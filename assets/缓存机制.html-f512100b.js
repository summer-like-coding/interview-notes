import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{o as c,c as d,b as i,a as t,d as e}from"./app-232346ce.js";const a="/interview-notes/assets/强制缓存-634a5e2a.png",n="/interview-notes/assets/总结-9aea179f.png",r={},s=t('<h2 id="什么是浏览器的缓存机制" tabindex="-1"><a class="header-anchor" href="#什么是浏览器的缓存机制" aria-hidden="true">#</a> 什么是浏览器的缓存机制</h2><p>浏览器缓存机制又可以称为是<code>Http</code>缓存机制`，是指浏览器对于静态资源的缓存策略。 对于一些<strong>重复性</strong>的请求，浏览器会将请求的资源缓存起来，当下次请求时，如果资源没有发生变化，就会直接从缓存中获取，而不是再次向服务器发起请求。</p><p>实现<code>HTTP</code>缓存的方式有很多，但是大体上可以分为两种：</p><ul><li>强制缓存</li><li>协商缓存</li></ul><h2 id="强制缓存" tabindex="-1"><a class="header-anchor" href="#强制缓存" aria-hidden="true">#</a> 强制缓存</h2><p>浏览器在第一次请求资源时，服务器会将资源的缓存策略一起返回给浏览器，<strong>浏览器会根据缓存策略来决定是否缓存资源</strong>。<strong>由浏览器来决定，是不是使用缓存</strong>，而不是由服务器来决定。</p><p>强制缓存主要使用的是响应头中的两个字段：<code>Expires</code>和<code>Cache-Control</code>。</p><ul><li><code>Expires</code>：是一个绝对时间，用来指定资源的过期时间，即到了这个时间，浏览器就会向服务器发起请求，如果没有发生变化，就会使用缓存。 <strong>但是到了<code>HTTP1.1</code>以后，<code>Expires</code>就被<code>Cache-COntrol</code>替换了</strong>，这是因为，<code>Expires</code>是一个绝对时间，是由服务器来设置的，如果服务器的时间和浏览器的时间不一致，就会导致缓存失效，但是浏览器第二次请求时，服务器的时间和浏览器的时间可能就一致了，这样就会导致缓存生效，但是实际上，资源已经发生了变化，这样就会导致缓存失效。</li><li><code>Cache-Control</code>：是一个相对时间，用来指定资源的过期时间，即到了这个时间，浏览器就会向服务器发起请求，如果没有发生变化，就会使用缓存。 <code>Cache-Control</code>的值有很多，常用的有以下几个： <ul><li><code>no-cache</code>：不使用强制缓存，但是会使用<strong>协商缓存</strong>。</li><li><code>no-store</code>：不使用强制缓存，也不使用协商缓存。</li><li><code>max-age</code>：指定资源的过期时间，单位是秒，缓存内容将在这个时间之后失效。</li><li><code>s-maxage</code>：和<code>max-age</code>的作用一样，但是只针对于代理服务器，比如<code>CDN</code>。</li></ul></li></ul><p><strong><code>Cache-Control</code>的优先级要高于<code>Expires</code></strong></p><p>引申：浏览器缓存，那么将请求的资源缓存到哪里呢？ 浏览器缓存主要分为两种：<strong>内存缓存</strong>和<strong>硬盘缓存</strong></p><ul><li><p>内存缓存的优点是读取速度快，但是缺点是存储空间小，而且会随着浏览器(进程)的关闭而释放。</p></li><li><p>硬盘缓存的优点是存储空间大，而且不会随着浏览器的关闭而释放，但是缺点是读取速度慢。</p><p><strong>浏览器会将<code>js</code>和图片解析完成后将他们放在内存缓存中，将<code>css</code>文件会存放在硬盘中</strong></p><!-- 插入图片，浏览器强制缓存 --><figure><img src="'+a+'" alt="浏览器强制缓存" tabindex="0" loading="lazy"><figcaption>浏览器强制缓存</figcaption></figure></li></ul><h2 id="协商缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存" aria-hidden="true">#</a> 协商缓存</h2><p>协商缓存是指，当强制缓存失效以后，浏览器会携带<strong>缓存标识</strong>向服务器发起请求，由服务器根据<strong>缓存标识</strong>来决定是否使用缓存。</p><p>控制协商缓存的字段有两组：</p><ul><li><code>Last-Modified</code>和<code>If-Modified-Since</code>：表示的是时间，最后一次修改时间。</li><li><code>ETag</code>和<code>If-None-Match</code>：表示的是资源的唯一标识，是一个字符串。 <strong>其中，<code>Etag</code>的优先级会高一点</strong></li></ul><p>具体流程如下：</p><ul><li>当强制缓存失效后，浏览器再次发送请求到服务器，并且会在请求头里面携带<code>If-Modified-Since</code>或者<code>If-None-Match</code>字段，这两个字段的值分别是上一次请求返回的<code>Last-Modified</code>和<code>ETag</code>的值。</li><li>服务器接受到请求后，会根据<code>If-Modified-Since</code>或者<code>If-None-Match</code>的值和资源的最新修改时间或者<code>ETag</code>的值进行对比，如果没有发生变化，就会返回<code>304</code>，并且不会返回资源内容，浏览器就会使用缓存，如果发生了变化，就会返回<code>200</code>，并且返回资源内容，浏览器就会使用最新的资源。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(<code>Last-Modified</code> / <code>If-Modified-Since</code>和<code>ETag</code> / <code>If-None-Match</code>)，<strong>协商缓存由服务器决定是否使用缓存</strong>，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回 304，继续使用缓存。</p>',19),l=e("figure",null,[e("img",{src:n,alt:"浏览器缓存",tabindex:"0",loading:"lazy"}),e("figcaption",null,"浏览器缓存")],-1);function g(p,h){return c(),d("div",null,[s,i(" 插入图片 "),l])}const _=o(r,[["render",g],["__file","缓存机制.html.vue"]]);export{_ as default};
