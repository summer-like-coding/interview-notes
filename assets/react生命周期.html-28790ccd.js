import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as o,a as s}from"./app-c53be088.js";const a={},t=s(`<h2 id="什么是生命周期" tabindex="-1"><a class="header-anchor" href="#什么是生命周期" aria-hidden="true">#</a> 什么是生命周期</h2><p>生命周期是组件<strong>从实例化到销毁</strong>的过程，也就是组件<strong>从生成到消亡</strong>的过程，这个过程中会伴随着一些事件，这些事件就是生命周期函数。</p><p>生命周期分为三个状态：挂载(<code>Mounting</code>)、更新(<code>Updating</code>)、卸载(<code>Unmounting</code>)。</p><p>组件的生命周期分为三个阶段：</p><ul><li><code>render</code>阶段：从组件实例化到组件渲染完成的过程,用于计算当前的状态/更新信息，会根据产生的任务的优先级来决定是否执行，安排任务的调度</li><li><code>pre-commit</code>阶段：从组件开始渲染到组件渲染完成的过程</li><li><code>commit</code>阶段：从组件渲染完成到组件卸载的过程</li></ul><p>但是在<code>React17</code>之后，<code>render</code>阶段和<code>pre-commit</code>阶段合并为一个阶段，也就是说<code>React17</code>之后只有两个阶段：<code>render</code>阶段和<code>commit</code>阶段。</p><p>因为<code>react</code>在 16.3 版本之后，推出了<code>Fiber</code>架构，<code>Fiber</code>架构的目的是为了解决<code>react</code>在渲染过程中，如果渲染任务过多，会造成页面卡顿，用户体验不好的问题，所以<code>Fiber</code>架构的目的就是为了解决这个问题，<code>Fiber</code>架构的核心就是<code>render</code>阶段和<code>commit</code>阶段的分离，<code>render</code>阶段负责计算任务，<code>commit</code>阶段负责执行任务，这样就可以根据任务的优先级来安排任务的调度，从而解决了<code>react</code>在渲染过程中，导致页面卡顿的问题。这就带来了一些生命周期钩子被废弃。</p><h2 id="生命周期的分类" tabindex="-1"><a class="header-anchor" href="#生命周期的分类" aria-hidden="true">#</a> 生命周期的分类</h2><h3 id="_16-3-版本之前的生命周期" tabindex="-1"><a class="header-anchor" href="#_16-3-版本之前的生命周期" aria-hidden="true">#</a> 16.3 版本之前的生命周期</h3><h4 id="挂载阶段" tabindex="-1"><a class="header-anchor" href="#挂载阶段" aria-hidden="true">#</a> 挂载阶段</h4><ul><li><code>constructor</code>：构造函数，最先被执行，我们通常在构造函数里初始化组件的状态对象(<code>this.state</code>)或者给自定义方法绑定<code>this</code>。</li><li><code>componentWillMount</code>：组件即将被挂载到页面上之前执行，也就是在组件即将被渲染到页面之前执行，此时可以修改组件的状态对象(<code>this.state</code>)，这个方法在服务端渲染中也会被调用。</li><li><code>render</code>: 渲染函数，它是一个纯函数，只负责<strong>渲染组件</strong>。它具有以下特性： <ul><li>不能修改组件的状态对象(<code>this.state</code>)，可能会导致组件一直被重新渲染。</li><li>不能和浏览器进行交互，不能获取 DOM 元素。</li><li>只能通过<code>this.props</code>和<code>this.state</code>来获取数据。</li><li>只能返回一个顶级元素，不能返回多个顶级元素。</li></ul></li><li><code>componentDidMount(preProps,preState)</code>：组件已经被挂载到页面上之后执行，也就是在组件已经被渲染到页面之后执行，此时可以获取到真实的 DOM 元素。它具有以下特性： <ul><li>最早可以获取到真实 DOM 元素的钩子。</li></ul></li></ul><h4 id="更新阶段" tabindex="-1"><a class="header-anchor" href="#更新阶段" aria-hidden="true">#</a> 更新阶段</h4><ul><li><p><code>componentWillReceiveProps(nextProps)</code>：组件即将接收到新的<code>props</code>之前执行，也就是说，当一个组件从父组件接收到新的<code>props</code>之前执行，此时可以根据新的<code>props</code>来修改组件的状态对象(<code>this.state</code>)。 特性：</p><ul><li>在组件初始化渲染的时候不会执行，父组件被重新渲染(<code>state</code>发生变化)，这个方法也会被执行，即使父组件传递给子组件的<code>props</code>没有发生改变，这个方法也会被执行。</li><li>在这个钩子里面可以最早拿到新的<code>props</code>(父组件传递给子组件)，但是不能获取到组件之前的<code>props</code>。</li></ul></li><li><p><code>shouldComponentUpdate(nextProps,nextState)</code>：组件是否要被更新，也就是说，当一个组件接收到新的<code>props</code>或者<code>state</code>之后，<code>shouldComponentUpdate</code>会在组件重新渲染之前执行，此时我们可以根据新的<code>props</code>或者<code>state</code>来判断组件是否需要重新渲染，<strong>默认返回<code>true</code></strong>，如果返回<code>false</code>，那么这个组件就不会被重新渲染，这个生命周期函数主要用于<strong>性能优化</strong>。</p><ul><li>我们可以使用<code>Json.stringify()</code>来比较两个对象(<code>this.state</code>和<code>nextState</code>)是否相等，如果两个对象相等，那么就返回<code>false</code>，如果两个对象不相等，那么就返回<code>true</code>。</li></ul></li><li><p><code>componentWillUpdate(nextProps,nextState)</code>：组件即将被更新之前执行，也就是说，当一个组件要被重新渲染之前执行，此时可以根据新的<code>props</code>或者<code>state</code>来修改组件的状态对象(<code>this.state</code>)。</p></li><li><p><code>componentDidUpdate(preProps,preState)</code>：组件已经被更新之后执行，也就是说，当一个组件被重新渲染之后执行，此时可以获取到真实的 DOM 元素，比如：获取到<strong>真实的 DOM</strong>元素之后，可以使用第三方库来操作这个 DOM 元素。</p></li></ul><h4 id="卸载阶段" tabindex="-1"><a class="header-anchor" href="#卸载阶段" aria-hidden="true">#</a> 卸载阶段</h4><ul><li><code>componentWillUnmount</code>：组件即将被卸载之前执行，也就是说，当一个组件从页面上被移除之前执行，此时可以做一些清理工作，比如：清除定时器、取消网络请求、清除组件中的缓存等。</li></ul><p>但是上面的生命周期都是在<code>react16.3</code>之前的生命周期，<code>react16.3</code>之后的生命周期有所改变，<code>react16.3</code>之后的生命周期有以下几个：</p><h3 id="_16-3-版本之后的生命周期" tabindex="-1"><a class="header-anchor" href="#_16-3-版本之后的生命周期" aria-hidden="true">#</a> 16.3 版本之后的生命周期</h3><h4 id="挂载阶段-1" tabindex="-1"><a class="header-anchor" href="#挂载阶段-1" aria-hidden="true">#</a> 挂载阶段</h4><ul><li><p><code>constructor</code>：构造函数，最先被执行，我们通常在构造函数里初始化组件的状态对象(<code>this.state</code>)或者给自定义方法绑定<code>this</code>。</p></li><li><p><code>static getDerivedStateFromProps(props, state)</code>：这是一个静态方法，也就是说，这个方法不能访问到组件实例(<code>this</code>)，这个方法在组件实例化之后和接收到新的<code>props</code>之后执行，这个方法的返回值会被添加到组件的状态对象(<code>this.state</code>)中,用于<strong>性能优化</strong>。</p><ul><li>简单来说，这个方法的作用就是根据新的<code>props</code>来更新组件的状态对象(<code>this.state</code>)，这个方法的返回值会被添加到组件的状态对象(<code>this.state</code>)中，如果返回<code>null</code>，则不会更新组件的状态对象(<code>this.state</code>)，<strong>就是将<code>return</code>到的对象替换当前的<code>state</code></strong>。</li><li>他在第一次渲染的时候被调用，以后每次接收到新的<code>props</code>之后都会被调用。</li></ul></li><li><p><code>render</code>: 渲染函数，它是一个纯函数，只负责<strong>渲染组件</strong>。他和<code>react16.3</code>之前的<code>render</code>函数没有什么区别。</p></li></ul><h4 id="更新阶段-1" tabindex="-1"><a class="header-anchor" href="#更新阶段-1" aria-hidden="true">#</a> 更新阶段</h4><ul><li><p><code>getSnapshotBeforeUpdate(preProps,preState)</code>:这个方法在组件更新之前执行，此时可以获取到最新的 DOM 数据，在这个方法中返回的任何值都会作为参数传递给<code>componentDidUpdate</code>的第三个参数。</p><ul><li>简单来说，这个方法的作用就是在组件更新之前获取到最新的 DOM 数据，然后在<code>componentDidUpdate</code>中获取到这个方法的返回值。</li><li>这个方法的返回值会作为参数传递给<code>componentDidUpdate</code>的第三个参数。</li><li>这个方法在组件初始化渲染的时候不会被调用，只有在组件更新的时候才会被调用。</li></ul></li><li><p><code>shouldComponentUpdate(nextProps,nextState)</code>：组件是否要被更新,用于<strong>性能优化</strong>。和<code>react16.3</code>之前的<code>shouldComponentUpdate</code>没有什么区别。</p></li><li><p><code>componentDidUpdate(preProps,preState,snapshot)</code>：组件已经被更新之后执行，也就是说，当一个组件被重新渲染之后执行，此时可以获取到真实的 DOM 元素。也可以在这个钩子里面根据<code>preProps</code>和<code>preState</code>来做一些<strong>性能优化</strong>。但是如果你要在这个钩子里面使用<code>this.setState</code>来修改状态的话，必须要有一个<strong>条件限制</strong>（判断 props），否则会导致组件陷入死循环。</p></li></ul><h4 id="卸载阶段-1" tabindex="-1"><a class="header-anchor" href="#卸载阶段-1" aria-hidden="true">#</a> 卸载阶段</h4><ul><li><code>componentWillUnmount</code>：组件即将被卸载之前执行，也就是说，当一个组件从页面上被移除之前执行，此时可以做一些清理工作，比如：清除定时器、取消网络请求、清除组件中的缓存等。</li></ul><p>上述介绍的所有生命周期钩子，都是借助<code>React</code>的<code>class</code>组件来实现的，但是在<code>React16.8</code>之后，新增了一个<code>hook</code>函数，可以让我们在不使用<code>class</code>组件的情况下使用生命周期钩子。</p><h3 id="hook函数" tabindex="-1"><a class="header-anchor" href="#hook函数" aria-hidden="true">#</a> <code>hook</code>函数</h3><p><code>hook</code>函数是<code>React16.8</code>之后新增的一个函数，可以让我们在不使用<code>class</code>组件的情况下使用生命周期钩子。</p><p>其实严格来说，<code>hook</code>函数并不是生命周期钩子，它只是模拟了生命周期钩子的功能，因为，<strong>生命周期函数都是<code>react.component</code>的方法，函数组件并没有继承，所以也不会拥有</strong></p><ul><li><code>useEffect</code>: 这个函数的作用就相当于<code>componentDidMount</code>、<code>componentDidUpdate</code>和<code>componentWillUnmount</code>这三个生命周期函数的集合。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;组件挂载完成&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;组件即将被卸载&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>你点击了<span class="token punctuation">{</span>count<span class="token punctuation">}</span>次<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>点击<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,29),c=[t];function p(d,i){return n(),o("div",null,c)}const u=e(a,[["render",p],["__file","react生命周期.html.vue"]]);export{u as default};
