var O=function(){return O=Object.assign||function(t){for(var e,i=1,n=arguments.length;i<n;i++){e=arguments[i];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}return t},O.apply(this,arguments)};function yt(a,t,e,i){function n(r){return r instanceof e?r:new e(function(u){u(r)})}return new(e||(e=Promise))(function(r,u){function o(s){try{h(i.next(s))}catch(f){u(f)}}function l(s){try{h(i.throw(s))}catch(f){u(f)}}function h(s){s.done?r(s.value):n(s.value).then(o,l)}h((i=i.apply(a,t||[])).next())})}function pt(a,t){var e={label:0,sent:function(){if(r[0]&1)throw r[1];return r[1]},trys:[],ops:[]},i,n,r,u;return u={next:o(0),throw:o(1),return:o(2)},typeof Symbol=="function"&&(u[Symbol.iterator]=function(){return this}),u;function o(h){return function(s){return l([h,s])}}function l(h){if(i)throw new TypeError("Generator is already executing.");for(;u&&(u=0,h[0]&&(e=0)),e;)try{if(i=1,n&&(r=h[0]&2?n.return:h[0]?n.throw||((r=n.return)&&r.call(n),0):n.next)&&!(r=r.call(n,h[1])).done)return r;switch(n=0,r&&(h=[h[0]&2,r.value]),h[0]){case 0:case 1:r=h;break;case 4:return e.label++,{value:h[1],done:!1};case 5:e.label++,n=h[1],h=[0];continue;case 7:h=e.ops.pop(),e.trys.pop();continue;default:if(r=e.trys,!(r=r.length>0&&r[r.length-1])&&(h[0]===6||h[0]===2)){e=0;continue}if(h[0]===3&&(!r||h[1]>r[0]&&h[1]<r[3])){e.label=h[1];break}if(h[0]===6&&e.label<r[1]){e.label=r[1],r=h;break}if(r&&e.label<r[2]){e.label=r[2],e.ops.push(h);break}r[2]&&e.ops.pop(),e.trys.pop();continue}h=t.call(a,e)}catch(s){h=[6,s],n=0}finally{i=r=0}if(h[0]&5)throw h[1];return{value:h[0]?h[1]:void 0,done:!0}}}function F(a){var t=typeof Symbol=="function"&&Symbol.iterator,e=t&&a[t],i=0;if(e)return e.call(a);if(a&&typeof a.length=="number")return{next:function(){return a&&i>=a.length&&(a=void 0),{value:a&&a[i++],done:!a}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function _(a,t){var e=typeof Symbol=="function"&&a[Symbol.iterator];if(!e)return a;var i=e.call(a),n,r=[],u;try{for(;(t===void 0||t-- >0)&&!(n=i.next()).done;)r.push(n.value)}catch(o){u={error:o}}finally{try{n&&!n.done&&(e=i.return)&&e.call(i)}finally{if(u)throw u.error}}return r}var mt="ENTRIES",it="KEYS",at="VALUES",I="",K=function(){function a(t,e){var i=t._tree,n=Array.from(i.keys());this.set=t,this._type=e,this._path=n.length>0?[{node:i,keys:n}]:[]}return a.prototype.next=function(){var t=this.dive();return this.backtrack(),t},a.prototype.dive=function(){if(this._path.length===0)return{done:!0,value:void 0};var t=N(this._path),e=t.node,i=t.keys;if(N(i)===I)return{done:!1,value:this.result()};var n=e.get(N(i));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()},a.prototype.backtrack=function(){if(this._path.length!==0){var t=N(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}},a.prototype.key=function(){return this.set._prefix+this._path.map(function(t){var e=t.keys;return N(e)}).filter(function(t){return t!==I}).join("")},a.prototype.value=function(){return N(this._path).node.get(I)},a.prototype.result=function(){switch(this._type){case at:return this.value();case it:return this.key();default:return[this.key(),this.value()]}},a.prototype[Symbol.iterator]=function(){return this},a}(),N=function(a){return a[a.length-1]},gt=function(a,t,e){var i=new Map;if(t===void 0)return i;for(var n=t.length+1,r=n+e,u=new Uint8Array(r*n).fill(e+1),o=0;o<n;++o)u[o]=o;for(var l=1;l<r;++l)u[l*n]=l;return ut(a,t,e,i,u,1,n,""),i},ut=function(a,t,e,i,n,r,u,o){var l,h,s=r*u;try{t:for(var f=F(a.keys()),c=f.next();!c.done;c=f.next()){var v=c.value;if(v===I){var d=n[s-1];d<=e&&i.set(o,[a.get(v),d])}else{for(var p=r,y=0;y<v.length;++y,++p){for(var g=v[y],w=u*p,m=w-u,b=n[w],z=Math.max(0,p-e-1),V=Math.min(u-1,p+e),x=z;x<V;++x){var C=g!==t[x],S=n[m+x]+ +C,E=n[m+x+1]+1,M=n[w+x]+1,A=n[w+x+1]=Math.min(S,E,M);A<b&&(b=A)}if(b>e)continue t}ut(a.get(v),t,e,i,n,p,u,o+v)}}}catch(L){l={error:L}}finally{try{c&&!c.done&&(h=f.return)&&h.call(f)}finally{if(l)throw l.error}}},Y=function(){function a(t,e){t===void 0&&(t=new Map),e===void 0&&(e=""),this._size=void 0,this._tree=t,this._prefix=e}return a.prototype.atPrefix=function(t){var e,i;if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");var n=_(R(this._tree,t.slice(this._prefix.length)),2),r=n[0],u=n[1];if(r===void 0){var o=_(Z(u),2),l=o[0],h=o[1];try{for(var s=F(l.keys()),f=s.next();!f.done;f=s.next()){var c=f.value;if(c!==I&&c.startsWith(h)){var v=new Map;return v.set(c.slice(h.length),l.get(c)),new a(v,t)}}}catch(d){e={error:d}}finally{try{f&&!f.done&&(i=s.return)&&i.call(s)}finally{if(e)throw e.error}}}return new a(r,t)},a.prototype.clear=function(){this._size=void 0,this._tree.clear()},a.prototype.delete=function(t){return this._size=void 0,Ft(this._tree,t)},a.prototype.entries=function(){return new K(this,mt)},a.prototype.forEach=function(t){var e,i;try{for(var n=F(this),r=n.next();!r.done;r=n.next()){var u=_(r.value,2),o=u[0],l=u[1];t(o,l,this)}}catch(h){e={error:h}}finally{try{r&&!r.done&&(i=n.return)&&i.call(n)}finally{if(e)throw e.error}}},a.prototype.fuzzyGet=function(t,e){return gt(this._tree,t,e)},a.prototype.get=function(t){var e=H(this._tree,t);return e!==void 0?e.get(I):void 0},a.prototype.has=function(t){var e=H(this._tree,t);return e!==void 0&&e.has(I)},a.prototype.keys=function(){return new K(this,it)},a.prototype.set=function(t,e){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;var i=X(this._tree,t);return i.set(I,e),this},Object.defineProperty(a.prototype,"size",{get:function(){if(this._size)return this._size;this._size=0;for(var t=this.entries();!t.next().done;)this._size+=1;return this._size},enumerable:!1,configurable:!0}),a.prototype.update=function(t,e){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;var i=X(this._tree,t);return i.set(I,e(i.get(I))),this},a.prototype.fetch=function(t,e){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;var i=X(this._tree,t),n=i.get(I);return n===void 0&&i.set(I,n=e()),n},a.prototype.values=function(){return new K(this,at)},a.prototype[Symbol.iterator]=function(){return this.entries()},a.from=function(t){var e,i,n=new a;try{for(var r=F(t),u=r.next();!u.done;u=r.next()){var o=_(u.value,2),l=o[0],h=o[1];n.set(l,h)}}catch(s){e={error:s}}finally{try{u&&!u.done&&(i=r.return)&&i.call(r)}finally{if(e)throw e.error}}return n},a.fromObject=function(t){return a.from(Object.entries(t))},a}(),R=function(a,t,e){var i,n;if(e===void 0&&(e=[]),t.length===0||a==null)return[a,e];try{for(var r=F(a.keys()),u=r.next();!u.done;u=r.next()){var o=u.value;if(o!==I&&t.startsWith(o))return e.push([a,o]),R(a.get(o),t.slice(o.length),e)}}catch(l){i={error:l}}finally{try{u&&!u.done&&(n=r.return)&&n.call(r)}finally{if(i)throw i.error}}return e.push([a,t]),R(void 0,"",e)},H=function(a,t){var e,i;if(t.length===0||a==null)return a;try{for(var n=F(a.keys()),r=n.next();!r.done;r=n.next()){var u=r.value;if(u!==I&&t.startsWith(u))return H(a.get(u),t.slice(u.length))}}catch(o){e={error:o}}finally{try{r&&!r.done&&(i=n.return)&&i.call(n)}finally{if(e)throw e.error}}},X=function(a,t){var e,i,n=t.length;t:for(var r=0;a&&r<n;){try{for(var u=(e=void 0,F(a.keys())),o=u.next();!o.done;o=u.next()){var l=o.value;if(l!==I&&t[r]===l[0]){for(var h=Math.min(n-r,l.length),s=1;s<h&&t[r+s]===l[s];)++s;var f=a.get(l);if(s===l.length)a=f;else{var c=new Map;c.set(l.slice(s),f),a.set(t.slice(r,r+s),c),a.delete(l),a=c}r+=s;continue t}}}catch(d){e={error:d}}finally{try{o&&!o.done&&(i=u.return)&&i.call(u)}finally{if(e)throw e.error}}var v=new Map;return a.set(t.slice(r),v),v}return a},Ft=function(a,t){var e=_(R(a,t),2),i=e[0],n=e[1];if(i!==void 0){if(i.delete(I),i.size===0)ot(n);else if(i.size===1){var r=_(i.entries().next().value,2),u=r[0],o=r[1];lt(n,u,o)}}},ot=function(a){if(a.length!==0){var t=_(Z(a),2),e=t[0],i=t[1];if(e.delete(i),e.size===0)ot(a.slice(0,-1));else if(e.size===1){var n=_(e.entries().next().value,2),r=n[0],u=n[1];r!==I&&lt(a.slice(0,-1),r,u)}}},lt=function(a,t,e){if(a.length!==0){var i=_(Z(a),2),n=i[0],r=i[1];n.set(r+t,e),n.delete(r)}},Z=function(a){return a[a.length-1]},J,j="or",ht="and",wt="and_not",xt=function(){function a(t){if((t==null?void 0:t.fields)==null)throw new Error('MiniSearch: option "fields" must be provided');var e=t.autoVacuum==null||t.autoVacuum===!0?nt:t.autoVacuum;this._options=O(O(O({},tt),t),{autoVacuum:e,searchOptions:O(O({},st),t.searchOptions||{}),autoSuggestOptions:O(O({},St),t.autoSuggestOptions||{})}),this._index=new Y,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=rt,this.addFields(this._options.fields)}return a.prototype.add=function(t){var e,i,n,r,u,o,l=this._options,h=l.extractField,s=l.tokenize,f=l.processTerm,c=l.fields,v=l.idField,d=h(t,v);if(d==null)throw new Error('MiniSearch: document does not have ID field "'.concat(v,'"'));if(this._idToShortId.has(d))throw new Error("MiniSearch: duplicate ID ".concat(d));var p=this.addDocumentId(d);this.saveStoredFields(p,t);try{for(var y=F(c),g=y.next();!g.done;g=y.next()){var w=g.value,m=h(t,w);if(m!=null){var b=s(m.toString(),w),z=this._fieldIds[w],V=new Set(b).size;this.addFieldLength(p,z,this._documentCount-1,V);try{for(var x=(n=void 0,F(b)),C=x.next();!C.done;C=x.next()){var S=C.value,E=f(S,w);if(Array.isArray(E))try{for(var M=(u=void 0,F(E)),A=M.next();!A.done;A=M.next()){var L=A.value;this.addTerm(z,p,L)}}catch(D){u={error:D}}finally{try{A&&!A.done&&(o=M.return)&&o.call(M)}finally{if(u)throw u.error}}else E&&this.addTerm(z,p,E)}}catch(D){n={error:D}}finally{try{C&&!C.done&&(r=x.return)&&r.call(x)}finally{if(n)throw n.error}}}}}catch(D){e={error:D}}finally{try{g&&!g.done&&(i=y.return)&&i.call(y)}finally{if(e)throw e.error}}},a.prototype.addAll=function(t){var e,i;try{for(var n=F(t),r=n.next();!r.done;r=n.next()){var u=r.value;this.add(u)}}catch(o){e={error:o}}finally{try{r&&!r.done&&(i=n.return)&&i.call(n)}finally{if(e)throw e.error}}},a.prototype.addAllAsync=function(t,e){var i=this;e===void 0&&(e={});var n=e.chunkSize,r=n===void 0?10:n,u={chunk:[],promise:Promise.resolve()},o=t.reduce(function(s,f,c){var v=s.chunk,d=s.promise;return v.push(f),(c+1)%r===0?{chunk:[],promise:d.then(function(){return new Promise(function(p){return setTimeout(p,0)})}).then(function(){return i.addAll(v)})}:{chunk:v,promise:d}},u),l=o.chunk,h=o.promise;return h.then(function(){return i.addAll(l)})},a.prototype.remove=function(t){var e,i,n,r,u,o,l=this._options,h=l.tokenize,s=l.processTerm,f=l.extractField,c=l.fields,v=l.idField,d=f(t,v);if(d==null)throw new Error('MiniSearch: document does not have ID field "'.concat(v,'"'));var p=this._idToShortId.get(d);if(p==null)throw new Error("MiniSearch: cannot remove document with ID ".concat(d,": it is not in the index"));try{for(var y=F(c),g=y.next();!g.done;g=y.next()){var w=g.value,m=f(t,w);if(m!=null){var b=h(m.toString(),w),z=this._fieldIds[w],V=new Set(b).size;this.removeFieldLength(p,z,this._documentCount,V);try{for(var x=(n=void 0,F(b)),C=x.next();!C.done;C=x.next()){var S=C.value,E=s(S,w);if(Array.isArray(E))try{for(var M=(u=void 0,F(E)),A=M.next();!A.done;A=M.next()){var L=A.value;this.removeTerm(z,p,L)}}catch(D){u={error:D}}finally{try{A&&!A.done&&(o=M.return)&&o.call(M)}finally{if(u)throw u.error}}else E&&this.removeTerm(z,p,E)}}catch(D){n={error:D}}finally{try{C&&!C.done&&(r=x.return)&&r.call(x)}finally{if(n)throw n.error}}}}}catch(D){e={error:D}}finally{try{g&&!g.done&&(i=y.return)&&i.call(y)}finally{if(e)throw e.error}}this._storedFields.delete(p),this._documentIds.delete(p),this._idToShortId.delete(d),this._fieldLength.delete(p),this._documentCount-=1},a.prototype.removeAll=function(t){var e,i;if(t)try{for(var n=F(t),r=n.next();!r.done;r=n.next()){var u=r.value;this.remove(u)}}catch(o){e={error:o}}finally{try{r&&!r.done&&(i=n.return)&&i.call(n)}finally{if(e)throw e.error}}else{if(arguments.length>0)throw new Error("Expected documents to be present. Omit the argument to remove all documents.");this._index=new Y,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldLength=new Map,this._avgFieldLength=[],this._storedFields=new Map,this._nextId=0}},a.prototype.discard=function(t){var e=this,i=this._idToShortId.get(t);if(i==null)throw new Error("MiniSearch: cannot discard document with ID ".concat(t,": it is not in the index"));this._idToShortId.delete(t),this._documentIds.delete(i),this._storedFields.delete(i),(this._fieldLength.get(i)||[]).forEach(function(n,r){e.removeFieldLength(i,r,e._documentCount,n)}),this._fieldLength.delete(i),this._documentCount-=1,this._dirtCount+=1,this.maybeAutoVacuum()},a.prototype.maybeAutoVacuum=function(){if(this._options.autoVacuum!==!1){var t=this._options.autoVacuum,e=t.minDirtFactor,i=t.minDirtCount,n=t.batchSize,r=t.batchWait;this.conditionalVacuum({batchSize:n,batchWait:r},{minDirtCount:i,minDirtFactor:e})}},a.prototype.discardAll=function(t){var e,i,n=this._options.autoVacuum;try{this._options.autoVacuum=!1;try{for(var r=F(t),u=r.next();!u.done;u=r.next()){var o=u.value;this.discard(o)}}catch(l){e={error:l}}finally{try{u&&!u.done&&(i=r.return)&&i.call(r)}finally{if(e)throw e.error}}}finally{this._options.autoVacuum=n}this.maybeAutoVacuum()},a.prototype.replace=function(t){var e=this._options,i=e.idField,n=e.extractField,r=n(t,i);this.discard(r),this.add(t)},a.prototype.vacuum=function(t){return t===void 0&&(t={}),this.conditionalVacuum(t)},a.prototype.conditionalVacuum=function(t,e){var i=this;return this._currentVacuum?(this._enqueuedVacuumConditions=this._enqueuedVacuumConditions&&e,this._enqueuedVacuum!=null?this._enqueuedVacuum:(this._enqueuedVacuum=this._currentVacuum.then(function(){var n=i._enqueuedVacuumConditions;return i._enqueuedVacuumConditions=rt,i.performVacuuming(t,n)}),this._enqueuedVacuum)):this.vacuumConditionsMet(e)===!1?Promise.resolve():(this._currentVacuum=this.performVacuuming(t),this._currentVacuum)},a.prototype.performVacuuming=function(t,e){return yt(this,void 0,void 0,function(){var i,n,r,u,o,l,h,s,f,c,v,d,p,y,g,w,m,b,z,V,x,C,S,E,M;return pt(this,function(A){switch(A.label){case 0:if(i=this._dirtCount,!this.vacuumConditionsMet(e))return[3,10];n=t.batchSize||et.batchSize,r=t.batchWait||et.batchWait,u=1,A.label=1;case 1:A.trys.push([1,7,8,9]),o=F(this._index),l=o.next(),A.label=2;case 2:if(l.done)return[3,6];h=_(l.value,2),s=h[0],f=h[1];try{for(c=(C=void 0,F(f)),v=c.next();!v.done;v=c.next()){d=_(v.value,2),p=d[0],y=d[1];try{for(g=(E=void 0,F(y)),w=g.next();!w.done;w=g.next())m=_(w.value,1),b=m[0],!this._documentIds.has(b)&&(y.size<=1?f.delete(p):y.delete(b))}catch(L){E={error:L}}finally{try{w&&!w.done&&(M=g.return)&&M.call(g)}finally{if(E)throw E.error}}}}catch(L){C={error:L}}finally{try{v&&!v.done&&(S=c.return)&&S.call(c)}finally{if(C)throw C.error}}return this._index.get(s).size===0&&this._index.delete(s),u%n!==0?[3,4]:[4,new Promise(function(L){return setTimeout(L,r)})];case 3:A.sent(),A.label=4;case 4:u+=1,A.label=5;case 5:return l=o.next(),[3,2];case 6:return[3,9];case 7:return z=A.sent(),V={error:z},[3,9];case 8:try{l&&!l.done&&(x=o.return)&&x.call(o)}finally{if(V)throw V.error}return[7];case 9:this._dirtCount-=i,A.label=10;case 10:return[4,null];case 11:return A.sent(),this._currentVacuum=this._enqueuedVacuum,this._enqueuedVacuum=null,[2]}})})},a.prototype.vacuumConditionsMet=function(t){if(t==null)return!0;var e=t.minDirtCount,i=t.minDirtFactor;return e=e||nt.minDirtCount,i=i||nt.minDirtFactor,this.dirtCount>=e&&this.dirtFactor>=i},Object.defineProperty(a.prototype,"isVacuuming",{get:function(){return this._currentVacuum!=null},enumerable:!1,configurable:!0}),Object.defineProperty(a.prototype,"dirtCount",{get:function(){return this._dirtCount},enumerable:!1,configurable:!0}),Object.defineProperty(a.prototype,"dirtFactor",{get:function(){return this._dirtCount/(1+this._documentCount+this._dirtCount)},enumerable:!1,configurable:!0}),a.prototype.has=function(t){return this._idToShortId.has(t)},a.prototype.getStoredFields=function(t){var e=this._idToShortId.get(t);if(e!=null)return this._storedFields.get(e)},a.prototype.search=function(t,e){var i,n;e===void 0&&(e={});var r=this.executeQuery(t,e),u=[];try{for(var o=F(r),l=o.next();!l.done;l=o.next()){var h=_(l.value,2),s=h[0],f=h[1],c=f.score,v=f.terms,d=f.match,p=v.length,y={id:this._documentIds.get(s),score:c*p,terms:Object.keys(d),match:d};Object.assign(y,this._storedFields.get(s)),(e.filter==null||e.filter(y))&&u.push(y)}}catch(g){i={error:g}}finally{try{l&&!l.done&&(n=o.return)&&n.call(o)}finally{if(i)throw i.error}}return u.sort(ct),u},a.prototype.autoSuggest=function(t,e){var i,n,r,u;e===void 0&&(e={}),e=O(O({},this._options.autoSuggestOptions),e);var o=new Map;try{for(var l=F(this.search(t,e)),h=l.next();!h.done;h=l.next()){var s=h.value,f=s.score,c=s.terms,v=c.join(" "),d=o.get(v);d!=null?(d.score+=f,d.count+=1):o.set(v,{score:f,terms:c,count:1})}}catch(z){i={error:z}}finally{try{h&&!h.done&&(n=l.return)&&n.call(l)}finally{if(i)throw i.error}}var p=[];try{for(var y=F(o),g=y.next();!g.done;g=y.next()){var w=_(g.value,2),d=w[0],m=w[1],f=m.score,c=m.terms,b=m.count;p.push({suggestion:d,terms:c,score:f/b})}}catch(z){r={error:z}}finally{try{g&&!g.done&&(u=y.return)&&u.call(y)}finally{if(r)throw r.error}}return p.sort(ct),p},Object.defineProperty(a.prototype,"documentCount",{get:function(){return this._documentCount},enumerable:!1,configurable:!0}),Object.defineProperty(a.prototype,"termCount",{get:function(){return this._index.size},enumerable:!1,configurable:!0}),a.loadJSON=function(t,e){if(e==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJS(JSON.parse(t),e)},a.getDefault=function(t){if(tt.hasOwnProperty(t))return q(tt,t);throw new Error('MiniSearch: unknown option "'.concat(t,'"'))},a.loadJS=function(t,e){var i,n,r,u,o,l,h=t.index,s=t.documentCount,f=t.nextId,c=t.documentIds,v=t.fieldIds,d=t.fieldLength,p=t.averageFieldLength,y=t.storedFields,g=t.dirtCount,w=t.serializationVersion;if(w!==1&&w!==2)throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");var m=new a(e);m._documentCount=s,m._nextId=f,m._documentIds=$(c),m._idToShortId=new Map,m._fieldIds=v,m._fieldLength=$(d),m._avgFieldLength=p,m._storedFields=$(y),m._dirtCount=g||0,m._index=new Y;try{for(var b=F(m._documentIds),z=b.next();!z.done;z=b.next()){var V=_(z.value,2),x=V[0],C=V[1];m._idToShortId.set(C,x)}}catch(P){i={error:P}}finally{try{z&&!z.done&&(n=b.return)&&n.call(b)}finally{if(i)throw i.error}}try{for(var S=F(h),E=S.next();!E.done;E=S.next()){var M=_(E.value,2),A=M[0],L=M[1],D=new Map;try{for(var k=(o=void 0,F(Object.keys(L))),B=k.next();!B.done;B=k.next()){var T=B.value,W=L[T];w===1&&(W=W.ds),D.set(parseInt(T,10),$(W))}}catch(P){o={error:P}}finally{try{B&&!B.done&&(l=k.return)&&l.call(k)}finally{if(o)throw o.error}}m._index.set(A,D)}}catch(P){r={error:P}}finally{try{E&&!E.done&&(u=S.return)&&u.call(S)}finally{if(r)throw r.error}}return m},a.prototype.executeQuery=function(t,e){var i=this;if(e===void 0&&(e={}),typeof t!="string"){var n=O(O(O({},e),t),{queries:void 0}),r=t.queries.map(function(y){return i.executeQuery(y,n)});return this.combineResults(r,n.combineWith)}var u=this._options,o=u.tokenize,l=u.processTerm,h=u.searchOptions,s=O(O({tokenize:o,processTerm:l},h),e),f=s.tokenize,c=s.processTerm,v=f(t).flatMap(function(y){return c(y)}).filter(function(y){return!!y}),d=v.map(zt(s)),p=d.map(function(y){return i.executeQuerySpec(y,s)});return this.combineResults(p,s.combineWith)},a.prototype.executeQuerySpec=function(t,e){var i,n,r,u,o=O(O({},this._options.searchOptions),e),l=(o.fields||this._options.fields).reduce(function(T,W){var P;return O(O({},T),(P={},P[W]=q(o.boost,W)||1,P))},{}),h=o.boostDocument,s=o.weights,f=o.maxFuzzy,c=o.bm25,v=O(O({},st.weights),s),d=v.fuzzy,p=v.prefix,y=this._index.get(t.term),g=this.termResults(t.term,t.term,1,y,l,h,c),w,m;if(t.prefix&&(w=this._index.atPrefix(t.term)),t.fuzzy){var b=t.fuzzy===!0?.2:t.fuzzy,z=b<1?Math.min(f,Math.round(t.term.length*b)):b;z&&(m=this._index.fuzzyGet(t.term,z))}if(w)try{for(var V=F(w),x=V.next();!x.done;x=V.next()){var C=_(x.value,2),S=C[0],E=C[1],M=S.length-t.term.length;if(M){m==null||m.delete(S);var A=p*S.length/(S.length+.3*M);this.termResults(t.term,S,A,E,l,h,c,g)}}}catch(T){i={error:T}}finally{try{x&&!x.done&&(n=V.return)&&n.call(V)}finally{if(i)throw i.error}}if(m)try{for(var L=F(m.keys()),D=L.next();!D.done;D=L.next()){var S=D.value,k=_(m.get(S),2),B=k[0],M=k[1];if(M){var A=d*S.length/(S.length+M);this.termResults(t.term,S,A,B,l,h,c,g)}}}catch(T){r={error:T}}finally{try{D&&!D.done&&(u=L.return)&&u.call(L)}finally{if(r)throw r.error}}return g},a.prototype.combineResults=function(t,e){if(e===void 0&&(e=j),t.length===0)return new Map;var i=e.toLowerCase();return t.reduce(At[i])||new Map},a.prototype.toJSON=function(){var t,e,i,n,r=[];try{for(var u=F(this._index),o=u.next();!o.done;o=u.next()){var l=_(o.value,2),h=l[0],s=l[1],f={};try{for(var c=(i=void 0,F(s)),v=c.next();!v.done;v=c.next()){var d=_(v.value,2),p=d[0],y=d[1];f[p]=Object.fromEntries(y)}}catch(g){i={error:g}}finally{try{v&&!v.done&&(n=c.return)&&n.call(c)}finally{if(i)throw i.error}}r.push([h,f])}}catch(g){t={error:g}}finally{try{o&&!o.done&&(e=u.return)&&e.call(u)}finally{if(t)throw t.error}}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:r,serializationVersion:2}},a.prototype.termResults=function(t,e,i,n,r,u,o,l){var h,s,f,c,v;if(l===void 0&&(l=new Map),n==null)return l;try{for(var d=F(Object.keys(r)),p=d.next();!p.done;p=d.next()){var y=p.value,g=r[y],w=this._fieldIds[y],m=n.get(w);if(m!=null){var b=m.size,z=this._avgFieldLength[w];try{for(var V=(f=void 0,F(m.keys())),x=V.next();!x.done;x=V.next()){var C=x.value;if(!this._documentIds.has(C)){this.removeTerm(w,C,e),b-=1;continue}var S=u?u(this._documentIds.get(C),e,this._storedFields.get(C)):1;if(S){var E=m.get(C),M=this._fieldLength.get(C)[w],A=bt(E,b,this._documentCount,M,z,o),L=i*g*S*A,D=l.get(C);if(D){D.score+=L,Et(D.terms,t);var k=q(D.match,e);k?k.push(y):D.match[e]=[y]}else l.set(C,{score:L,terms:[t],match:(v={},v[e]=[y],v)})}}}catch(B){f={error:B}}finally{try{x&&!x.done&&(c=V.return)&&c.call(V)}finally{if(f)throw f.error}}}}}catch(B){h={error:B}}finally{try{p&&!p.done&&(s=d.return)&&s.call(d)}finally{if(h)throw h.error}}return l},a.prototype.addTerm=function(t,e,i){var n=this._index.fetch(i,vt),r=n.get(t);if(r==null)r=new Map,r.set(e,1),n.set(t,r);else{var u=r.get(e);r.set(e,(u||0)+1)}},a.prototype.removeTerm=function(t,e,i){if(!this._index.has(i)){this.warnDocumentChanged(e,t,i);return}var n=this._index.fetch(i,vt),r=n.get(t);r==null||r.get(e)==null?this.warnDocumentChanged(e,t,i):r.get(e)<=1?r.size<=1?n.delete(t):r.delete(e):r.set(e,r.get(e)-1),this._index.get(i).size===0&&this._index.delete(i)},a.prototype.warnDocumentChanged=function(t,e,i){var n,r;try{for(var u=F(Object.keys(this._fieldIds)),o=u.next();!o.done;o=u.next()){var l=o.value;if(this._fieldIds[l]===e){this._options.logger("warn","MiniSearch: document with ID ".concat(this._documentIds.get(t),' has changed before removal: term "').concat(i,'" was not present in field "').concat(l,'". Removing a document after it has changed can corrupt the index!'),"version_conflict");return}}}catch(h){n={error:h}}finally{try{o&&!o.done&&(r=u.return)&&r.call(u)}finally{if(n)throw n.error}}},a.prototype.addDocumentId=function(t){var e=this._nextId;return this._idToShortId.set(t,e),this._documentIds.set(e,t),this._documentCount+=1,this._nextId+=1,e},a.prototype.addFields=function(t){for(var e=0;e<t.length;e++)this._fieldIds[t[e]]=e},a.prototype.addFieldLength=function(t,e,i,n){var r=this._fieldLength.get(t);r==null&&this._fieldLength.set(t,r=[]),r[e]=n;var u=this._avgFieldLength[e]||0,o=u*i+n;this._avgFieldLength[e]=o/(i+1)},a.prototype.removeFieldLength=function(t,e,i,n){if(i===1){this._avgFieldLength[e]=0;return}var r=this._avgFieldLength[e]*i-n;this._avgFieldLength[e]=r/(i-1)},a.prototype.saveStoredFields=function(t,e){var i,n,r=this._options,u=r.storeFields,o=r.extractField;if(!(u==null||u.length===0)){var l=this._storedFields.get(t);l==null&&this._storedFields.set(t,l={});try{for(var h=F(u),s=h.next();!s.done;s=h.next()){var f=s.value,c=o(e,f);c!==void 0&&(l[f]=c)}}catch(v){i={error:v}}finally{try{s&&!s.done&&(n=h.return)&&n.call(h)}finally{if(i)throw i.error}}}},a}(),q=function(a,t){return Object.prototype.hasOwnProperty.call(a,t)?a[t]:void 0},At=(J={},J[j]=function(a,t){var e,i;try{for(var n=F(t.keys()),r=n.next();!r.done;r=n.next()){var u=r.value,o=a.get(u);if(o==null)a.set(u,t.get(u));else{var l=t.get(u),h=l.score,s=l.terms,f=l.match;o.score=o.score+h,o.match=Object.assign(o.match,f),ft(o.terms,s)}}}catch(c){e={error:c}}finally{try{r&&!r.done&&(i=n.return)&&i.call(n)}finally{if(e)throw e.error}}return a},J[ht]=function(a,t){var e,i,n=new Map;try{for(var r=F(t.keys()),u=r.next();!u.done;u=r.next()){var o=u.value,l=a.get(o);if(l!=null){var h=t.get(o),s=h.score,f=h.terms,c=h.match;ft(l.terms,f),n.set(o,{score:l.score+s,terms:l.terms,match:Object.assign(l.match,c)})}}}catch(v){e={error:v}}finally{try{u&&!u.done&&(i=r.return)&&i.call(r)}finally{if(e)throw e.error}}return n},J[wt]=function(a,t){var e,i;try{for(var n=F(t.keys()),r=n.next();!r.done;r=n.next()){var u=r.value;a.delete(u)}}catch(o){e={error:o}}finally{try{r&&!r.done&&(i=n.return)&&i.call(n)}finally{if(e)throw e.error}}return a},J),Ct={k:1.2,b:.7,d:.5},bt=function(a,t,e,i,n,r){var u=r.k,o=r.b,l=r.d,h=Math.log(1+(e-t+.5)/(t+.5));return h*(l+a*(u+1)/(a+u*(1-o+o*i/n)))},zt=function(a){return function(t,e,i){var n=typeof a.fuzzy=="function"?a.fuzzy(t,e,i):a.fuzzy||!1,r=typeof a.prefix=="function"?a.prefix(t,e,i):a.prefix===!0;return{term:t,fuzzy:n,prefix:r}}},tt={idField:"id",extractField:function(a,t){return a[t]},tokenize:function(a,t){return a.split(Dt)},processTerm:function(a,t){return a.toLowerCase()},fields:void 0,searchOptions:void 0,storeFields:[],logger:function(a,t,e){return console!=null&&console.warn!=null&&console[a](t)},autoVacuum:!0},st={combineWith:j,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:Ct},St={combineWith:ht,prefix:function(a,t,e){return t===e.length-1}},et={batchSize:1e3,batchWait:10},rt={minDirtFactor:.1,minDirtCount:20},nt=O(O({},et),rt),Et=function(a,t){a.includes(t)||a.push(t)},ft=function(a,t){var e,i;try{for(var n=F(t),r=n.next();!r.done;r=n.next()){var u=r.value;a.includes(u)||a.push(u)}}catch(o){e={error:o}}finally{try{r&&!r.done&&(i=n.return)&&i.call(n)}finally{if(e)throw e.error}}},ct=function(a,t){var e=a.score,i=t.score;return i-e},vt=function(){return new Map},$=function(a){var t,e,i=new Map;try{for(var n=F(Object.keys(a)),r=n.next();!r.done;r=n.next()){var u=r.value;i.set(parseInt(u,10),a[u])}}catch(o){t={error:o}}finally{try{r&&!r.done&&(e=n.return)&&e.call(n)}finally{if(t)throw t.error}}return i},Dt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u;const dt=Object.entries,Mt=Object.fromEntries,Ot=Object.keys,U=100,Q=20,G=(a,t)=>{const e=a.toLowerCase(),i=t.toLowerCase(),n=[];let r=0,u=0;const o=(h,s=!1)=>{let f="";u===0?f=h.length>Q?`… ${h.slice(-Q)}`:h:s?f=h.length+u>U?`${h.slice(0,U-u)}… `:h:f=h.length>Q?`${h.slice(0,Q)} … ${h.slice(-Q)}`:h,f&&n.push(f),u+=f.length,s||(n.push(["mark",t]),u+=t.length,u>=U&&n.push(" …"))};let l=e.indexOf(i,r);if(l===-1)return null;for(;l>=0;){const h=l+i.length;if(o(a.slice(r,l)),r=h,u>U)break;l=e.indexOf(i,r)}return u<U&&o(a.slice(r),!0),n},Vt=(a,t,e={})=>{const i={};return t.search(a,{fuzzy:.2,prefix:!0,boost:{header:4,text:2,title:1},...e}).forEach(n=>{const{title:r,id:u,terms:o,score:l}=n,h=u.split("#")[0];i[h]||(i[h]={title:r,contents:[]});const{contents:s}=i[h],f=c=>{const v=G(n.title,c);if(v&&s.push({type:"title",id:u,display:v,score:l}),"header"in n){const d=G(n.header,c);d&&s.push({type:"heading",id:u.split("#")[0],display:d,score:l})}if("text"in n)for(const d of n.text){const p=G(d,c);p&&s.push({type:"content",header:"header"in n?n.header:n.title,id:u.split("#")[0],display:p,score:l})}"customFields"in n&&dt(n.customFields).forEach(([d,p])=>{p.forEach(y=>{const g=G(y,c);g&&s.push({type:"custom",id:u,index:d,display:g,score:l})})})};o.forEach(c=>{f(c)})}),Ot(i).sort((n,r)=>i[r].contents.reduce((u,{score:o})=>u+o,0)-i[n].contents.reduce((u,{score:o})=>u+o,0)).map(n=>i[n])},Lt=Mt(dt(JSON.parse("{\"/\":{\"documentCount\":284,\"nextId\":284,\"documentIds\":{\"0\":\"v-1d2cefc0\",\"1\":\"v-5bc3b2da#如何处理内存泄漏问题\",\"2\":\"v-5bc3b2da#为什么会导致内存泄漏\",\"3\":\"v-5bc3b2da#如何处理\",\"4\":\"v-5bc3b2da#闭包\",\"5\":\"v-5bc3b2da#闭包的应用\",\"6\":\"v-5bc3b2da\",\"7\":\"v-4d21c07a#什么是浏览器的缓存机制\",\"8\":\"v-4d21c07a#强制缓存\",\"9\":\"v-4d21c07a#协商缓存\",\"10\":\"v-4d21c07a#总结\",\"11\":\"v-4d21c07a\",\"12\":\"v-c0145384#什么是跨域\",\"13\":\"v-c0145384#同源策略\",\"14\":\"v-c0145384#如何解决跨域\",\"15\":\"v-c0145384#_1-通过-jsonp-跨域\",\"16\":\"v-c0145384#_2-cors-跨域\",\"17\":\"v-c0145384#_3-反向代理\",\"18\":\"v-c0145384\",\"19\":\"v-29367432#盒模型\",\"20\":\"v-29367432#标准盒模型\",\"21\":\"v-29367432#怪异盒模型\",\"22\":\"v-29367432\",\"23\":\"v-aad12c32#选择器\",\"24\":\"v-aad12c32#优先级\",\"25\":\"v-aad12c32#继承属性\",\"26\":\"v-aad12c32\",\"27\":\"v-75c3ec6e#单位\",\"28\":\"v-75c3ec6e\",\"29\":\"v-6e32d892#区别\",\"30\":\"v-6e32d892\",\"31\":\"v-fd14e8e4#什么是bfc\",\"32\":\"v-fd14e8e4#如何创建bfc\",\"33\":\"v-fd14e8e4#bfc的特性\",\"34\":\"v-fd14e8e4#应用场景\",\"35\":\"v-fd14e8e4\",\"36\":\"v-74368525\",\"37\":\"v-6237d1b1#什么是-css-渲染阻塞\",\"38\":\"v-6237d1b1#为什么会有-css-渲染阻塞\",\"39\":\"v-6237d1b1#如何避免-css-渲染阻塞\",\"40\":\"v-6237d1b1#_1-将-css-放在head标签中\",\"41\":\"v-6237d1b1#_2-使用媒体查询\",\"42\":\"v-6237d1b1#媒体查询\",\"43\":\"v-6237d1b1#媒体查询的使用场景\",\"44\":\"v-6237d1b1#_3-使用内联样式\",\"45\":\"v-6237d1b1#_4-使用preload和prefetch\",\"46\":\"v-6237d1b1\",\"47\":\"v-36e7ec57#基础概念\",\"48\":\"v-36e7ec57#属性\",\"49\":\"v-36e7ec57#容器属性\",\"50\":\"v-36e7ec57#项目属性\",\"51\":\"v-36e7ec57#常见布局\",\"52\":\"v-36e7ec57#三栏布局\",\"53\":\"v-36e7ec57\",\"54\":\"v-379d5da0#let-和-const-和-var\",\"55\":\"v-379d5da0#产生时间\",\"56\":\"v-379d5da0#作用域\",\"57\":\"v-379d5da0#作用域补充\",\"58\":\"v-379d5da0#变量提升-临时死亡区\",\"59\":\"v-379d5da0#重复声明\",\"60\":\"v-379d5da0#可变性\",\"61\":\"v-379d5da0#箭头函数\",\"62\":\"v-379d5da0#模板字符串\",\"63\":\"v-379d5da0#解构赋值\",\"64\":\"v-379d5da0#数组的解构赋值\",\"65\":\"v-379d5da0#对象的解构赋值\",\"66\":\"v-379d5da0#函数的解构赋值\",\"67\":\"v-379d5da0#扩展运算符\",\"68\":\"v-379d5da0#类\",\"69\":\"v-379d5da0#定义类\",\"70\":\"v-379d5da0#es5-的类\",\"71\":\"v-379d5da0#es6-的类\",\"72\":\"v-379d5da0#对类添加方法\",\"73\":\"v-379d5da0#类的继承\",\"74\":\"v-379d5da0#module-模块化\",\"75\":\"v-379d5da0#promise\",\"76\":\"v-379d5da0#promise-的基本使用\",\"77\":\"v-379d5da0#promise-的三种状态\",\"78\":\"v-379d5da0#实例方法\",\"79\":\"v-379d5da0#构造函数方法\",\"80\":\"v-379d5da0\",\"81\":\"v-74376a60\",\"82\":\"v-35f016f2#this的指向类型\",\"83\":\"v-35f016f2#call和apply和bind的区别\",\"84\":\"v-35f016f2\",\"85\":\"v-5464e616\",\"86\":\"v-66e2f8be#基本数据类型\",\"87\":\"v-66e2f8be#number\",\"88\":\"v-66e2f8be#string\",\"89\":\"v-66e2f8be#boolean\",\"90\":\"v-66e2f8be#null\",\"91\":\"v-66e2f8be#undefined\",\"92\":\"v-66e2f8be#symbol\",\"93\":\"v-66e2f8be#引用数据类型\",\"94\":\"v-66e2f8be#object\",\"95\":\"v-66e2f8be#array\",\"96\":\"v-66e2f8be#function\",\"97\":\"v-66e2f8be#date\",\"98\":\"v-66e2f8be#regexp\",\"99\":\"v-66e2f8be#存储位置\",\"100\":\"v-66e2f8be\",\"101\":\"v-30525834#操作方法\",\"102\":\"v-30525834#增加元素\",\"103\":\"v-30525834#删除元素\",\"104\":\"v-30525834#修改元素\",\"105\":\"v-30525834#查找元素\",\"106\":\"v-30525834#排序方法\",\"107\":\"v-30525834#迭代方法\",\"108\":\"v-30525834#转化方法\",\"109\":\"v-30525834\",\"110\":\"v-2b9022fc#操作方法\",\"111\":\"v-2b9022fc#增加元素\",\"112\":\"v-2b9022fc#删除元素\",\"113\":\"v-2b9022fc#修改元素\",\"114\":\"v-2b9022fc#查找元素\",\"115\":\"v-2b9022fc#转换方法\",\"116\":\"v-2b9022fc#模板匹配方法\",\"117\":\"v-2b9022fc\",\"118\":\"v-a0326798#显示类型转化\",\"119\":\"v-a0326798#隐式类型转化\",\"120\":\"v-a0326798\",\"121\":\"v-3cb808b6#等于\",\"122\":\"v-3cb808b6#完全等于\",\"123\":\"v-3cb808b6#总结\",\"124\":\"v-3cb808b6\",\"125\":\"v-5f5c21dd#浅拷贝\",\"126\":\"v-5f5c21dd#常见的浅拷贝方法\",\"127\":\"v-5f5c21dd#深拷贝\",\"128\":\"v-5f5c21dd#常见的深拷贝方法\",\"129\":\"v-5f5c21dd#参考文章\",\"130\":\"v-5f5c21dd\",\"131\":\"v-568d3b89\",\"132\":\"v-13900acc#undefined\",\"133\":\"v-13900acc#null\",\"134\":\"v-13900acc#null-和-undefined-的相同点\",\"135\":\"v-13900acc#null-和-undefined-的不同点\",\"136\":\"v-13900acc\",\"137\":\"v-1514e16c#产生的原因\",\"138\":\"v-1514e16c#任务队列\",\"139\":\"v-1514e16c#事件循环\",\"140\":\"v-1514e16c#宏任务和微任务\",\"141\":\"v-1514e16c#代码示例\",\"142\":\"v-1514e16c\",\"143\":\"v-1ccf7368#作用域链分类\",\"144\":\"v-1ccf7368#作用域链\",\"145\":\"v-1ccf7368#词法作用域\",\"146\":\"v-1ccf7368#作用域链的场景\",\"147\":\"v-1ccf7368#闭包\",\"148\":\"v-1ccf7368#事件委托\",\"149\":\"v-1ccf7368#引申-事件模型\",\"150\":\"v-1ccf7368#事件和事件流\",\"151\":\"v-1ccf7368#事件模型\",\"152\":\"v-1ccf7368#原始事件模型\",\"153\":\"v-1ccf7368#标准事件模型\",\"154\":\"v-1ccf7368\",\"155\":\"v-452c4c68#原型\",\"156\":\"v-452c4c68#原型链\",\"157\":\"v-452c4c68#数组的原型链\",\"158\":\"v-452c4c68\",\"159\":\"v-d4d1ccf8#es5-的继承\",\"160\":\"v-d4d1ccf8#es6-的继承\",\"161\":\"v-d4d1ccf8\",\"162\":\"v-6cfad872\",\"163\":\"v-28cd39da\",\"164\":\"v-bce0ae32#应用层\",\"165\":\"v-bce0ae32#传输层\",\"166\":\"v-bce0ae32#tcp段的由来\",\"167\":\"v-bce0ae32#网络层\",\"168\":\"v-bce0ae32#链路层\",\"169\":\"v-bce0ae32#物理层\",\"170\":\"v-bce0ae32\",\"171\":\"v-54eae7a0#浏览器解析\",\"172\":\"v-54eae7a0#dns解析\",\"173\":\"v-54eae7a0#tcp连接\",\"174\":\"v-54eae7a0#ip协议\",\"175\":\"v-54eae7a0#mac地址\",\"176\":\"v-54eae7a0#网卡\",\"177\":\"v-54eae7a0#交换机\",\"178\":\"v-54eae7a0#路由器\",\"179\":\"v-54eae7a0\",\"180\":\"v-c2073362\",\"181\":\"v-b53997e2#场景\",\"182\":\"v-b53997e2#实现\",\"183\":\"v-b53997e2#_1-使用-createapp-创建了两个-vue-实例\",\"184\":\"v-b53997e2\",\"185\":\"v-5b4756e9\",\"186\":\"v-a85593e6#什么是-jsx\",\"187\":\"v-a85593e6#jsx-转化过程\",\"188\":\"v-a85593e6#_1-转化为-react-元素\",\"189\":\"v-a85593e6#在-react16-中-会被转化成\",\"190\":\"v-a85593e6#在-react17-中-会被转化成\",\"191\":\"v-a85593e6#_2-react-元素转化为-fiber\",\"192\":\"v-a85593e6#_3-fiber-转化为-dom\",\"193\":\"v-a85593e6\",\"194\":\"v-0d084802#react-hooks\",\"195\":\"v-0d084802#类组件和函数组件\",\"196\":\"v-0d084802#类组件\",\"197\":\"v-0d084802#函数组件\",\"198\":\"v-0d084802#类组件和函数组件的区别\",\"199\":\"v-0d084802#hooks-种类\",\"200\":\"v-0d084802#usestate函数\",\"201\":\"v-0d084802#useeffect函数\",\"202\":\"v-0d084802#usecontext函数\",\"203\":\"v-0d084802#usereducer函数\",\"204\":\"v-0d084802#usememo函数\",\"205\":\"v-0d084802#usecallback函数\",\"206\":\"v-0d084802#useref函数\",\"207\":\"v-0d084802\",\"208\":\"v-08c026b0#什么是生命周期\",\"209\":\"v-08c026b0#生命周期的分类\",\"210\":\"v-08c026b0#_16-3-版本之前的生命周期\",\"211\":\"v-08c026b0#挂载阶段\",\"212\":\"v-08c026b0#更新阶段\",\"213\":\"v-08c026b0#卸载阶段\",\"214\":\"v-08c026b0#_16-3-版本之后的生命周期\",\"215\":\"v-08c026b0#挂载阶段-1\",\"216\":\"v-08c026b0#更新阶段-1\",\"217\":\"v-08c026b0#卸载阶段-1\",\"218\":\"v-08c026b0#hook函数\",\"219\":\"v-08c026b0\",\"220\":\"v-5ec739b6#父子组件通信\",\"221\":\"v-5ec739b6#父传子\",\"222\":\"v-5ec739b6#子传父\",\"223\":\"v-5ec739b6#兄弟组件通信\",\"224\":\"v-5ec739b6#跨级组件通信\",\"225\":\"v-5ec739b6#context\",\"226\":\"v-5ec739b6#任意组件通信\",\"227\":\"v-5ec739b6\",\"228\":\"v-9ec5e242#受控组件\",\"229\":\"v-9ec5e242#非受控组件\",\"230\":\"v-9ec5e242\",\"231\":\"v-5ce1f97c\",\"232\":\"v-4761c778#场景\",\"233\":\"v-4761c778#解决方案\",\"234\":\"v-4761c778#方案一-使用-localstorage\",\"235\":\"v-4761c778#方案二-使用路由参数\",\"236\":\"v-4761c778\",\"237\":\"v-015c1f8a#场景\",\"238\":\"v-015c1f8a#解决方案\",\"239\":\"v-015c1f8a#方案一-分页加载\",\"240\":\"v-015c1f8a#方案二-图片懒加载\",\"241\":\"v-015c1f8a#方案三-前端缓存\",\"242\":\"v-015c1f8a#方案四-虚拟列表\",\"243\":\"v-015c1f8a#方案五-骨架屏\",\"244\":\"v-015c1f8a\",\"245\":\"v-3448eb71\",\"246\":\"v-2376843a#什么是泛型\",\"247\":\"v-2376843a#泛型使用方式\",\"248\":\"v-2376843a#泛型函数\",\"249\":\"v-2376843a#泛型接口\",\"250\":\"v-2376843a#泛型类\",\"251\":\"v-2376843a#泛型约束\",\"252\":\"v-2376843a#泛型别名\",\"253\":\"v-2376843a#索引类型\",\"254\":\"v-2376843a\",\"255\":\"v-743faa02\",\"256\":\"v-2b00a92c#相同点\",\"257\":\"v-2b00a92c#不同点\",\"258\":\"v-2b00a92c#方式\",\"259\":\"v-2b00a92c#编译过程\",\"260\":\"v-2b00a92c#触发生命周期\",\"261\":\"v-2b00a92c#性能\",\"262\":\"v-2b00a92c\",\"263\":\"v-3bdca45c#vue2\",\"264\":\"v-3bdca45c#创建前后\",\"265\":\"v-3bdca45c#挂载前后\",\"266\":\"v-3bdca45c#更新前后\",\"267\":\"v-3bdca45c#销毁前后\",\"268\":\"v-3bdca45c#其他\",\"269\":\"v-3bdca45c#vue3\",\"270\":\"v-3bdca45c#创建前后-1\",\"271\":\"v-3bdca45c#挂载前后-1\",\"272\":\"v-3bdca45c#更新前后-1\",\"273\":\"v-3bdca45c#销毁前后-1\",\"274\":\"v-3bdca45c#其他-1\",\"275\":\"v-3bdca45c#引申-1-keep-alive的是什么\",\"276\":\"v-3bdca45c#引申-2-当父组件发生更新-那么子组件的生命周期会发生怎么样的变化\",\"277\":\"v-3bdca45c#引申-3-keep-alive是否类似于react中的memo\",\"278\":\"v-3bdca45c#引申-4-keep-alive下的组件生命周期\",\"279\":\"v-3bdca45c#第一次渲染\",\"280\":\"v-3bdca45c#组件被激活\",\"281\":\"v-3bdca45c#组件被移除\",\"282\":\"v-3bdca45c#组件被销毁\",\"283\":\"v-3bdca45c\"},\"fieldIds\":{\"id\":0,\"title\":1,\"header\":2,\"text\":3,\"customFields\":4},\"fieldLength\":{\"0\":[2,1,null,null,3],\"1\":[3,1,1,1],\"2\":[3,1,1,11],\"3\":[3,1,1,17],\"4\":[3,1,1,41],\"5\":[3,1,1,88],\"6\":[2,1,null,null,3],\"7\":[3,1,1,12],\"8\":[3,1,1,69],\"9\":[3,1,1,38],\"10\":[3,1,1,23],\"11\":[2,1,null,null,3],\"12\":[3,1,1,6],\"13\":[3,1,1,30],\"14\":[3,1,1,1],\"15\":[6,1,4,62],\"16\":[5,1,3,70],\"17\":[4,1,2,14],\"18\":[2,1,null,null,3],\"19\":[3,1,1,22],\"20\":[3,1,1,13],\"21\":[3,1,1,13],\"22\":[2,1,null,null,3],\"23\":[3,1,1,36],\"24\":[3,1,1,41],\"25\":[3,1,1,61],\"26\":[2,1,null,null,3],\"27\":[3,1,1,25],\"28\":[2,1,null,null,3],\"29\":[3,1,1,24],\"30\":[2,1,null,23,3],\"31\":[3,1,1,10],\"32\":[3,1,1,8],\"33\":[3,1,1,4],\"34\":[3,1,1,3],\"35\":[2,1,null,null,3],\"36\":[2,1,null,null,3],\"37\":[5,1,3,9],\"38\":[5,1,3,14],\"39\":[5,1,3,1],\"40\":[6,1,6,4],\"41\":[4,1,2,22],\"42\":[3,1,1,39],\"43\":[3,1,1,12],\"44\":[4,1,2,1],\"45\":[4,1,5,20],\"46\":[2,1,null,null,3],\"47\":[3,1,1,9],\"48\":[3,1,1,1],\"49\":[3,1,1,18],\"50\":[3,1,1,54],\"51\":[3,1,1,1],\"52\":[3,1,1,23],\"53\":[2,1,null,null,3],\"54\":[6,1,4,1],\"55\":[3,1,1,6],\"56\":[3,1,1,1],\"57\":[3,1,1,40],\"58\":[4,1,3,32],\"59\":[3,1,1,18],\"60\":[3,1,1,16],\"61\":[3,1,1,51],\"62\":[3,1,1,25],\"63\":[3,1,1,4],\"64\":[3,1,1,40],\"65\":[3,1,1,26],\"66\":[3,1,1,23],\"67\":[3,1,1,72],\"68\":[3,1,1,1],\"69\":[3,1,1,1],\"70\":[4,1,2,31],\"71\":[4,1,2,42],\"72\":[3,1,1,36],\"73\":[3,1,1,2],\"74\":[4,1,2,1],\"75\":[3,1,1,1],\"76\":[4,1,2,47],\"77\":[4,1,2,7],\"78\":[3,1,1,12],\"79\":[3,1,1,59],\"80\":[2,1,null,null,3],\"81\":[2,1,null,null,3],\"82\":[3,1,2,35],\"83\":[3,1,5,73],\"84\":[2,1,null,6,3],\"85\":[2,2,null,49,3],\"86\":[3,1,1,1],\"87\":[3,1,1,25],\"88\":[3,1,1,1],\"89\":[3,1,1,14],\"90\":[3,1,1,2],\"91\":[3,1,1,20],\"92\":[3,1,1,1],\"93\":[3,1,1,1],\"94\":[3,1,1,1],\"95\":[3,1,1,1],\"96\":[3,1,1,1],\"97\":[3,1,1,1],\"98\":[3,1,1,1],\"99\":[3,1,1,8],\"100\":[2,1,null,null,3],\"101\":[3,1,1,3],\"102\":[3,1,1,17],\"103\":[3,1,1,20],\"104\":[3,1,1,4],\"105\":[3,1,1,13],\"106\":[3,1,1,11],\"107\":[3,1,1,30],\"108\":[3,1,1,7],\"109\":[2,1,null,null,3],\"110\":[3,1,1,7],\"111\":[3,1,1,11],\"112\":[3,1,1,9],\"113\":[3,1,1,18],\"114\":[3,1,1,12],\"115\":[3,1,1,6],\"116\":[3,1,1,7],\"117\":[2,1,null,null,3],\"118\":[3,1,1,11],\"119\":[3,1,1,40],\"120\":[2,1,null,null,3],\"121\":[3,1,1,32],\"122\":[3,1,1,19],\"123\":[3,1,1,14],\"124\":[2,1,null,null,3],\"125\":[3,1,1,10],\"126\":[3,1,1,8],\"127\":[3,1,1,51],\"128\":[3,1,1,9],\"129\":[3,1,1,1],\"130\":[2,1,null,null,3],\"131\":[2,1,null,null,3],\"132\":[3,1,1,18],\"133\":[3,1,1,19],\"134\":[6,1,4,17],\"135\":[6,1,4,15],\"136\":[2,1,null,null,3],\"137\":[3,1,1,11],\"138\":[3,1,1,12],\"139\":[3,1,1,7],\"140\":[3,1,1,32],\"141\":[3,1,1,99],\"142\":[2,1,null,null,3],\"143\":[3,1,1,3],\"144\":[3,1,1,9],\"145\":[3,1,1,44],\"146\":[3,1,1,1],\"147\":[3,1,1,20],\"148\":[3,1,1,60],\"149\":[4,1,2,1],\"150\":[3,1,1,15],\"151\":[3,1,1,3],\"152\":[3,1,1,33],\"153\":[3,1,1,43],\"154\":[2,1,null,null,3],\"155\":[3,1,1,8],\"156\":[3,1,1,9],\"157\":[3,1,1,3],\"158\":[2,1,null,1,3],\"159\":[4,1,2,54],\"160\":[4,1,2,53],\"161\":[2,1,null,null,3],\"162\":[2,1,null,null,3],\"163\":[2,1,null,4,3],\"164\":[3,2,1,13],\"165\":[3,2,1,23],\"166\":[3,2,1,6],\"167\":[3,2,1,37],\"168\":[3,2,1,4],\"169\":[3,2,1,6],\"170\":[2,2,null,null,3],\"171\":[3,3,1,23],\"172\":[3,3,1,15],\"173\":[3,3,1,10],\"174\":[3,3,1,6],\"175\":[3,3,1,17],\"176\":[3,3,1,5],\"177\":[3,3,1,7],\"178\":[3,3,1,5],\"179\":[2,3,null,null,3],\"180\":[2,1,null,null,3],\"181\":[3,1,1,13],\"182\":[3,1,1,1],\"183\":[8,1,6,22],\"184\":[2,1,null,null,3],\"185\":[2,1,null,null,3],\"186\":[4,1,3,7],\"187\":[4,1,2,1],\"188\":[6,1,4,21],\"189\":[6,1,5,60],\"190\":[6,1,5,58],\"191\":[6,1,4,48],\"192\":[6,1,4,4],\"193\":[2,1,null,null,3],\"194\":[4,2,2,1],\"195\":[3,2,1,1],\"196\":[3,2,1,39],\"197\":[3,2,1,28],\"198\":[3,2,1,12],\"199\":[4,2,2,1],\"200\":[3,2,2,38],\"201\":[3,2,2,46],\"202\":[3,2,2,60],\"203\":[3,2,2,38],\"204\":[3,2,2,54],\"205\":[3,2,2,55],\"206\":[3,2,2,99],\"207\":[2,2,null,null,3],\"208\":[3,1,1,45],\"209\":[3,1,1,1],\"210\":[5,1,3,1],\"211\":[3,1,1,37],\"212\":[3,1,1,53],\"213\":[3,1,1,15],\"214\":[5,1,3,1],\"215\":[4,1,1,31],\"216\":[4,1,1,36],\"217\":[4,1,1,16],\"218\":[3,1,2,45],\"219\":[2,1,null,null,3],\"220\":[3,1,1,1],\"221\":[3,1,1,40],\"222\":[3,1,1,63],\"223\":[3,1,1,57],\"224\":[3,1,1,11],\"225\":[3,1,1,31],\"226\":[3,1,1,5],\"227\":[2,1,null,null,3],\"228\":[3,1,1,40],\"229\":[3,1,1,41],\"230\":[2,1,null,null,3],\"231\":[2,1,null,null,3],\"232\":[3,1,1,6],\"233\":[3,1,1,1],\"234\":[5,1,3,52],\"235\":[4,1,2,74],\"236\":[2,1,null,null,3],\"237\":[3,1,1,9],\"238\":[3,1,1,1],\"239\":[4,1,2,50],\"240\":[4,1,2,61],\"241\":[4,1,2,8],\"242\":[4,1,2,58],\"243\":[4,1,2,39],\"244\":[2,1,null,null,3],\"245\":[2,1,null,null,3],\"246\":[3,1,1,12],\"247\":[3,1,1,4],\"248\":[3,1,1,10],\"249\":[3,1,1,9],\"250\":[3,1,1,9],\"251\":[3,1,1,16],\"252\":[3,1,1,28],\"253\":[3,1,1,18],\"254\":[2,1,null,null,3],\"255\":[2,1,null,null,3],\"256\":[3,4,1,15],\"257\":[3,4,1,1],\"258\":[3,4,1,25],\"259\":[3,4,1,15],\"260\":[3,4,1,16],\"261\":[3,4,1,7],\"262\":[2,4,null,null,3],\"263\":[3,1,1,5],\"264\":[3,1,1,28],\"265\":[3,1,1,16],\"266\":[3,1,1,18],\"267\":[3,1,1,8],\"268\":[3,1,1,12],\"269\":[3,1,1,1],\"270\":[4,1,1,10],\"271\":[4,1,1,7],\"272\":[4,1,1,18],\"273\":[4,1,1,8],\"274\":[4,1,1,12],\"275\":[6,1,6,24],\"276\":[6,1,5,12],\"277\":[6,1,9,10],\"278\":[6,1,5,5],\"279\":[3,1,1,1],\"280\":[3,1,1,4],\"281\":[3,1,1,4],\"282\":[3,1,1,1],\"283\":[2,1,null,2,3]},\"averageFieldLength\":[3.1549295774647885,1.2147887323943665,1.4574805249492435,20.864440582424187,3],\"storedFields\":{\"0\":{\"title\":\"浏览器篇\",\"customFields\":{\"0\":[\"浏览器篇\"]}},\"1\":{\"title\":\"内存泄漏\",\"header\":\"如何处理内存泄漏问题\",\"text\":[]},\"2\":{\"title\":\"内存泄漏\",\"header\":\"为什么会导致内存泄漏\",\"text\":[\"正常浏览器会存在垃圾回收机制，会将不会被使用的对象进行清除，但是如果存在引用，那么就不会被清除，就会导致内存泄漏。\",\"使用全局变量\",\"闭包\",\"循环引用：对象之前出现相互引用的情况，导致垃圾回收机制无法回收\",\"未清理的定时器或者回调函数\"]},\"3\":{\"title\":\"内存泄漏\",\"header\":\"如何处理\",\"text\":[\"使用 let 和 const 声明变量，避免使用 var\",\"使用闭包时，注意闭包中的变量是否会被使用，如果不会被使用，那么就会导致内存泄漏\",\"使用定时器时，注意清除定时器\",\"WeakMap 之类弱引用的数据结构\",\"引申：闭包\"]},\"4\":{\"title\":\"内存泄漏\",\"header\":\"闭包\",\"text\":[\"闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。\",\"function fn1() { var a = 2; function fn2() { console.log(a); } return fn2; } var fn3 = fn1(); fn3(); // 2 \",\"从上述代码我们可以知道，fn3 作为 fn1 的返回值，fn3 可以访问到 fn1 中的变量 a，这就是闭包的一个特性：函数可以访问其声明外部的函数的作用域。\",\"闭包的另一个特性是：即使创建它的上下文已经销毁，它仍然存在。因为闭包会携带包含它的函数的作用域，所以会比其他函数占用更多的内存。\",\"function fn1() { var a = 2; function fn2() { console.log(a); } return fn2; } var fn3 = fn1(); fn3(); fn3 = null; \",\"根据上述代码进行分析：\",\"fn3 被赋值为 null，意味着对 fn3 的引用已经被释放,fn3 已经被销毁\",\"fn3 = fn1(),将fn1的返回值给了fn3,此时fn3指向了fn2，虽然fn3被销毁了，但是fn2依然会访问到外部作用域的变量，是一个闭包，无法销毁。fn2 无法被销毁\",\"因此fn1也不会被销毁，他的变量还在内存中被fn2引用着，fn1 无法被销毁\"]},\"5\":{\"title\":\"内存泄漏\",\"header\":\"闭包的应用\",\"text\":[\"闭包可以用来模拟块级作用域\",\"for (var i = 0; i < 5; i++) { (function (j) { setTimeout(function () { console.log(j); // 0,1,2,3,4 }, j * 1000); })(i); } \",\"分析一下上述代码：\",\"(function (j) {...})(i)这段代码其实是一个闭包，i作为参数传递给了闭包，i的值会被保存在闭包中，当setTimeout执行时，会访问到闭包中的i。\",\"因为setTimeout是一个异步函数，所以会在循环结束后才会执行，此时i的值已经变成了5。\",\"但是因为使用了闭包，所以i的值会被保存在闭包中，所以会输出0,1,2,3,4。\",\"不使用闭包情况下：\",\"for (var i = 0; i < 5; i++) { setTimeout(function () { console.log(i); // 5,5,5,5,5 }, i * 1000); } \",\"假如使用变量let\",\"for (let i = 0; i < 5; i++) { setTimeout(function () { console.log(i); // 0,1,2,3,4 }, i * 1000); } \",\"那么为什么会产生不同呢？\",\"var定义的变量会具有变量提升的特性，所以var定义的变量会被提升到全局作用域中，所以setTimeout中访问到的i是全局作用域中的i，而全局作用域中的i在循环结束后，值为5。\",\"代码会变为：\",\"var i; for (i = 0; i < 5; i++) { setTimeout(function () { console.log(i); // 5,5,5,5,5 }, i * 1000); } \",\"let定义的变量不会具有变量提升的特性，所以setTimeout中访问到的i是for循环中的i，在每次循环时，都会重新定义，所以每次循环时，i的值都不一样。\",\"闭包可以用来封装私有变量\",\"function Person(name) { var _age; // 私有变量 function setAge(n) { _age = n; } function getAge() { return _age; } return { name: name, getAge: getAge, setAge: setAge, }; } var p1 = Person(\\\"张三\\\"); p1.setAge(25); console.log(p1.getAge()); \",\"闭包进行延迟执行\",\"闭包可以用来延迟函数的执行，当需要在某个时间点上执行函数，但是又不想立即执行该函数时，可以使用闭包来延迟函数的执行。\",\"function delay(func, delayTime) { return function () { var args = arguments; var _this = this; setTimeout(function () { func.apply(_this, args); // 通过apply将参数传递给func }, delayTime); } } function fn(a, b) { console.log(a + b); } var fn1 = delay(fn, 1000); fn1(1, 2); // 3 \",\"一般会在场景题里面出现\",\"为什么要使用闭包来延迟函数的执行呢？为什么不是直接使用setTimeout来延迟函数的执行呢？\",\"function fn(a, b) { console.log(a + b); } setTimeout(fn, 1000, 1, 2); // 3 \",\"原因：在函数中使用setTimeout，会创建一个新的上下文，并将其放在任务队列里面。等到执行栈中的代码执行完毕后，才会执行任务队列中的代码。这时候就会无法获取到父函数中的变量。\"]},\"6\":{\"title\":\"内存泄漏\",\"customFields\":{\"0\":[\"浏览器\"],\"1\":[\"内存泄漏\"]}},\"7\":{\"title\":\"缓存机制\",\"header\":\"什么是浏览器的缓存机制\",\"text\":[\"浏览器缓存机制又可以称为是Http缓存机制`，是指浏览器对于静态资源的缓存策略。 对于一些重复性的请求，浏览器会将请求的资源缓存起来，当下次请求时，如果资源没有发生变化，就会直接从缓存中获取，而不是再次向服务器发起请求。\",\"实现HTTP缓存的方式有很多，但是大体上可以分为两种：\",\"强制缓存\",\"协商缓存\"]},\"8\":{\"title\":\"缓存机制\",\"header\":\"强制缓存\",\"text\":[\"浏览器在第一次请求资源时，服务器会将资源的缓存策略一起返回给浏览器，浏览器会根据缓存策略来决定是否缓存资源。由浏览器来决定，是不是使用缓存，而不是由服务器来决定。\",\"强制缓存主要使用的是响应头中的两个字段：Expires和Cache-Control。\",\"Expires：是一个绝对时间，用来指定资源的过期时间，即到了这个时间，浏览器就会向服务器发起请求，如果没有发生变化，就会使用缓存。 但是到了HTTP1.1以后，Expires就被Cache-COntrol替换了，这是因为，Expires是一个绝对时间，是由服务器来设置的，如果服务器的时间和浏览器的时间不一致，就会导致缓存失效，但是浏览器第二次请求时，服务器的时间和浏览器的时间可能就一致了，这样就会导致缓存生效，但是实际上，资源已经发生了变化，这样就会导致缓存失效。\",\"Cache-Control：是一个相对时间，用来指定资源的过期时间，即到了这个时间，浏览器就会向服务器发起请求，如果没有发生变化，就会使用缓存。 Cache-Control的值有很多，常用的有以下几个： \",\"no-cache：不使用强制缓存，但是会使用协商缓存。\",\"no-store：不使用强制缓存，也不使用协商缓存。\",\"max-age：指定资源的过期时间，单位是秒，缓存内容将在这个时间之后失效。\",\"s-maxage：和max-age的作用一样，但是只针对于代理服务器，比如CDN。\",\"Cache-Control的优先级要高于Expires\",\"引申：浏览器缓存，那么将请求的资源缓存到哪里呢？ 浏览器缓存主要分为两种：内存缓存和硬盘缓存\",\"内存缓存的优点是读取速度快，但是缺点是存储空间小，而且会随着浏览器(进程)的关闭而释放。\",\"硬盘缓存的优点是存储空间大，而且不会随着浏览器的关闭而释放，但是缺点是读取速度慢。\",\"浏览器会将js和图片解析完成后将他们放在内存缓存中，将css文件会存放在硬盘中\",\"浏览器强制缓存\"]},\"9\":{\"title\":\"缓存机制\",\"header\":\"协商缓存\",\"text\":[\"协商缓存是指，当强制缓存失效以后，浏览器会携带缓存标识向服务器发起请求，由服务器根据缓存标识来决定是否使用缓存。\",\"控制协商缓存的字段有两组：\",\"Last-Modified和If-Modified-Since：表示的是时间，最后一次修改时间。\",\"ETag和If-None-Match：表示的是资源的唯一标识，是一个字符串。 其中，Etag的优先级会高一点\",\"具体流程如下：\",\"当强制缓存失效后，浏览器再次发送请求到服务器，并且会在请求头里面携带If-Modified-Since或者If-None-Match字段，这两个字段的值分别是上一次请求返回的Last-Modified和ETag的值。\",\"服务器接受到请求后，会根据If-Modified-Since或者If-None-Match的值和资源的最新修改时间或者ETag的值进行对比，如果没有发生变化，就会返回304，并且不会返回资源内容，浏览器就会使用缓存，如果发生了变化，就会返回200，并且返回资源内容，浏览器就会使用最新的资源。\"]},\"10\":{\"title\":\"缓存机制\",\"header\":\"总结\",\"text\":[\"强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和ETag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回 304，继续使用缓存。\",\"浏览器缓存\"]},\"11\":{\"title\":\"缓存机制\",\"customFields\":{\"0\":[\"浏览器\"],\"1\":[\"浏览器\",\"缓存\"]}},\"12\":{\"title\":\"跨域问腿\",\"header\":\"什么是跨域\",\"text\":[\"跨域是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对javascript施加的安全限制。\",\"引申： 什么是同源策略？\"]},\"13\":{\"title\":\"跨域问腿\",\"header\":\"同源策略\",\"text\":[\"浏览器规定，AJAX请求只能发给同源的网址，否则就报错。所谓同源是指，域名，协议，端口相同。\",\"例如：\",\"http://www.example.com/dir/page.html http://www.example.com/dir2/other.html # 同源 https://www.example.com/dir/page.html # 不同源（协议不同） http://www.example.com:81/dir/page.html # 不同源（端口不同） http://www.example.com/dir/page.html # 不同源（域名不同） \",\"比如你在请求一个跨域的接口，浏览器会将这个请求拦截下来，不会发出去，也不会返回结果，但是浏览器的控制台中会显示出如下错误信息：\"]},\"14\":{\"title\":\"跨域问腿\",\"header\":\"如何解决跨域\",\"text\":[]},\"15\":{\"title\":\"跨域问腿\",\"header\":\"1. 通过 jsonp 跨域\",\"text\":[\"jsonp的原理是动态创建script标签\",\"HTML5 的 script 标签，默认 type 就是 text/javascript,这时候请求的内容就会被当做javascript代码去执行，然后就可以拿到数据。\",\"<script> var script = document.createElement('script'); script.type = 'text/javascript'; // 传参并指定回调执行函数为onBack script.src = 'http://www.domain2.com:8080/login?user=admin&callback=onBack'; document.head.appendChild(script); // 回调执行函数 function onBack(res) { alert(JSON.stringify(res)); } </script> \",\"也就是说，我们在客户端提前设置好一个函数，这个函数的作用是拿到服务器返回的数据，然后做一些事情，这个函数就是onBack。 当服务器看到这些额外的参数，就会将要返回的数据包裹在这个函数里面，然后以 JSON 格式返回给客户端。\",\"JOSNP 的优缺点：\",\"优点：兼容性好，简单易用，支持浏览器与服务器双向通信。\",\"缺点：只支持 GET 请求，不安全，可能会遭受 XSS 攻击。\"]},\"16\":{\"title\":\"跨域问腿\",\"header\":\"2. CORS 跨域\",\"text\":[\"当浏览器在发送跨域请求的时候，会自动在请求头中加入Origin字段，这个字段的值就是当前页面的源（协议 + 域名 + 端口）。\",\"这时候服务器就可以根据这个值来决定是否同意这次请求。可以设置Access-Control-Allow-Origin字段来允许指定源的请求。\",\"当用户想要修改服务器数据的时候，例如 PUT，Patch 之类的，浏览器就会自动发送一个预检请求，这个请求是一个OPTIONS请求，这个请求的作用是询问服务器是否允许这种请求，如果服务器允许，就会在响应头中加入Access-Control-Allow-Methods字段，告诉浏览器允许这种请求。\",\"// nodejs const http = require('http'); const server = http.createServer(); server.on('request', (req, res) => { // 设置响应头，允许跨域 res.setHeader('Access-Control-Allow-Origin', '*'); // 设置响应头，允许跨域的请求方式 res.setHeader('Access-Control-Allow-Methods', 'GET,POST,DELETE,OPTIONS'); // 允许前端获取哪个请求头 res.setHeader('Access-Control-Allow-Headers', 'x-requested-with,content-type'); // 设置响应头，允许跨域携带cookie res.setHeader('Access-Control-Allow-Credentials', true); // 设置响应体 res.end('hello cors'); }); server.listen(3000, () => { console.log('server running at http:// localhost:3000'); }); \",\"具体流程如下：\"]},\"17\":{\"title\":\"跨域问腿\",\"header\":\"3. 反向代理\",\"text\":[\"反向代理的原理是：同源策略是浏览器的安全策略，不是服务器的安全策略，服务器完全可以不遵守同源策略，服务器可以接收任何请求，也可以发送任何请求，所以我们可以通过服务器来请求接口，然后再将结果返回给浏览器，这样浏览器就认为这是同源的了。\",\"一般在项目中，我们可以去配置nginx来做反向代理，也可以配置Vite, webpack等工具来做反向代理。\"]},\"18\":{\"title\":\"跨域问腿\",\"customFields\":{\"0\":[\"浏览器\"],\"1\":[\"跨域\",\"配置\"]}},\"19\":{\"title\":\"CSS的盒模型\",\"header\":\"盒模型\",\"text\":[\"盒模型是一个矩形的盒子，它包含了元素的内容、内边距、边框和外边距。\",\"css 中盒模型分为两种：标准盒模型和 IE 盒模型。\",\"标准盒模型：width = content\",\"IE 盒模型：width = content + padding + border\",\"在CSS中通过box-sizing来进行设置\",\" box-sizing: content-box; /* 标准盒模型 */ box-sizing: border-box; /* IE盒模型 */ \"]},\"20\":{\"title\":\"CSS的盒模型\",\"header\":\"标准盒模型\",\"text\":[\"标准盒模型其实就是width就是内容的宽度，不包含padding和border。\",\"width = content\",\"height = content\",\"盒子实际宽高：\",\"盒子的总宽度是width + padding + border+margin。\",\"盒子的总高度是height + padding + border+margin。\"]},\"21\":{\"title\":\"CSS的盒模型\",\"header\":\"怪异盒模型\",\"text\":[\"你设置多大的width和height，盒子就是多大，不管你有没有设置padding和border。\",\"width = content + padding + border\",\"height = content + padding + border\",\"盒子的总宽度是width+margin。 盒子的总高度是height+margin。\",\"盒模型图例\"]},\"22\":{\"title\":\"CSS的盒模型\",\"customFields\":{\"0\":[\"CSS篇\"],\"1\":[\"基础概念\",\"盒模型\"]}},\"23\":{\"title\":\"CSS选择器\",\"header\":\"选择器\",\"text\":[\"css 中选择器主要分为以下几种：\",\"元素选择器 \",\"普通元素选择器，类似div，p\",\"伪元素选择器，类似::before，::after，可以在里面插入内容\",\"类选择器 \",\"类选择器，类似.class\",\"伪类选择器,类似:hover，:active，可以在里面插入样式\",\"id 选择器，类似#id\",\"属性选择器，类似[type=\\\"text\\\"]\",\"通配符选择器，类似*\",\"后代选择器，类似div p\",\"子代选择器，类似div > p\",\"兄弟选择器，类似div + p\",\"群组选择器，类似div, p\",\"注意区分后代选择器和兄弟选择器的区别：\",\"后代选择器：div p,他会选择所有的div下的p元素，包括嵌套的p元素。\",\"兄弟选择器：div + p,他会选择所有的div下的紧邻的p元素，不包括嵌套的p元素。\"]},\"24\":{\"title\":\"CSS选择器\",\"header\":\"优先级\",\"text\":[\"css 中的优先级是根据选择器的权重来决定的，权重越高，优先级越高。 主要原则就是：ABCD法则\",\"A: 代表内联样式，权重为1000\",\"B: 代表 id 选择器，权重为100\",\"C: 代表类选择器，属性选择器，伪类选择器，权重为10\",\"D: 代表元素选择器，伪元素选择器，权重为1\",\"例子：\",\"#nav-global > ul > li > a.nav-link; \",\"使用ABCD法则计算权重：\",\"A(内联样式): 0\",\"B(ID 选择器): 1\",\"C(Class 选择器+属性选择器): 1\",\"D(元素选择器): 3\",\"所以权重为0113\"]},\"25\":{\"title\":\"CSS选择器\",\"header\":\"继承属性\",\"text\":[\"css 中有一些属性是可以继承的\",\"字体类\",\"font-family\",\"font-size\",\"font-weight\",\"font-style\",\"font-variant\",\"font\",\"文本类\",\"color: 文本颜色\",\"text-align: 文本对齐方式\",\"text-indent: 首行缩进\",\"元素可见性\",\"visibility: 元素是否可见\",\"表格类\",\"caption-side: 表格标题的位置\",\"empty-cells: 是否显示表格中的空单元格\",\"table-layout: 表格的布局方式\",\"border-collapse: 表格边框是否合并\",\"列表类\",\"list-style-type: 列表项标记的类型\",\"list-style-position: 列表项标记的位置\",\"list-style-image: 列表项标记的图像\",\"其实只要记录一些比较特殊的不可继承属性就可以了，其他的都是可以继承的。\",\"display\",\"文本类\",\"vertical-align：垂直对齐方式\",\"text-decoration: 文本装饰,添加下划线，删除线等\",\"盒子类\",\"width，height:宽高度\",\"margin，padding: 外边距，内边距\",\"border，border-width，border-style，border-color: 边框\",\"背景类\",\"float和position类\"]},\"26\":{\"title\":\"CSS选择器\",\"customFields\":{\"0\":[\"CSS篇\"],\"1\":[\"基础概念\",\"选择器\",\"容易遗忘\"]}},\"27\":{\"title\":\"CSS中的单位\",\"header\":\"单位\",\"text\":[\"CSS中的常见单位有以下几种：\",\"px:像素点，是一个相对单位，相对于显示器的分辨率，一般情况下，1px = 1/96英寸\",\"%：百分比\",\"vh,vm：视窗高度和视窗宽度\",\"em：根据当前盒子的父元素的font-size来计算\",\"rem：根据根元素html的font-size来计算，一般情况下，1rtem = 16px\",\"%和vh,vm的区别：\",\"%是相对于父元素的宽度来计算的\",\"vh,vm是相对于视窗的高度和宽度来计算的\"]},\"28\":{\"title\":\"CSS中的单位\",\"customFields\":{\"0\":[\"CSS篇\"],\"1\":[\"基础概念\",\"单位\"]}},\"29\":{\"title\":\"CSS实现隐藏元素的方法\",\"header\":\"区别\",\"text\":[\"其实日常开发中，我们一般使用display: none;来隐藏元素，但是这种方法会导致元素不占据空间，所以在一些特殊的场景下，我们需要使用其他的方法来隐藏元素。\",\"方法\",\"元素占据空间\",\"元素可点击\",\"元素可见\",\"visibility: hidden;\",\"是\",\"是\",\"否\",\"opcitiy: 0;\",\"是\",\"是\",\"否\",\"z-index: -1;\",\"是\",\"是\",\"否\",\"position: absolute;\",\"是\",\"是\",\"否\",\"height: 0;\",\"否\",\"否\",\"否\",\"display: none;\",\"否\",\"否\",\"否\"]},\"30\":{\"title\":\"CSS实现隐藏元素的方法\",\"text\":[\"常见的隐藏元素的方法有以下几种：\",\"visibility: hidden;,设置可见性为隐藏，但是元素还是占据空间\",\"opcitiy: 0;，设置透明度为 0，但是元素还是占据空间\",\"z-index: -1;，设置z-index为负数，但是元素还是占据空间\",\"position: absolute;，设置绝对定位，然后将元素移除屏幕，但是元素还是占据空间\",\"height: 0;，设置元素高度为 0，元素不占据空间\",\"display: none;，设置元素不显示，元素不占据空间\"],\"customFields\":{\"0\":[\"CSS篇\"],\"1\":[\"基础概念\",\"隐藏元素\"]}},\"31\":{\"title\":\"BFC布局\",\"header\":\"什么是BFC\",\"text\":[\"BFC（Block Formatting Context）即块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。\"]},\"32\":{\"title\":\"BFC布局\",\"header\":\"如何创建BFC\",\"text\":[\"根元素或包含根元素的元素<html>\",\"浮动元素\",\"position: absolute或fixed\",\"display:不为none\",\"overflow:不为visible\"]},\"33\":{\"title\":\"BFC布局\",\"header\":\"BFC的特性\",\"text\":[\"不会存在外边距合并(margin塌陷问题)\",\"float,浮动元素会参与高度计算\"]},\"34\":{\"title\":\"BFC布局\",\"header\":\"应用场景\",\"text\":[\"防止margin塌陷\",\"清除浮动\",\"自适应两栏布局\"]},\"35\":{\"title\":\"BFC布局\",\"customFields\":{\"0\":[\"CSS篇\"],\"1\":[\"基础概念\",\"BFC\"]}},\"36\":{\"title\":\"CSS篇\",\"customFields\":{\"0\":[\"CSS篇\"]}},\"37\":{\"title\":\"css渲染阻塞\",\"header\":\"什么是 css 渲染阻塞\",\"text\":[\"css渲染阻塞是指浏览器在解析html时，如果遇到了css，会暂停html的解析，等css加载完毕后，再继续解析html。所以说，css 渲染阻塞会阻塞DOM树的构建。\"]},\"38\":{\"title\":\"css渲染阻塞\",\"header\":\"为什么会有 css 渲染阻塞\",\"text\":[\"当浏览器开始解析HTML文件时，就会生成DOM树，但是在生成DOM树的时候，如果遇到了css，就会停止DOM树的生成，等css加载完毕后，再继续生成DOM树。\",\"这样是为了确保css能够正确的渲染DOM树，因为css可以修改DOM树的样式，css下载，解析完毕后，再去渲染DOM树，就可以确保css能够正确的渲染DOM树。\"]},\"39\":{\"title\":\"css渲染阻塞\",\"header\":\"如何避免 css 渲染阻塞\",\"text\":[]},\"40\":{\"title\":\"css渲染阻塞\",\"header\":\"1. 将 css 放在 head 标签中\",\"text\":[\"将css放在head标签中，可以确保css在DOM树生成之前就加载完毕，这样就不会阻塞DOM树的生成。\"]},\"41\":{\"title\":\"css渲染阻塞\",\"header\":\"2. 使用媒体查询\",\"text\":[\"我们可以使用媒体查询来指定css的加载时机，这样就可以避免css阻塞DOM树的生成。\",\"<!-- 网页首次加载时，只在打印内容时适用 --> <link rel=\\\"stylesheet\\\" href=\\\"style.css\\\" media=\\\"print\\\" /> <!-- 当符合某种条件的时候才会阻塞渲染 --> <!-- 宽度至少是40em --> <link rel=\\\"stylesheet\\\" href=\\\"style.css\\\" media=\\\"(min-width: 40em)\\\" /> <!-- 一直会阻塞渲染 --> <link rel=\\\"stylesheet\\\" href=\\\"style.css\\\" /> \",\"引申：媒体查询\"]},\"42\":{\"title\":\"css渲染阻塞\",\"header\":\"媒体查询\",\"text\":[\"简单来说，媒体查询就是一种检测浏览器或设备特性的方法，可以根据不同的特性来加载不同的css\",\"媒体查询的语法如下：\",\"@media not|only mediatype and (expressions) { CSS-Code; } \",\"not：表示不匹配媒体类型的情况\",\"only：表示只匹配媒体类型的情况\",\"meidatype：指定媒体类型，如screen、print等\",\"expressions：媒体查询表达式，用来检测媒体类型的特性，如width、height等 \",\"max-width：最大宽度(至多多少)\",\"min-width：最小宽度(至少多少)\",\"语法改进：\",\"@media (min-width: 40em) { /* 宽度至少是40em */ } /* 现在可以改写成 */ @media (width >= 40em) { /* 宽度至少是40em */ } \",\"@media (min-width: 40em) and (max-width: 60em) { /* 宽度至少是40em，至多是60em */ } /* 现在可以改写成 */ @media (width >= 40em) and (width <= 60em) { /* 宽度至少是40em，至多是60em */ } \"]},\"43\":{\"title\":\"css渲染阻塞\",\"header\":\"媒体查询的使用场景\",\"text\":[\"响应式布局\",\"设置打印样式(@media print { ... })\",\"动态样式(根据不同的设备特性，加载不同的样式)\",\"图片优化(根据不同的设备，不同分辨率，加载不同的图片)\"]},\"44\":{\"title\":\"css渲染阻塞\",\"header\":\"3. 使用内联样式\",\"text\":[]},\"45\":{\"title\":\"css渲染阻塞\",\"header\":\"4. 使用 preload 和 prefetch\",\"text\":[\"preload和prefetch是html5中的新特性，可以用来指定资源的加载时机。\",\"preload用来指定当前页面必须要用到的资源，而prefetch用来指定当前页面可能会用到的资源。\",\"<!-- preload --> <link rel=\\\"preload\\\" href=\\\"style.css\\\" as=\\\"style\\\" /> <!-- prefetch --> <link rel=\\\"prefetch\\\" href=\\\"style.css\\\" as=\\\"style\\\" /> \",\"作用就是：预加载，提前加载，提前缓存，一般都是将他直接缓存在浏览器的缓存目录下。\"]},\"46\":{\"title\":\"css渲染阻塞\",\"customFields\":{\"0\":[\"CSS\"],\"1\":[\"CSS\",\"渲染\"]}},\"47\":{\"title\":\"flex布局\",\"header\":\"基础概念\",\"text\":[\"flex 布局是一种一维布局模型，可以实现更加灵活的布局方式，flex 布局的主要思想是让容器有能力让其子元素改变自身的宽度、高度、顺序，以及对齐方式等，以最适合当前的显示环境。\"]},\"48\":{\"title\":\"flex布局\",\"header\":\"属性\",\"text\":[]},\"49\":{\"title\":\"flex布局\",\"header\":\"容器属性\",\"text\":[\"就是对于父元素的属性\",\"flex-direction：决定主轴的方向\",\"flex-wrap: 决定元素是否换行\",\"align-items: 在副轴上如何对齐\",\"justify-content: 在主轴上如何对齐\",\"align-content: 多根轴线的对齐方式\",\"flex-flow: flex-direction和flex-wrap的简写,默认值为row nowrap\"]},\"50\":{\"title\":\"flex布局\",\"header\":\"项目属性\",\"text\":[\"order: 定义项目的排列顺序，数值越小，排列越靠前，默认为 0\",\"align-self: 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性\",\"flex-grow: 定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大\",\"flex-shrink: 定义项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小\",\"flex-basis: 定义在分配多余空间之前，项目占据的主轴空间（main size）\",\"flex: flex-grow、flex-shrink和flex-basis的简写，默认值为0 1 auto，后两个属性可选\",\"这边flex比较复杂，且很重要，所以单独拿出来说一下\",\"flex,一般会简写：\",\"flex: 1：相当于flex: 1 1 0,表明，在空间不足的情况下，不缩小，在空间有剩余的情况下，放大\",\"flex: auto：相当于flex: 1 1 auto,表明，在空间不足的情况下，缩小，在空间有剩余的情况下，放大\",\"flex:none: 相当于flex: 0 0 auto,表明，不放大，不缩小\",\"flex: 2 1 100px: 表明，放大比例为 2，缩小比例为 1，基准值为 100px\",\"场景：\",\"如果希望弹性项目可以占据多余空间，且会根据剩余空间的大小进行放大，可以使用flex: 1\",\"如果希望弹箱项目会根据位置和大小进行缩小，可以使用flex: auto\"]},\"51\":{\"title\":\"flex布局\",\"header\":\"常见布局\",\"text\":[]},\"52\":{\"title\":\"flex布局\",\"header\":\"三栏布局\",\"text\":[\"三栏布局：左右两边固定宽度，中间自适应\",\".content { display: flex; width: 400px; height: 600px; background-color: aquamarine; } .medium { flex: 1; background-color: yellow; } .left { width: 200px; height: 100%; background-color: blue; } .right { width: 200px; height: 100%; background-color: red; } \"]},\"53\":{\"title\":\"flex布局\",\"customFields\":{\"0\":[\"CSS\"],\"1\":[\"flex\",\"布局\",\"基础概念\"]}},\"54\":{\"title\":\"ES6新特新\",\"header\":\"let 和 const 和 var\",\"text\":[]},\"55\":{\"title\":\"ES6新特新\",\"header\":\"产生时间\",\"text\":[\"var是 ES5 的产物，let和const是 ES6 的产物。\"]},\"56\":{\"title\":\"ES6新特新\",\"header\":\"作用域\",\"text\":[]},\"57\":{\"title\":\"ES6新特新\",\"header\":\"作用域补充\",\"text\":[\"什么是作用域？\",\"作用域就是变量和函数的可访问范围，也就是说在什么范围内可以访问到变量和函数。\",\"作用域分类\",\"全局作用域：在代码的任何地方都可以访问到的变量和函数(只要不在函数内部或者在大括号内的都是全局作用域)。\",\"块级作用域：在大括号内可以访问到的变量和函数。\",\"函数作用域：在函数内部可以访问到的变量和函数。\",\"// 全局作用域 var a = 1; let b = 2; const c = 3; // 块级作用域 { var a = 4; let b = 5; const c = 6; console.log(a); // 4 console.log(b); // 5 console.log(c); // 6 } console.log(a); // 4 console.log(b); // 2 console.log(c); // 3 // 函数作用域 function fn() { var a = 7; let b = 8; const c = 9; console.log(a); // 7 console.log(b); // 8 console.log(c); // 9 } fn(); console.log(a); // 4 console.log(b); // 2 console.log(c); // 3 \",\"上述代码表明：\",\"var声明的变量在全局作用域和块级作用域中都可以访问到，并且是可以被改变的，但是在函数作用域中不能访问到。\",\"let和const声明的变量在全局作用域中可以访问到，但是在块级作用域和函数作用域中都不能访问到。(仅在当前这个作用域生效，可被改变)\"]},\"58\":{\"title\":\"ES6新特新\",\"header\":\"变量提升(临时死亡区)\",\"text\":[\"什么是变量提升？\",\"变量提升就是在代码执行之前，会把变量的声明提升到代码的最前面，但是，赋值还是在后面。\",\"什么是临时死亡区？\",\"临时死亡区就是代码块的起始位置到变量声明的位置，这段区域内不能访问到变量。如果访问，那么会报错(ReferenceError)\",\"console.log(a); // undefined var a = 1; console.log(a); // 1 \",\"上面这段代码表明，var声明的变量会被提升到代码的最前面，但是变量的赋值不会被提升。\",\"console.log(b); // 报错 let b = 2; console.log(b); // 2 \",\"上面这段代码表明，let声明的变量不会被提升到代码的最前面，所以在声明之前访问变量会报错。\",\"console.log(c); // 报错 const c = 3; console.log(c); // 3 \",\"上面这段代码表明，const声明的变量不会被提升到代码的最前面，所以在声明之前访问变量会报错。\"]},\"59\":{\"title\":\"ES6新特新\",\"header\":\"重复声明\",\"text\":[\"var声明的变量可以被重复声明，而let和const声明的变量不能被重复声明。\",\"var a = 1; var a = 2; console.log(a); // 2 \",\"上面这段代码表明，var声明的变量可以被重复声明，而且后面的声明会覆盖前面的声明。\",\"let b = 1; let b = 2; console.log(b); // 报错 const c = 1; const c = 2; console.log(c); // 报错 \",\"上面这段代码表明，let和const声明的变量不能被重复声明。\"]},\"60\":{\"title\":\"ES6新特新\",\"header\":\"可变性\",\"text\":[\"var和let声明的变量是可变的，而const声明的变量是不可变的。\",\"var a = 1; a = 2; console.log(a); // 2 let b = 1; b = 2; console.log(b); // 2 \",\"上面的代码表明，var和let声明的变量是可变的。\",\"const c = 1; c = 2; console.log(c); // 报错 \"]},\"61\":{\"title\":\"ES6新特新\",\"header\":\"箭头函数\",\"text\":[\"形式：() => {}\",\"特点：\",\"箭头函数没有this，this指向的是函数定义时所在的对象，而不是使用时所在的对象；但是普通函数有this,指向的是函数使用时所在的对象。\",\"const obj = { name: \\\"Summer\\\", fn: function () { console.log(this); // obj setTimeout(function () { console.log(this); // window，setTimeout是window的方法 }, 1000); }, fn2: function () { console.log(this); // obj setTimeout(() => { console.log(this); // obj，因为箭头函数没有this，所以this指向的是函数定义时所在的对象 }, 1000); }, }; obj.fn(); // obj，window obj.fn2(); // obj，obj \",\"再举一个例子\",\"function Timer() { console.log(this); // window, Timer是window的方法，是window调用的 this.name = \\\"Summer\\\"; setTimeout(function () { console.log(this.name); // undefined，因为普通函数有this，所以this指向的是使用时所在的对象，而使用时是window调用的，所以this指向的是window }, 1000); setTimeout(() => { console.log(this.name); // Summer，因为箭头函数没有this，所以this指向的是函数定义时所在的对象 }, 1000); } let timer = new Timer(); \",\"引申：this的指向问题\",\"具体参考，this 指向问题\",\"箭头函数没有arguments\",\"arguments是一个类数组对象，包含了函数的所有参数。简单理解为参数列表\",\"function fn() { console.log(arguments); } fn(1, 2, 3); // [1, 2, 3] \",\"const fn = () => { console.log(arguments); }; fn(1, 2, 3); // 报错 \"]},\"62\":{\"title\":\"ES6新特新\",\"header\":\"模板字符串\",\"text\":[\"模板字符串是增强版的字符串，用反引号(`)标识，它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。\",\"const name = \\\"Summer\\\"; const age = 18; const str = `My name is ${name}, I'm ${age} years old.`; console.log(str); // My name is Summer, I'm 18 years old. \"]},\"63\":{\"title\":\"ES6新特新\",\"header\":\"解构赋值\",\"text\":[\"解构赋值是对赋值运算符的扩展，它是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。\"]},\"64\":{\"title\":\"ES6新特新\",\"header\":\"数组的解构赋值\",\"text\":[\"类型：\",\"一一对应\",\"可以跳过某些元素\",\"使用省略号（剩余运算符），返回的是一个数组\",\"设置默认值\",\"解构不成功，变量的值就等于 undefined\",\"const arr = [1, 2, 3]; const [a, b, c] = arr; console.log(a, b, c); // 1, 2, 3 const [, , e] = arr; // 可以跳过某些元素 console.log(e); // 3 const [f, ...g] = arr; // 可以使用剩余运算符，但是需要注意的是，剩余运算符只能放在最后一位 console.log(f, g); // 1, [2, 3] const [h, i, j, k] = arr; // 如果解构不成功，变量的值就等于undefined const [l, m, n, o = 4] = arr; // 可以给变量设置默认值 \"]},\"65\":{\"title\":\"ES6新特新\",\"header\":\"对象的解构赋值\",\"text\":[\"类型：\",\"一一对应\",\"设置别名\",\"设置默认值\",\"使用省略号（剩余运算符），返回的是一个对象\",\"const obj = { name: \\\"Summer\\\", age: 18, }; const { name, age } = obj; console.log(name, age); // Summer, 18 const { name: myName, age: myAge } = obj; // 可以给变量设置别名 console.log(myName, myAge); // Summer, 18 const { name, age = 10 } = obj; // 可以给变量设置默认值 const { name, ...rest } = obj; // 可以使用剩余运算符，但是需要注意的是，剩余运算符只能放在最后一位 console.log(name, rest); // Summer, {age: 18} \"]},\"66\":{\"title\":\"ES6新特新\",\"header\":\"函数的解构赋值\",\"text\":[\"函数的解构赋值其实是针对于函数的参数而言的\",\"function fn([a, b, c]) { console.log(a, b, c); } fn([1, 2, 3]); // 1, 2, 3 function fn2({ name, age }) { console.log(name, age); } fn2({ name: \\\"Summer\\\", age: 18 }); // Summer, 18 function fn3({ name, age = 18 }) { // 设置默认值 console.log(name, age); } fn3({ name: \\\"Summer\\\" }); // Summer, 18 function fn4({ name, ...rest }) { // 使用剩余运算符 console.log(name, rest); } fn4({ name: \\\"Summer\\\", age: 18 }); // Summer, {age: 18} \"]},\"67\":{\"title\":\"ES6新特新\",\"header\":\"扩展运算符\",\"text\":[\"扩展运算符是三个点（...），它好比是 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\",\"console.log(...[1, 2, 3]); // 1, 2, 3 \",\"应用场景：\",\"数组合并\",\"const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const arr3 = [...arr1, ...arr2]; console.log(arr3); // [1, 2, 3, 4, 5, 6] \",\"与解构赋值结合，获取数组的部分元素\",\"const arr = [1, 2, 3, 4, 5]; const [a, ...b] = arr; console.log(a, b); // 1, [2, 3, 4, 5] \",\"字符串转数组\",\"const str = \\\"Summer\\\"; const arr = [...str]; console.log(arr); // [\\\"S\\\", \\\"u\\\", \\\"m\\\", \\\"m\\\", \\\"e\\\", \\\"r\\\"] \",\"将伪数组转为真正的数组\",\"const divs = document.querySelectorAll(\\\"div\\\"); const arr = [...divs]; \",\"进行深拷贝\",\"const obj = { name: \\\"Summer\\\", age: 18 }; const obj2 = { ...obj }; \",\"在 react 中，可以使用扩展运算符来传递 props\",\"const obj = { name: \\\"Summer\\\", age: 18 }; const App = () => { return <Child {...obj} />; }; \",\"关于扩展运算符和解构赋值，都需要对象具有可迭代性（iterable）\",\"引申：在 JS 中哪些数据结构具有可迭代性？\",\"数组\",\"字符串\",\"Map(ES6 新增)\",\"Set(ES6 新增)\",\"arguments（参数列表）\",\"具有可迭代性的对象，可以使用解构赋值，扩展运算符以及for...of循环\"]},\"68\":{\"title\":\"ES6新特新\",\"header\":\"类\",\"text\":[]},\"69\":{\"title\":\"ES6新特新\",\"header\":\"定义类\",\"text\":[]},\"70\":{\"title\":\"ES6新特新\",\"header\":\"ES5 的类\",\"text\":[\"javascript中没有类的概念，它是基于原型的继承，但是我们可以使用构造函数来模拟类的概念\",\"// 定义构造函数 function Person(name, age) { this.name = name; this.age = age; } // 定义方法 Person.prototype.say = function () { console.log(`My name is ${this.name}, I'm ${this.age} years old.`); }; // 实例化 const p1 = new Person(\\\"Summer\\\", 18); p1.say(); // My name is Summer, I'm 18 years old. \"]},\"71\":{\"title\":\"ES6新特新\",\"header\":\"ES6 的类\",\"text\":[\"class Person { constructor(name, age) { this.name = name; this.age = age; } say() { console.log(`My name is ${this.name}, I'm ${this.age} years old.`); } } // 实例化 const p1 = new Person(\\\"Summer\\\", 18); p1.say(); // My name is Summer, I'm 18 years old. \",\"结合上面两个代码，我们可以看出:\",\"ES6 的类，本质上还是 ES5 的构造函数,可以认为，class就是构造函数的语法糖\",\"constructor 方法，就是构造函数,用来接收参数。如果不写，默认会有一个空的constructor方法\",\"ES6中定义的方法，是类的方法，不要加上关键词function\"]},\"72\":{\"title\":\"ES6新特新\",\"header\":\"对类添加方法\",\"text\":[\"在原型链上添加方法\",\"class Person { constructor(name, age) { this.name = name; this.age = age; } say() { console.log(`My name is ${this.name}, I'm ${this.age} years old.`); } } // 添加方法 Person.prototype.eat = function () { console.log(\\\"I'm eating.\\\"); }; // 实例化 const p1 = new Person(\\\"Summer\\\", 18); p1.say(); // My name is Summer, I'm 18 years old. p1.eat(); // I'm eating. \",\"使用 Object.assign()方法\",\"class Person { constructor(name, age) { this.name = name; this.age = age; } say() { console.log(`My name is ${this.name}, I'm ${this.age} years old.`); } } // 添加方法 Object.assign(Person.prototype, { eat() { console.log(\\\"I'm eating.\\\"); }, }); // 实例化 const p1 = new Person(\\\"Summer\\\", 18); p1.say(); // My name is Summer, I'm 18 years old. p1.eat(); // I'm eating. \"]},\"73\":{\"title\":\"ES6新特新\",\"header\":\"类的继承\",\"text\":[\"具体参考：继承\"]},\"74\":{\"title\":\"ES6新特新\",\"header\":\"module 模块化\",\"text\":[\"主要就是export和import两个关键字\"]},\"75\":{\"title\":\"ES6新特新\",\"header\":\"Promise\",\"text\":[]},\"76\":{\"title\":\"ES6新特新\",\"header\":\"Promise 的基本使用\",\"text\":[\"// 定义一个 Promise 对象 const p1 = new Promise((resolve, reject) => { // resolve 成功的回调函数 // reject 失败的回调函数 // 异步操作 setTimeout(() => { const num = Math.random(); if (num > 0.5) { resolve(num); } else { reject(num); } }, 1000); }); // 调用 Promise 对象的 then 方法 p1.then( (data) => { console.log(\\\"成功\\\", data); }, (err) => { console.log(\\\"失败\\\", err); } ); \",\"从上面的代码可以看出：\",\"Promise对象是一个构造函数，通过new关键字创建一个Promise对象\",\"在还未执行到resolve或reject时，Promise对象的状态为pending，执行到resolve时，状态变为resolved，执行到reject时，状态变为rejected\",\"然后就会去调用then方法，then方法接收两个参数，第一个参数是resolve的回调函数，第二个参数是reject的回调函数\"]},\"77\":{\"title\":\"ES6新特新\",\"header\":\"Promise 的三种状态\",\"text\":[\"pending：等待状态，既不是成功也不是失败\",\"resolved：成功状态\",\"rejected: 失败状态\"]},\"78\":{\"title\":\"ES6新特新\",\"header\":\"实例方法\",\"text\":[\"then()：接收两个参数，第一个参数是resolve的回调函数，第二个参数是reject的回调函数\",\"catch()：接收一个参数，是reject的回调函数,兜底的作用\",\"finally()：接收一个参数，是resolve或reject的回调函数，不管Promise对象的状态是resolved还是rejected，都会执行\"]},\"79\":{\"title\":\"ES6新特新\",\"header\":\"构造函数方法\",\"text\":[\"all(): 接收一个数组，数组中的每一项都是一个Promise对象，当数组中的每一个Promise对象都变为resolved状态时，all()方法返回的Promise对象才会变为resolved状态，如果数组中的某一个Promise对象变为rejected状态，all()方法返回的Promise对象就会变为rejected状态\",\"// 定义一个 Promise 对象 const p1 = new Promise((resolve, reject) => { // resolve 成功的回调函数 // reject 失败的回调函数 // 异步操作 setTimeout(() => { const num = Math.random(); if (num > 0.3) { resolve(num); } else { reject(num); } }, 1000); }); const p2 = new Promise((resolve, reject) => { // resolve 成功的回调函数 // reject 失败的回调函数 // 异步操作 setTimeout(() => { const num = Math.random(); if (num > 0.5) { resolve(num); } else { reject(num); } }, 1000); }); const p3 = new Promise((resolve, reject) => { // resolve 成功的回调函数 // reject 失败的回调函数 // 异步操作 setTimeout(() => { const num = Math.random(); if (num > 0.7) { resolve(num); } else { reject(num); } }, 1000); }); // 调用 Promise 对象的 all 方法 Promise.all([p1, p2, p3]).then( (data) => { console.log(\\\"成功\\\", data); }, (err) => { console.log(\\\"失败\\\", err); } ); \",\"race(): 接收一个数组，数组中的每一项都是一个Promise对象，只要数组的某一个Promise对象变为resolved状态，race()方法返回的Promise对象就会变为resolved状态，如果数组中的某一个Promise对象变为rejected状态，race()方法返回的Promise对象就会变为rejected状态\",\"简单来说，就是，谁先来的就跟着谁变化\",\"// 定义一个 Promise 对象 const p1 = new Promise((resolve, reject) => { // resolve 成功的回调函数 // reject 失败的回调函数 // 异步操作 setTimeout(() => { const num = Math.random(); if (num > 0.3) { resolve(num); } else { reject(num); } }, 1000); }); const p2 = new Promise((resolve, reject) => { // resolve 成功的回调函数 // reject 失败的回调函数 // 异步操作 setTimeout(() => { const num = Math.random(); if (num > 0.5) { resolve(num); } else { reject(num); } }, 1000); }); const p3 = new Promise((resolve, reject) => { // resolve 成功的回调函数 // reject 失败的回调函数 // 异步操作 setTimeout(() => { const num = Math.random(); if (num > 0.7) { resolve(num); } else { reject(num); } }, 1000); }); // 调用race Promise.race([p1, p2, p3]).then( (data) => { console.log(\\\"成功\\\", data); }, (err) => { console.log(\\\"失败\\\", err); } ); \",\"resolve(): 接收一个参数，可以是一个值，也可以是一个Promise对象，如果是一个值，返回的Promise对象就会变为resolved状态，如果是一个Promise对象，返回的Promise对象的状态就会跟随参数的Promise对象的状态\",\"// 定义一个 Promise 对象 const p1 = new Promise((resolve, reject) => { // resolve 成功的回调函数 // reject 失败的回调函数 // 异步操作 setTimeout(() => { const num = Math.random(); if (num > 0.3) { resolve(num); } else { reject(num); } }, 1000); }); // 调用 Promise 对象的 resolve 方法 Promise.resolve(p1).then( (data) => { console.log(\\\"成功\\\", data); }, (err) => { console.log(\\\"失败\\\", err); } ); \",\"reject(): 接收一个参数，返回的Promise对象就会变为rejected状态\"]},\"80\":{\"title\":\"ES6新特新\",\"customFields\":{\"0\":[\"ES6篇\"],\"1\":[\"ES6\",\"新特性\"]}},\"81\":{\"title\":\"ES6篇\",\"customFields\":{\"0\":[\"ES6篇\"]}},\"82\":{\"title\":\"this指向问题\",\"header\":\"this 的指向类型\",\"text\":[\"默认绑定\",\"function fn() { console.log(this); // window } fn(); // 这个其实就是相当于window.fn() \",\"上面的代码表明，this指向的是 window。\",\"隐式绑定\",\"const obj = { name: \\\"Summer\\\", fn: function () { console.log(this); // obj }, }; obj.fn(); // \",\"上面的代码表明，this指向的是 obj。\",\"显示绑定\",\"采用一些方法，来直接改变 this 的指向\",\"const obj = { name: \\\"Summer\\\", }; function fn() { console.log(this); // obj } fn(); // window fn.call(obj); // obj \",\"我们也可以看一个稍微复杂一点的例子\",\"function sayName() { console.log(this.name); } const obj1 = { name: \\\"Summer\\\", }; const obj2 = { name: \\\"Winter\\\", }; sayName.call(obj1); // Summer sayName.call(obj2); // Winter sayName.bind(obj1)(); // Summer sayName.bind(obj2)(); // Winter sayName.bind(obj1).call(obj2); // Summer, bind改变了this的指向，所以this指向的是obj1，而call又改变了this的指向，所以this指向的是obj2 sayName.apply(obj1); // Summer \",\"这边我们引申出一个问题，call和apply和bind的区别?\"]},\"83\":{\"title\":\"this指向问题\",\"header\":\"call 和 apply 和 bind 的区别\",\"text\":[\"call和apply都是改变this的指向，而bind是返回一个新的函数，新的函数的this指向的是bind的第一个参数，而且bind的第一个参数是不能被改变的。\",\"function sayName() { console.log(this.name); } const obj1 = { name: \\\"Summer\\\", }; const obj2 = { name: \\\"Winter\\\", }; const fn1 = sayName.bind(obj1); const fn2 = sayName.bind(obj2); fn1(); // Summer fn2(); // Winter fn1.call(obj2); // Summer fn2.call(obj1); // Winter \",\"call和apply的区别在于，call的参数是一个一个传递的，而apply的参数是一个数组。\",\"function sayName() { console.log(this.name); } const obj1 = { name: \\\"Summer\\\", }; const obj2 = { name: \\\"Winter\\\", }; sayName.call(obj1); // Summer sayName.apply(obj2); // Winter sayName.call(obj1, 1, 2, 3); // Summer sayName.apply(obj2, [1, 2, 3]); // Winter \",\"apply的使用场景\",\"求数组的最大值和最小值\",\"// 不使用apply时，我们会使用遍历或者sort方法 const arr = [1, 2, 3, 4, 5]; console.log(arr.sort((a, b) => b - a)); // 5 \",\"但是这种方法并不是很便捷，所以会使用Math.max()和Math.min()方法。 但是Math.max()和Math.min()方法，他们的参数，是一个一个的传递的。\",\"console.log(Math.max(1, 2, 3, 4, 5)); // 5 console.log(Math.min(1, 2, 3, 4, 5)); // 1 \",\"所以我们就需要使用apply方法。\",\"const arr = [1, 2, 3, 4, 5]; console.log(Math.max.apply(null, arr)); // 5 console.log(Math.min.apply(null, arr)); // 1 \",\"实现数组的拼接\",\"这个不使用apply其实也可以做到，可以使用...运算符。\",\"const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; console.log([...arr1, ...arr2]); // [1, 2, 3, 4, 5, 6] \",\"但是使用apply,不需要额外的变量，也不需要额外的运算符。\",\"const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; console.log(arr1.push.apply(arr1, arr2)); // [1, 2, 3, 4, 5, 6] \",\"我的理解是，虽然apply接受的参数是一个数组，但是它会把数组中的每一个元素，都当做一个参数，传递出去。\",\"new绑定 当使用new操作符构造函数时，this 的值会绑定到新创建的对象上\",\"function Person(name) { this.name = name; } const person = new Person(\\\"Summer\\\"); console.log(person.name); // Summer \"]},\"84\":{\"title\":\"this指向问题\",\"text\":[\"总的来说，this会指向调用它的对象，但是有一些特殊情况(call,bind)。\"],\"customFields\":{\"0\":[\"ES6篇\",\"this\"],\"1\":[\"ES6\",\"this\"]}},\"85\":{\"title\":\"7.17星星充电\",\"text\":[\"自我介绍\",\"介绍一下项目，这个低代码项目\",\"使用的什么库 =＞react-dnd\",\"页面是如何缓存的？如何做到的？=＞直接存在了缓存中\",\"Localstore和sessionstore的区别？\",\"Div元素垂直居中\",\"px，em，rem区别\",\"如何适配移动端？\",\"viewport是什么\",\"Meta，html里面的Meta有什么作用\",\"diff算法是怎样的？怎样执行的？怎么比较的\",\"http和https\",\"useEffect\",\"JavaScript的基本类型\",\"Typeof null =object的原因是什么？\",\"深拷贝和浅拷贝，基本类型怎么进行拷贝的？他复制的就不是地址吗？\",\"节流和防抖，项目中你如何做的？\",\"css盒模型=＞Box它是几部分组成的？\",\"你对MVVM的理解\",\"多个请求同时进行，用什么？=＞promise.all（），他返回的是一个还是多个？\",\"Premise all遇到错误的时候是怎么做的？\",\"数组是怎么遍历的？map和foreach区别？map返回的是啥？\",\"JavaScript的作用域\",\"闭包\",\"继承=＞call，this指向谁\",\"将两个数组合并并且去重\"],\"customFields\":{\"0\":[\"InterviewRecord\"]}},\"86\":{\"title\":\"Javascript数据类型\",\"header\":\"基本数据类型\",\"text\":[]},\"87\":{\"title\":\"Javascript数据类型\",\"header\":\"Number\",\"text\":[\"转化为数字的方法parseInt()和Number() 有什么区别？\",\"Number()只可以转化纯数字字符串或者空字符串，长度为 1/0 的数组，布尔值，null\",\"ParseInt()只能将字符串转化为数字，遇到不可以转化的就截断，返回已经转化的数字，如果第一个字符就不可以转化，返回NaN\",\"value\",\"Number()\",\"parseInt()\",\"'123'\",\"123\",\"123\",\"'123a'\",\"NaN\",\"123\",\"'a123'\",\"NaN\",\"NaN\",\"true/false\",\"1/0\",\"NaN\",\"null\",\"0\",\"NaN\",\"[] / [1]\",\"0/1\",\"NaN\",\"\\\"\\\"\",\"0\",\"NaN\"]},\"88\":{\"title\":\"Javascript数据类型\",\"header\":\"String\",\"text\":[]},\"89\":{\"title\":\"Javascript数据类型\",\"header\":\"Boolean\",\"text\":[\"转化为布尔值的方法：Boolean()和!!\",\"Boolean()\",\"!!:双重非运算符\",\"布尔值转化为false的情况：\",\"0(数字 0)\",\"null\",\"undefined\",\"NaN\",\"''(空字符串)其他情况都是转化为true，比如[],{}等\"]},\"90\":{\"title\":\"Javascript数据类型\",\"header\":\"Null\",\"text\":[\"typeof null会返回object\"]},\"91\":{\"title\":\"Javascript数据类型\",\"header\":\"Undefined\",\"text\":[\"undefined是一个全局变量，它的值就是undefined，一般typeof undefined会返回undefined,它其实就是变量声明，但是没有赋值的情况下的默认值\",\"undefined和null的区别：\",\"undefined是一个变量，而null是一个关键字\",\"undefined是变量声明，但是没有赋值的情况下的默认值，而null是一个空对象指针(Object)\",\"undefined的类型是undefined，而null的类型是object\",\"undefined转化为数字是NaN，而null转化为数字是0\",\"null == undefined // true\"]},\"92\":{\"title\":\"Javascript数据类型\",\"header\":\"Symbol\",\"text\":[]},\"93\":{\"title\":\"Javascript数据类型\",\"header\":\"引用数据类型\",\"text\":[]},\"94\":{\"title\":\"Javascript数据类型\",\"header\":\"Object\",\"text\":[]},\"95\":{\"title\":\"Javascript数据类型\",\"header\":\"Array\",\"text\":[]},\"96\":{\"title\":\"Javascript数据类型\",\"header\":\"Function\",\"text\":[]},\"97\":{\"title\":\"Javascript数据类型\",\"header\":\"Date\",\"text\":[]},\"98\":{\"title\":\"Javascript数据类型\",\"header\":\"RegExp\",\"text\":[]},\"99\":{\"title\":\"Javascript数据类型\",\"header\":\"存储位置\",\"text\":[\"基本数据类型的值是存储在栈内存中的，每个变量都有自己的内存空间，互不影响\",\"引用数据类型的值是存储在堆内存中的，每个变量存储的是一个指针，指向存储在堆内存中的对象，这个对象包含了实际的值\",\"数据类型的存储位置\"]},\"100\":{\"title\":\"Javascript数据类型\",\"customFields\":{\"0\":[\"Javascript篇\"],\"1\":[\"Javascript\",\"数据类型\"]}},\"101\":{\"title\":\"数组常用方法\",\"header\":\"操作方法\",\"text\":[\"操作方法我们可以从CRUD(增删改查)四个方面来进行分类\"]},\"102\":{\"title\":\"数组常用方法\",\"header\":\"增加元素\",\"text\":[\"不会改变数组本身 \",\"concat():连接两个或多个数组，返回新数组\",\"会改变数组本身 \",\"push():在数组末尾添加元素，返回数组长度\",\"shift():在数组开头添加元素，返回数组长度\",\"splice(start,deleteCount,item1,item2...):在数组中间添加元素，返回删除的元素组成的数组\"]},\"103\":{\"title\":\"数组常用方法\",\"header\":\"删除元素\",\"text\":[\"不会改变数组本身 \",\"slice(start,end):返回一个新数组，包含从start到end(不包括end)的元素\",\"会改变数组本身 \",\"pop():删除数组末尾的元素，返回删除的元素\",\"unshift():删除数组开头的元素，返回删除的元素\",\"splice(start,deleteCount,item1,item2...):从start位置开始删除deleteCount个，返回删除的元素组成的数组\"]},\"104\":{\"title\":\"数组常用方法\",\"header\":\"修改元素\",\"text\":[\"修改数组，一般使用slice()和splice()方法\"]},\"105\":{\"title\":\"数组常用方法\",\"header\":\"查找元素\",\"text\":[\"ES6之前 \",\"indexOf()/lastIndexOf():返回元素在数组中的位置，如果不存在，返回-1\",\"ES6之后 \",\"find():返回第一个符合条件的元素\",\"includes():返回布尔值，表示是否找到了元素\"]},\"106\":{\"title\":\"数组常用方法\",\"header\":\"排序方法\",\"text\":[\"sort()，可以传入一个比较函数，比较函数返回值为-1，0，1，分别表示小于，等于，大于，会改变数组本身\",\"reverse(),将数组进行反转，会改变数组本身\"]},\"107\":{\"title\":\"数组常用方法\",\"header\":\"迭代方法\",\"text\":[\"所有的迭代方法都不会改变数组本身\",\"forEach((item,index,array)=>{}):遍历数组，对每个元素进行操作，没有返回值\",\"map((item,index,array)=>{}):遍历数组，对每个元素进行操作，返回一个新数组\",\"filter((item,index,array)=>{}):遍历数组，对每个元素进行操作，返回一个新数组，新数组中的元素是通过测试的元素\",\"some((item,index,array)=>{}):遍历数组，对每个元素进行操作，返回一个布尔值，只要有一个元素通过测试，就返回true\",\"every((item,index,array)=>{}):遍历数组，对每个元素进行操作，返回一个布尔值，只有所有元素都通过测试，才返回true\",\"reduce((prev,cur,index,array)=>{},initValue):遍历数组，对每个元素进行操作，返回一个值，该值会作为下一次迭代的prev，initValue为初始值，如果没有初始值，那么第一次迭代的prev为数组的第一个元素，cur为数组的第二个元素\"]},\"108\":{\"title\":\"数组常用方法\",\"header\":\"转化方法\",\"text\":[\"数组转化为字符串\",\"toString():将数组转化为字符串，每个元素用,隔开\",\"join():将数组转化为字符串，每个元素用指定的字符串隔开\"]},\"109\":{\"title\":\"数组常用方法\",\"customFields\":{\"0\":[\"Javascript篇\"],\"1\":[\"Javascript\",\"数据类型\"]}},\"110\":{\"title\":\"字符串常用方法\",\"header\":\"操作方法\",\"text\":[\"操作方法我们也是从CRUD(增删改查)的角度来看待的 其实可以将字符串看作是一种string[],只是这种数组，不可以修改，只读\"]},\"111\":{\"title\":\"字符串常用方法\",\"header\":\"增加元素\",\"text\":[\"concat():连接字符串\",\"模板字符串:ES6新增的字符串拼接方法，使用反引号(``)来标识，变量使用${}来标识\",\"+(加号)：字符串拼接\"]},\"112\":{\"title\":\"字符串常用方法\",\"header\":\"删除元素\",\"text\":[\"slice(start,end):截取字符串,[start,end)\",\"substr(start,length):截取字符串,[start,start+length)\",\"substring(start,end):截取字符串,[start,end)\",\"返回的都是一个新的string\"]},\"113\":{\"title\":\"字符串常用方法\",\"header\":\"修改元素\",\"text\":[\"trim()/trimLeft()/trimRight():去除字符串两端的空格\",\"repeat(count):重复字符串，返回一个新的字符串\",\"toLowerCase()/toUpperCase():将字符串转化为小写/大写\",\"padStart(targetLength,padString)/padEnd(targetLength,padString):用padString填充字符串，使其长度为targetLength\"]},\"114\":{\"title\":\"字符串常用方法\",\"header\":\"查找元素\",\"text\":[\"indexOf():查找字符串中是否包含searchValue,如果包含，返回第一次出现的位置，否则返回-1\",\"includes():查找字符串中是否包含searchValue,如果包含，返回true，否则返回false\",\"charAt(index):返回指定位置的字符\"]},\"115\":{\"title\":\"字符串常用方法\",\"header\":\"转换方法\",\"text\":[\"将字符串转化为数组的方法：\",\"split(separator,limit):将字符串按照separator分割成数组，limit表示最大分割次数\"]},\"116\":{\"title\":\"字符串常用方法\",\"header\":\"模板匹配方法\",\"text\":[\"其实就是进行正则匹配的方法\",\"match():返回匹配到的字符串数组\",\"search():返回匹配到的第一个字符串的位置\",\"replace():返回替换后的字符串\"]},\"117\":{\"title\":\"字符串常用方法\",\"customFields\":{\"0\":[\"Javascript篇\"],\"1\":[\"Javascript\",\"数据类型\"]}},\"118\":{\"title\":\"类型转化机制\",\"header\":\"显示类型转化\",\"text\":[\"转化为Number的方法: parseInt()和Number()\",\"转化为String的方法: toString()和String()\",\"转化为Boolean的方法: Boolean()和!!\",\"具体可以参考JavaScript 数据类型\"]},\"119\":{\"title\":\"类型转化机制\",\"header\":\"隐式类型转化\",\"text\":[\"隐式类型转化发生的场景：\",\"比较运算符(==,!=,===,!==,>,<,>=,<=),if,while 这种需要转化为boolean的场景，会将其他类型转化为boolean，然后再进行比较\",\"算术运算符(+,-,*,/,%)\",\"自动转化为字符串一般遇到+,并且有字符串，那么就会转化为字符串\",\"\\\"5\\\" + 1; // '51' \\\"5\\\" + true; // \\\"5true\\\" \\\"5\\\" + false; // \\\"5false\\\" \\\"5\\\" + {}; // \\\"5[object Object]\\\" \\\"5\\\" + []; // \\\"5\\\" \\\"5\\\" + function () {}; // \\\"5function (){}\\\" \\\"5\\\" + undefined; // \\\"5undefined\\\" \\\"5\\\" + null; // \\\"5null\\\" \",\"自动转化为数字除了+会转化为字符串，其他都是转为数字\\n转化应该调用的是Number()方法，将undefined转化为NaN，将null转化为0\"]},\"120\":{\"title\":\"类型转化机制\",\"customFields\":{\"0\":[\"Javascript篇\"],\"1\":[\"Javascript\",\"数据类型\"]}},\"121\":{\"title\":\"等于vs完全等于\",\"header\":\"等于\",\"text\":[\"等于==属于比较运算符，会进行隐式类型转换，转换规则如下： 笼统的说，就是如果两个值类型不同，那么就会进行类型转换，转换成相同的类型，再进行比较。\",\"如果一方是布尔值或者是字符串，那么会将布尔值/字符串转换为数字，再进行比较\",\"null == undefined //true\",\"NaN和任何值都不相等，包括自己：NaN == NaN //false\",\"如果一方是Object(对象)，一方是String、Number或者Symbol，那么会将对象转换为原始类型的值(obj.valueOf())，再进行比较\",\"如果两方都是Object(对象)，那么比较的是两个对象的引用是否相等 意思就是：比较这两个对象是不是同一个对象(栈内存里面的地址必须相同)\"]},\"122\":{\"title\":\"等于vs完全等于\",\"header\":\"完全等于\",\"text\":[\"完全等于===属于比较运算符，不会进行隐式类型转换，如果类型不同，直接返回false，如果类型相同，再进行值的比较。\",\"下面给出一些例子：\",\"compare\",\"==\",\"===\",\"\\\"55\\\"和 55\",\"true\",\"false\",\"null 和 undefined\",\"true\",\"false\",\"NaN 和 NaN\",\"false\",\"false\",\"null 和 null\",\"true\",\"true\",\"undefined 和 undefined\",\"true\",\"true\",\"{a:1}和{a:1}\",\"false\",\"false\"]},\"123\":{\"title\":\"等于vs完全等于\",\"header\":\"总结\",\"text\":[\"==会进行隐式类型转换，转换成相同的类型，再进行比较\",\"===不会进行隐式类型转换，如果类型不同，直接返回false，如果类型相同，再进行值的比较\",\"null == undefined //true\",\"null === undefined //false\"]},\"124\":{\"title\":\"等于vs完全等于\",\"customFields\":{\"0\":[\"Javascript篇\"],\"1\":[\"Javascript\",\"数据类型\"]}},\"125\":{\"title\":\"深拷贝vs浅拷贝\",\"header\":\"浅拷贝\",\"text\":[\"浅拷贝只是复制了一层对象的属性，如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。笼统来说，就是它只管一层\",\"代码实现\"]},\"126\":{\"title\":\"深拷贝vs浅拷贝\",\"header\":\"常见的浅拷贝方法\",\"text\":[\"Object.assign()\",\"Array.prototype.concat()\",\"拓展运算符([...obj])\"]},\"127\":{\"title\":\"深拷贝vs浅拷贝\",\"header\":\"深拷贝\",\"text\":[\"深拷贝就是能够实现真正意义上的对象拷贝。深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。\",\"代码实现\",\"但是这个深拷贝没有考虑到数组的情况,只考虑了普通Object情况，所以还需要对数组进行判断\",\"但是这个深拷贝还有一个问题，就是循环引用的问题，比如：\",\"let obj = { a: 1, b: { c: 2, }, }; obj.b.d = obj.b; \",\"这样的话，就会造成死循环，所以我们需要一个容器来存储已经拷贝过的对象，如果已经拷贝过了，就直接返回，不需要再次拷贝。\",\"接着我们可以参考，js 的垃圾回收机制，把map换为WeakMap，这样的话，当obj被回收的时候，WeakMap也会被回收，这样就不会造成内存泄漏了。\",\"补充WeakMap\",\"WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名\",\"WeakMap属于弱引用，当WeakMap的键名所指向的对象被回收，那么WeakMap的键名和键值也会被回收\",\"但是即使这样，这个深拷贝还是有问题的，就是对于Date、RegExp、Error、Function等特殊对象，还是没有考虑到，所以我们需要对这些特殊对象进行判断,这边就不写了，有兴趣的可以自己写一下。\"]},\"128\":{\"title\":\"深拷贝vs浅拷贝\",\"header\":\"常见的深拷贝方法\",\"text\":[\"JSON.parse(JSON.stringify(obj)):将对象转换为字符串，再将字符串转换为对象\",\"lodash.cloneDeep(obj)\"]},\"129\":{\"title\":\"深拷贝vs浅拷贝\",\"header\":\"参考文章\",\"text\":[\"如何写出一个惊艳面试官的深拷贝\"]},\"130\":{\"title\":\"深拷贝vs浅拷贝\",\"customFields\":{\"0\":[\"Javascript篇\"],\"1\":[\"Javascript\",\"手写题\"]}},\"131\":{\"title\":\"JavaScript篇\",\"customFields\":{\"0\":[\"JavaScript篇\"]}},\"132\":{\"title\":\"null和undefined的区别\",\"header\":\"undefined\",\"text\":[\"在javascript中，undefined是一个全局变量，它的值是undefined，当一个变量声明了但是没有赋值时，它的值就是undefined，或者当一个对象没有赋值的属性时，它的值也是undefined。\",\"// 没有赋值的变量，默认为undefined let a; console.log(a); // undefined // 没有赋值的对象属性，默认为undefined let obj = {}; console.log(obj.a); // undefined \"]},\"133\":{\"title\":\"null和undefined的区别\",\"header\":\"null\",\"text\":[\"null表示当前这个值，已经赋值为null了，它是一个空对象指针，表示一个空对象，所以typeof null的值是object。\",\"// 赋值为null let a = null; console.log(a); // null // 赋值为null的对象，typeof的值是object let obj = { a: null, }; console.log(obj.a); // null console.log(typeof obj.a); // object \"]},\"134\":{\"title\":\"null和undefined的区别\",\"header\":\"null 和 undefined 的相同点\",\"text\":[\"条件判断的时候，undefined和null都会转换为false。\",\"if (!undefined) { console.log(\\\"undefined is false\\\"); } // undefined is false if (!null) { console.log(\\\"null is false\\\"); } // null is false \",\"使用==进行比较的时候，null和undefined是相等的。\",\"这是因为==他会进行类型转换，null和undefined都会转换为false，所以他们是相等的。\",\"console.log(null == undefined); // true \"]},\"135\":{\"title\":\"null和undefined的区别\",\"header\":\"null 和 undefined 的不同点\",\"text\":[\"Number()转化为数字的时候，undefined转化为NaN，null转化为0。\",\"这是因为null是一个空对象，转化为数字的时候，就是0，而undefined是一个未定义的值，转化为数字的时候，就是NaN。\",\" console.log(Number(undefined)); // NaN console.log(Number(null)); // 0 \"]},\"136\":{\"title\":\"null和undefined的区别\",\"customFields\":{\"0\":[\"JavaScript\"],\"1\":[\"JavaScript\",\"数据结构\"]}},\"137\":{\"title\":\"事件循环\",\"header\":\"产生的原因\",\"text\":[\"JavaScript 是单线程的，也就是说，JavaScript 只能同时执行一个任务，而其他任务都必须在后面排队等待。但是这不代表，JavaScript 就会导致任务堵塞，因为 JavaScript 还有一个特性，就是异步执行。\"]},\"138\":{\"title\":\"事件循环\",\"header\":\"任务队列\",\"text\":[\"JavaScript 引擎会维护一个任务队列，任务队列中的任务分为两种，一种是同步任务，一种是异步任务。\",\"同步任务会在主线程上排队执行，前一个任务执行完毕，才会执行后一个任务。\",\"异步任务则会在异步任务有了结果后，将注册的回调函数放入任务队列中，等待主线程的空闲时间来执行。\"]},\"139\":{\"title\":\"事件循环\",\"header\":\"事件循环\",\"text\":[\"事件循环是指，主线程不断从任务队列中读取任务，只要主线程空闲，就会去读取任务队列，这个过程是循环不断的，所以叫做事件循环。\"]},\"140\":{\"title\":\"事件循环\",\"header\":\"宏任务和微任务\",\"text\":[\"但是如果只将任务划分为同步任务和异步任务，那么异步任务又分为很多种，比如setTimeout、setInterval、Promise、async/await等等，这些异步任务又有什么区别呢？\",\"其实，JavaScript将异步任务分为了两种，一种是宏任务，一种是微任务。\",\"宏任务：setTimeout、setInterval、setImmediate、I/O、UI rendering等等。\",\"微任务：Promise.then()、process.nextTick等等。\",\"执行顺序：当主线程空闲时，会先执行微任务队列中的任务，然后再执行宏任务队列中的任务。\",\"引申：宏任务和微任务有哪些区别？\",\"宏任务和微任务都是异步任务，但是宏任务的优先级要低于微任务。\"]},\"141\":{\"title\":\"事件循环\",\"header\":\"代码示例\",\"text\":[\"console.log(\\\"script start\\\"); setTimeout(function () { console.log(\\\"setTimeout\\\"); }, 0); Promise.resolve() .then(function () { console.log(\\\"promise1\\\"); }) .then(function () { console.log(\\\"promise2\\\"); }); console.log(\\\"script end\\\"); \",\"代码分析：\",\"首先执行同步任务，输出script start\",\"遇到setTimeout，将其放入宏任务队列中\",\"遇到了Promise，将其放入微任务队列中\",\"执行同步任务，输出script end\",\"这时候主线程空闲，开始执行微任务队列中的任务，输出promise1，promise2\",\"微任务队列中的任务执行完毕，开始执行宏任务队列中的任务，输出setTimeout\",\"console.log(\\\"1\\\"); setTimeout(function () { console.log(\\\"2\\\"); Promise.resolve().then(function () { console.log(\\\"3\\\"); }); }); Promise.resolve().then(function () { console.log(\\\"4\\\"); setTimeout(function () { console.log(\\\"5\\\"); }); }); \",\"代码分析：\",\"同步任务，输出1\",\"setTimeout放入宏任务队列\",\"Promise放入微任务队列\",\"主线程空闲，执行微任务队列中的任务，输出4\",\"在微任务队列中，遇到setTimeout，将其放入宏任务队列\",\"此时微任务队列中的任务执行完毕，开始执行宏任务队列中的任务，输出2\",\"在宏任务队列中，遇到Promise，将其放入微任务队列\",\"执行微任务队列中的任务，输出3\",\"微任务队列中的任务执行完毕，开始执行宏任务队列中的任务，输出5\",\"console.log(\\\"1\\\"); setTimeout(function () { console.log(\\\"2\\\"); Promise.resolve().then(function () { console.log(\\\"3\\\"); }); }); Promise.resolve().then(function () { console.log(\\\"4\\\"); setTimeout(function () { console.log(\\\"5\\\"); Promise.resolve().then(function () { console.log(\\\"6\\\"); }); }); }); \",\"代码分析：\",\"同步任务，输出1\",\"setTimeout放入宏任务队列\",\"Promise放入微任务队列\",\"同步任务执行完毕，执行微任务队列中的任务，输出4\",\"在微任务队列中，遇到setTimeout，将其放入宏任务队列\",\"微任务队列空闲，执行宏任务队列中的任务，输出2\",\"在宏任务队列中，遇到Promise，将其放入微任务队列\",\"执行微任务队列中的任务，输出3\",\"此时微任务队列中的任务执行完毕，开始执行宏任务队列中的任务，输出5\",\"在宏任务队列中，遇到Promise，将其放入微任务队列\",\"去执行微任务队列中的任务，输出6\",\"console.log(\\\"1\\\"); setTimeout(function () { console.log(\\\"2\\\"); Promise.resolve().then(function () { console.log(\\\"3\\\"); }); }); Promise.resolve().then(function () { console.log(\\\"4\\\"); setTimeout(function () { console.log(\\\"5\\\"); Promise.resolve().then(function () { console.log(\\\"6\\\"); }); }); }); setTimeout(function () { console.log(\\\"7\\\"); Promise.resolve().then(function () { console.log(\\\"8\\\"); }); }); // 1 4 2 3 5 6 7 8 \",\"console.log('1'); setTimeout(function() { console.log('2'); Promise.resolve().then(function() { console.log('3'); }); process.nextTick(function() { console.log('4'); }); setImmediate(function() { console.log('5'); }); }); Promise.resolve().then(function() { console.log('6'); process.nextTick(function() { console.log('7'); }); setImmediate(function() { console.log('8'); }); }); // 1 6 7 2 4 3 8 5 \",\"这边出现了process.nextTick和setImmediate。记一下，process.nextTick属于微任务，而setTmmdiate属于宏任务\",\"代码分析：\",\"首先进行同步任务，输出1\",\"setTimeout放入宏任务队列\",\"Promise放入微任务队列\",\"此时主线程空闲，执行微任务队列中的任务，输出6\",\"遇到了process.nextTick，将其放入微任务队列\",\"遇到了setImmediate，将其放入宏任务队列\",\"接着执行微任务队列中的任务(nextTick)，输出7\",\"此时宏任务队列中的任务执行完毕，开始执行微任务队列中的任务，输出2\",\"遇到了Promise，将其放入微任务队列\",\"遇到了process.nextTick，将其放入微任务队列\",\"遇到了setImmediate，将其放入宏任务队列\",\"当前宏任务队列中的任务执行完毕，开始执行微任务队列中的任务\",\"因为process.nextTick的优先级比Promise高，所以先执行process.nextTick，输出4\",\"接着执行微任务队列中的任务，输出3\",\"微任务队列中的任务执行完毕，开始执行宏任务队列中的任务，输出8\",\"继续执行宏任务队列中的任务，输出5\",\"console.log('start'); setTimeout(() => { console.log('children2'); Promise.resolve().then(() => { console.log('children3'); }) }, 0); new Promise(function(resolve, reject) { console.log('children4'); setTimeout(function() { console.log('children5'); resolve('children6') // 这里的resolve，会调用那个then函数 }, 0) }).then((res) => { console.log('children7'); setTimeout(() => { console.log(res); }, 0) }) // start children4 children2 children3 children5 children7 children6 \",\"注意：async和await\",\"async函数返回的是一个Promise对象(同步执行)\",\"await后面跟着的是一个Promise对象，如果不是，会被转换成一个立即resolve的Promise对象(异步执行)\",\"参考文档：\",\"深入浅出浏览器事件循环\"]},\"142\":{\"title\":\"事件循环\",\"customFields\":{\"0\":[\"JavaScript\"],\"1\":[\"JavaScript\",\"Event Loop\"]}},\"143\":{\"title\":\"作用域链\",\"header\":\"作用域链分类\",\"text\":[\"块级作用域\",\"函数作用域\",\"全局作用域\"]},\"144\":{\"title\":\"作用域链\",\"header\":\"作用域链\",\"text\":[\"当访问一个变量时，会先从当前作用域查找，如果没有找到，就会从父级作用域查找，直到找到该变量或者到全局作用域，如果全局作用域也没有找到，就会报错(TypeError)。\"]},\"145\":{\"title\":\"作用域链\",\"header\":\"词法作用域\",\"text\":[\"词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，因为它的作用域在函数定义的时候就决定了。并不是在调用的地方，只有箭头函数，确认 this 才是，在那里调用，this 指向谁\",\"var value = 1; function foo() { console.log(value); } function bar() { var value = 2; foo(); // 调用的地方，不是作用域的地方 } bar(); // 1 \",\"分析词法作用域：\",\"函数foo的作用域是全局作用域，所以foo的作用域链是foo -> 全局作用域\",\"函数bar的作用域是全局作用域，所以bar的作用域链是bar -> 全局作用域\",\"Q：为什么结果输出为 1？\",\"A：因为foo的作用域链是foo -> 全局作用域，所以在foo中查找value时，会先从foo的作用域中查找，如果没有找到，就会从父级作用域中查找，直到找到该变量或者到全局作用域，如果全局作用域也没有找到，就会报错(TypeError)。\",\"可以这么说，闭包就是在作用域链中查找变量的一种机制。\"]},\"146\":{\"title\":\"作用域链\",\"header\":\"作用域链的场景\",\"text\":[]},\"147\":{\"title\":\"作用域链\",\"header\":\"闭包\",\"text\":[\"function foo() { var value = 1; let fn1 = function () { console.log(value); }; return fn1; } foo()(); // 1 \",\"我们可以分析出：\",\"函数foo的作用域是全局作用域，所以foo的作用域链是foo -> 全局作用域\",\"函数fn1的作用域是foo的作用域，所以fn1的作用域链是fn1 -> foo -> 全局作用域\",\"这也就是我们说的，闭包中内部函数可以访问外部变量的原因\"]},\"148\":{\"title\":\"作用域链\",\"header\":\"事件委托\",\"text\":[\"补充：\",\"什么是事件委托？\",\"事件委托就是利用事件冒泡(由内到外)，只指定一个事件处理程序，就可以管理某一类型的所有事件。\",\"事件委托适用于那些场景？\",\"一个大量数据的列表，需要对列表的每一项都能进行一些相同的事件。假如我们为每一个列表项都增加点击事件，那么工作量很大。这样我们就可以直接在ul上增加点击事件，等待事件冒泡，执行操作。\",\"还有一种常见场景，列表不是很大，但是需要动态的增加item,并且增加的item还会绑定事件,这时候哦我们可以使用事件委托。\",\"一般情况下，适合事件委托的事件有：\",\"click，点击事件这类\",\"mousedown,对于鼠标操作这类\",\"keydown，keypress,keyup,对于键盘操作这类\",\"举例：\",\"<ul id=\\\"ul\\\"> <li>1</li> <li>2</li> <li>3</li> </ul> \",\"let ul = document.getElementById(\\\"ul\\\"); ul.addEventListener(\\\"click\\\", function (e) { console.log(e.target.innerHTML); }); \",\"当用户点击ul的子元素时，事件处理程序就会创建一个执行上下文，并将这个上下文添加到执行环境中。在这个执行环境中，可以通过作用域链来访问属性和方法和e事件对象。\",\"既然提到事件委托，那么我们就来谈谈 Javascript 的事件模型\"]},\"149\":{\"title\":\"作用域链\",\"header\":\"引申：事件模型\",\"text\":[]},\"150\":{\"title\":\"作用域链\",\"header\":\"事件和事件流\",\"text\":[\"产生原因： 因为DOM是一个树形结构，所以当父子元素都绑定了事件的时候，就会出现，事件的执行的先后顺序问题。\",\"事件流阶段：\",\"捕获阶段(从根元素开始往下寻找，一直找到目标元素，然后执行)\",\"目标阶段\",\"冒泡阶段(从当前元素开始往外查找，一直找到根元素为止)\"]},\"151\":{\"title\":\"作用域链\",\"header\":\"事件模型\",\"text\":[\"事件模型分为两种：\",\"原始事件模型\",\"标准事件模型\"]},\"152\":{\"title\":\"作用域链\",\"header\":\"原始事件模型\",\"text\":[\"原始事件模型就是指在IE8及其以下版本中使用的事件模型，这种事件模型只支持冒泡阶段，不支持捕获阶段。使用的是onCLick这种方式绑定事件。\",\"<div id=\\\"div1\\\"> <div id=\\\"div2\\\"> <div id=\\\"div3\\\"></div> </div> <div id=\\\"div4\\\"></div> </div> \",\"let div1 = document.getElementById(\\\"div1\\\"); let div2 = document.getElementById(\\\"div2\\\"); let div3 = document.getElementById(\\\"div3\\\"); let div4 = document.getElementById(\\\"div4\\\"); div1.onclick = function () { console.log(\\\"div1\\\"); }; div2.onclick = function () { console.log(\\\"div2\\\"); }; div3.onclick = function () { console.log(\\\"div3\\\"); }; div4.onclick = function () { console.log(\\\"div4\\\"); }; \",\"当我们点击div3时，会依次输出div3,div2,div1。\",\"这是因为，原始事件模型，只支持冒泡阶段，所以当我们点击div3时，会从div3开始，一直往外查找，直到根元素div1，然后执行事件处理程序。\"]},\"153\":{\"title\":\"作用域链\",\"header\":\"标准事件模型\",\"text\":[\"标准事件模型就是指在IE9及其以上版本中使用的事件模型，这种事件模型同时支持冒泡阶段和捕获阶段。使用的是addEventListener这种方式绑定事件。\",\"<div id=\\\"div1\\\"> <div id=\\\"div2\\\"> <div id=\\\"div3\\\"></div> </div> <div id=\\\"div4\\\"></div> </div> \",\"let div1 = document.getElementById(\\\"div1\\\"); let div2 = document.getElementById(\\\"div2\\\"); let div3 = document.getElementById(\\\"div3\\\"); let div4 = document.getElementById(\\\"div4\\\"); div1.addEventListener(\\\"click\\\", function () { console.log(\\\"div1\\\"); }); div2.addEventListener(\\\"click\\\", function () { console.log(\\\"div2\\\"); }); div3.addEventListener(\\\"click\\\", function () { console.log(\\\"div3\\\"); }); div4.addEventListener(\\\"click\\\", function () { console.log(\\\"div4\\\"); }); \",\"addEventListener接收三个参数：\",\"第一个参数：事件类型\",\"第二个参数: 事件处理程序\",\"第三个参数：是否在捕获阶段执行事件处理程序，默认为false，即在冒泡阶段执行事件处理程序。\",\"这是因为，现代浏览器的事件模型，同时支持冒泡阶段和捕获阶段，所以当我们点击div3时，会从div1开始，一直往下查找，直到div3，然后执行事件处理程序。\",\"现在我们可以分析上述代码：点击div3时，会依次输出div3,div2,div1。\"]},\"154\":{\"title\":\"作用域链\",\"customFields\":{\"0\":[\"JavaScript\"],\"1\":[\"作用域链\"]}},\"155\":{\"title\":\"数组的原型链\",\"header\":\"原型\",\"text\":[\"每个函数都有一个 prototype 属性，这个属性指向函数的原型对象。原型对象中有一个 constructor 属性，指向函数本身。\"]},\"156\":{\"title\":\"数组的原型链\",\"header\":\"原型链\",\"text\":[\"每个对象都有一个 proto 属性，指向创建它的构造函数的原型对象。 原型对象也是对象，也有 proto 属性，指向创建它的构造函数的原型对象。这样一层一层，就形成了原型链。\"]},\"157\":{\"title\":\"数组的原型链\",\"header\":\"数组的原型链\",\"text\":[\"数组本身就是一个特殊的对象，所以数组的原型链和对象的原型链是一样的。\"]},\"158\":{\"title\":\"数组的原型链\",\"text\":[\"首先先来介绍一下原型和原型链\"],\"customFields\":{\"0\":[\"JavaScript\",\"数组\"],\"1\":[\"数组\",\"原型链\"]}},\"159\":{\"title\":\"类的继承\",\"header\":\"ES5 的继承\",\"text\":[\"基于原型链的继承\",\"// 定义父类 function Person{ this.name = name; this.age = age; } // 定义父类的方法 Person.prototype.say = function(){ console.log(`My name is ${this.name}, I'm ${this.age} years old.`); } // 定义子类 function Student(grade){ this.grade = grade; } // 继承父类 Student.prototype = new Person(\\\"summer\\\",12); // 实例化 const s1 = new Student(1); s1.say(); // My name is summer, I'm 12 years old. \",\"基于构造函数继承\",\"在子类中，使用call()调用父类的构造函数，这样就可以实现继承，将父类的属性添加到子类的实例上，将属性变为实例属性\",\"// 构造函数 function Person(name, age) { this.name = name; this.age = age; } // 定义方法 Person.prototype.say = function () { console.log(`My name is ${this.name}, I'm ${this.age} years old.`); }; // 定义子类 function Student(name, age, grade) { Person.call(this, name, age); // 相当于将父类的实例复制了一份给了子类 this.grade = grade; } // 实例化 const s1 = new Student(\\\"summer\\\", 12, 1); s1.say(); // 报错 \",\"但是如果是基于构造函数的继承，子类无法获取到父类原型上的方法\",\"组合继承(构造函数继承+原型链继承)\",\"// 构造函数 function Person(name, age) { this.name = name; this.age = age; } // 实现方法 Person.prototype.say = function () { console.log(`My name is ${this.name}, I'm ${this.age} years old.`); }; // 定义子类 function Student(name, age, grade) { Person.call(this, name, age); // 构造函数继承获取到父类的属性 this.grade = grade; } // 原型链继承 Student.prototype = new Person(); // 原型链继承获取到父类的方法 // 实例化 const s1 = new Student(\\\"summer\\\", 12, 1); s1.say(); // My name is summer, I'm 12 years old. \"]},\"160\":{\"title\":\"类的继承\",\"header\":\"ES6 的继承\",\"text\":[\"// 定义父类 class Person { constructor(name, age) { this.name = name; this.age = age; } say() { console.log(`My name is ${this.name}, I'm ${this.age} years old.`); } } // 定义子类 class Student extends Person { constructor(name, age, grade) { super(name, age); // 调用父类的构造函数 this.grade = grade; } } // 实例化 const s1 = new Student(\\\"summer\\\", 12, 1); s1.say(); // My name is summer, I'm 12 years old. \",\"super关键字的作用：\",\"通过调用super可以让子类访问到父类的方法和属性\",\"可以使用super调用父类的构造函数，super()相当于Person.call(this, name, age)\",\"super可以调用原型方法和静态方法\",\"class Person{ constructor(name,age){ this.name = name; this.age = age } // 添加原型方法 say(){ console.log(\\\"hello,\\\"+this.name) } // 添加静态方法 static sayHi(){ console.log(\\\"hi,\\\"+this.name) } } // 子类 class Student{ // 继承属性 constructor(name,age,grade){ // 调用父类的构造函数 super(name,age) this.grade = grade } // 继承方法，对方法进行重写 say(){ console.log(\\\"hello,\\\"+this.name+\\\",I'm \\\"+this.age+\\\" years old.\\\") } } \"]},\"161\":{\"title\":\"类的继承\",\"customFields\":{\"0\":[\"JavaScript\"],\"1\":[\"继承\",\"类\"]}},\"162\":{\"title\":\"HTTP基本概念\",\"customFields\":{\"0\":[\"Network 篇\",\"HTTP\"],\"1\":[\"Network\",\"HTTP\",\"basic\"]}},\"163\":{\"title\":\"Network篇\",\"text\":[\"参考文档：\",\"小林X图解计算机基础\",\"面试官-HTTP\"],\"customFields\":{\"0\":[\"Network篇\"]}},\"164\":{\"title\":\"TCP/IP网络模型\",\"header\":\"应用层\",\"text\":[\"应用层是网络应用程序及它们的应用层协议存留的地方，例如HTTP、FTP、SMTP、DNS等。\",\"我们手机上的APP，电脑上的软件，都是应用层的东西。\",\"应用层不关心数据传输的细节，传输层会帮我们处理数据传输的细节。\",\"应用层是工作在操作系统的用户态，传输层及以下是工作在操作系统的内核态。\"]},\"165\":{\"title\":\"TCP/IP网络模型\",\"header\":\"传输层\",\"text\":[\"传输层为两台主机上的应用程序提供端到端的通信，例如TCP、UDP等。\",\"传输层有两个协议：TCP和UDP。\",\"TCP提供面向连接的、可靠的数据传输服务，它能够保证数据从一端传到另一端，而且不会丢失，不会乱序，不会重复，而且还能够保证数据的顺序。\",\"UDP提供无连接的、尽最大努力的数据传输服务，它不保证数据传输的可靠性，也就是说，当数据传到另一端时，我们并不能确定数据是否传输成功，也不能确定数据是否乱序，是否重复，是否丢失，也不能确定数据的顺序。\"]},\"166\":{\"title\":\"TCP/IP网络模型\",\"header\":\"TCP段的由来\",\"text\":[\"当应用层需要传递的数据非常大,超过了输出层的数据包大小的时候，这时候就会把数据分成多个小的数据包，每个小的数据包都会被封装成一个TCP段，然后再传输到传输层。\"]},\"167\":{\"title\":\"TCP/IP网络模型\",\"header\":\"网络层\",\"text\":[\"应用层将数据交给传输层，传输层只是为应用层提供了端到端的通信，但是传输层并不知道数据是如何从一端传到另一端的，这就需要网络层来帮助传输层完成这个工作。\",\"网络层使用协议：IP协议。\",\"IP协议定义了一种寻址方式，可以借助子网掩码就可以计算出网络号和主机号。 在寻址过程中，一般都是先匹配网络号，再匹配主机号。 \",\"IPV4：32位寻址方式\",\"IPV6：128位寻址方式\",\"IP协议还定义了一种路由选择协议，可以根据IP地址的不同，选择不同的路由，从而实现数据从一端传到另一端。 在实际生活，两个主机并不是直接通过一条链路相连的，而是通过一些路由器相连的，所以，当数据从一端传到另一端的时候，数据会经过很多的路由器，这就需要路由器来帮助我们选择路由，从而实现数据从一端传到另一端。\",\"路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘。\"]},\"168\":{\"title\":\"TCP/IP网络模型\",\"header\":\"链路层\",\"text\":[\"链路层是网络层的下一层，它的作用是将网络层传下来的IP数据报封装成帧，然后再通过物理层进行传输。\"]},\"169\":{\"title\":\"TCP/IP网络模型\",\"header\":\"物理层\",\"text\":[\"物理层是整个网络模型的最底层，它的作用是将数据从一台主机传输到另一台主机，它传输的单位是比特，也就是0和1。\",\"每一层的封装格式：\"]},\"170\":{\"title\":\"TCP/IP网络模型\",\"customFields\":{\"0\":[\"Network篇\"],\"1\":[\"Network\",\"basic\"]}},\"171\":{\"title\":\"键入网址到页面显示，发生了什么？\",\"header\":\"浏览器解析\",\"text\":[\"浏览器会判断输入的网址是搜索内容还是网址，如果是搜索内容，浏览器会将其转换为https://www.baidu.com/s?wd=搜索内容的形式，然后再发送请求。 这边我们考虑的都是键入网址内容\",\"浏览器会先检查本地缓存中是否有该网址对应的资源，如果有，就直接从缓存中获取资源，如果没有，就发送请求到服务器。\",\"浏览器会解析网址，获取协议、域名、端口号、路径、查询字符串、锚点等信息。\"]},\"172\":{\"title\":\"键入网址到页面显示，发生了什么？\",\"header\":\"DNS解析\",\"text\":[\"浏览器会先检查本地缓存中是否有该网址对应的IP地址，如果有，就直接从缓存中获取，如果没有，就发送请求到DNS服务器。\",\"向DNS发送请求采用的是迭代查询，即先向根域名服务器发送请求，根域名服务器会返回一个IP地址，然后再向该IP地址对应的服务器发送请求，该服务器会返回一个IP地址，然后再向该IP地址对应的服务器发送请求，直到最后返回一个IP地址。\",\"在DNS解析完成以后，就可以获取到目的网络的IP地址，这时候应用层就会生成相应的Http报文，然后从上往下传输到传输层\"]},\"173\":{\"title\":\"键入网址到页面显示，发生了什么？\",\"header\":\"TCP连接\",\"text\":[\"TCP在传输数据之前，要先进行三次握手，建立连接。\",\"双方建立好连接以后，就可以进行数据传输了。如果HTTP请求的消息体较大，TCP会将消息体分成多个数据包，然后在接收端再将其组装起来。\",\"将封装好的数据包传输到网络层。\"]},\"174\":{\"title\":\"键入网址到页面显示，发生了什么？\",\"header\":\"IP协议\",\"text\":[\"IP协议需要将数据封装为数据包，然后发送到数据链路层。\",\"IP协议需要知道源地址IP和目的地址IP，这两个地址都是IP地址，而不是域名。\"]},\"175\":{\"title\":\"键入网址到页面显示，发生了什么？\",\"header\":\"MAC地址\",\"text\":[\"IP头部生成后，还需要在数据链路层生成MAC头部，MAC头部包含源MAC地址和目的MAC地址。\",\"发送方的MAC在网卡生产的时候就已经固定了，而接收方的MAC地址是通过ARP协议获取的。\",\"ARP获取MAC地址的方式，是一种广播的方式，即发送方会向网络中的所有主机发送请求，询问目的主机的MAC地址，然后目的主机会向发送方回复MAC地址。ARP为了提高效率，会有一个缓存\",\"在数据链路层，数据包会被封装为帧吗，帧里面包含了MAC头部和IP头部，然后再发送到物理层。\"]},\"176\":{\"title\":\"键入网址到页面显示，发生了什么？\",\"header\":\"网卡\",\"text\":[\"网卡会将数据包转换为电信号，然后通过网线发送出去，发送到路由器上。也就是说，这才是真正的数据发送过程\"]},\"177\":{\"title\":\"键入网址到页面显示，发生了什么？\",\"header\":\"交换机\",\"text\":[\"交换机的端口因为无法获取到MAC地址，所以会将数据包转发到所有的端口，但是交换机会记录下数据包的源MAC地址和端口号，然后将其存储到MAC地址表中。\",\"所以交换机会根据MAC地址表，将数据包转发到目的主机。\"]},\"178\":{\"title\":\"键入网址到页面显示，发生了什么？\",\"header\":\"路由器\",\"text\":[\"网络包经过交换机转发到路由器上，路由器会根据IP头部的目的IP地址，查找路由表，然后将数据包转发到下一个路由器。\"]},\"179\":{\"title\":\"键入网址到页面显示，发生了什么？\",\"customFields\":{\"0\":[\"Network 篇\"],\"1\":[\"Network\",\"basic\"]}},\"180\":{\"title\":\"项目复盘\",\"customFields\":{\"0\":[\"项目复盘\"],\"1\":[\"项目复盘\",\"soybean admin\"]}},\"181\":{\"title\":\"系统加载\",\"header\":\"场景\",\"text\":[\"在项目中，因为首页的一些数据需要在用户登录后才能获取，所以需要在用户登录后，再加载首页的数据。假如我们在登录成功后，直接跳转到首页，那么首页的数据还未加载，会导致页面显示不全，所以需要在首页加载完成后，再跳转到首页。这时候我们就需要一个系统加载的功能(Loading)。\"]},\"182\":{\"title\":\"系统加载\",\"header\":\"实现\",\"text\":[]},\"183\":{\"title\":\"系统加载\",\"header\":\"1. 使用 createApp 创建了两个 vue 实例\",\"text\":[\"// main.js import { createApp } from \\\"vue\\\"; import App from \\\"./App.vue\\\"; const loading = createApp(App); loading.mount(\\\"#loading\\\"); const app = createApp(App); app.mount(\\\"#app\\\"); // 当`app`组件加载好了之后，就可以销毁`loading`组件了。 loading.unmount(); \",\"先挂载 loading 实例，再挂载 app 实例，这样就可以保证 loading 实例先加载，app 实例后加载。\"]},\"184\":{\"title\":\"系统加载\",\"customFields\":{\"0\":[\"项目复盘\"],\"1\":[\"soybean admin\",\"项目复盘\"]}},\"185\":{\"title\":\"React篇\",\"customFields\":{\"0\":[\"React篇\"]}},\"186\":{\"title\":\"jsx转化过程\",\"header\":\"什么是 jsx？\",\"text\":[\"jsxjsx 可以生成 React 元素，它是 React 的一种语法糖。\"]},\"187\":{\"title\":\"jsx转化过程\",\"header\":\"jsx 转化过程\",\"text\":[]},\"188\":{\"title\":\"jsx转化过程\",\"header\":\"1. 转化为 React 元素\",\"text\":[\"首先jsx会被babel转化成React.createElement的形式(React16),在React17以后,JSX不会将JSX转化为React.createElement的形式,而是直接从React的包中引入JSX的运行时,这样就不需要引入React了,这样就减少了打包的体积。\",\"举一个例子：\",\"<div id=\\\"app\\\" className=\\\"app\\\"> <span>hello</span> <Hello>hello</Hello> </div> \"]},\"189\":{\"title\":\"jsx转化过程\",\"header\":\"在 React16 中，会被转化成：\",\"text\":[\"/*#__PURE__*/ React.createElement( \\\"div\\\", { id: \\\"app\\\", className: \\\"app\\\", }, /*#__PURE__*/ React.createElement(\\\"span\\\", null, \\\"hello\\\"), /*#__PURE__*/ React.createElement(Hello, null, \\\"hello\\\") ); \",\"createElement(type, [props], [...children])\",\"接受三个参数：\",\"type：表示元素的类型，可以是原生的 DOM 元素，也可以是自定义的组件。\",\"props：表示元素的属性，比如 id、className、style 等。\",\"children：表示当前元素的子元素。\",\"返回类型：ReactElement\",\"ReactElement\",\"ReactElement 是 React 元素的类型，它是一个对象，它的结构如下：\",\"const ReactElement = function (type, key, ref, self, source, owner, props) { const element = { // 用于标识这是一个 React 元素 $typeof: REACT_ELEMENT_TYPE, // 用于标识这个元素的类型 type: type, key: key, ref: ref, props: props, // 记录创建这个元素的组件 _owner: owner, }; return element; }; \",\"$typeof：用于标识这是一个 React 元素。他是一个 Symbol 类型的值，值为 Symbol.for('react.element')。\",\"type: 用于标识这个元素的类型，可以是原生的 DOM 元素，也可以是自定义的组件。\",\"ref: 用于标识这个元素的 ref 属性。\",\"props: 用于标识这个元素的属性(class等)。\",\"key: 用于标识这个元素或者组件的 key 属性。\"]},\"190\":{\"title\":\"jsx转化过程\",\"header\":\"在 React17 中，会被转化成：\",\"text\":[\"import { jsx as _jsx } from \\\"react/jsx-runtime\\\"; import { jsxs as _jsxs } from \\\"react/jsx-runtime\\\"; /*#__PURE__*/ _jsxs(\\\"div\\\", { id: \\\"app\\\", className: \\\"app\\\", children: [ /*#__PURE__*/ _jsx(\\\"span\\\", { children: \\\"hello\\\", }), /*#__PURE__*/ _jsx(Hello, { children: \\\"hello\\\", }), ], }); \",\"jsx(type, props, children)\",\"接受三个参数：\",\"type：表示元素的类型，可以是原生的 DOM 元素，也可以是自定义的组件。\",\"props：表示元素的属性，比如 id、className、style 等。\",\"children：表示当前元素的子元素。\",\"返回类型：ReactElement\",\"引申：为什么在 React 老版本中，使用 jsx 语法时，需要引入 React，而在 React17 中，不需要引入 React？\",\"因为在 React16 中，jsx 会被转化成 React.createElement 的形式，而 React.createElement 是一个函数，所以在使用 jsx 语法时，需要引入 React。但是在 React17 中，jsx 会被转化成 React.js 中的 jsx 函数，而 jsx 函数是一个 import 导入的函数，所以不需要引入 React。\"]},\"191\":{\"title\":\"jsx转化过程\",\"header\":\"2. React 元素转化为 Fiber\",\"text\":[\"在ReactElement被创建完以后，它就会被调度器Scheduler接管，Scheduler会将这个ReactElement放到Fiber中。\",\"Filber对应的是React中的Fiber，Fiber是React中的一个核心算法，它是一个链表结构，它的结构如下：\",\"type Fiber = { // 用于标识这个 Fiber 对应的组件 type: any; // 用于标识这个 Fiber 对应的 DOM 元素 key: null | string; // 用于标识这个 Fiber 对应的 DOM 元素 elementType: any; // 用于标识这个 Fiber 对应的 DOM 元素 ref: null | (((handle: any) => void) & { _stringRef: ?string }) | RefObject; // 用于标识这个 Fiber 对应的 DOM 元素 source: null | Source; // 用于标识这个 Fiber 对应的 DOM 元素 return: Fiber | null; // 用于标识这个 Fiber 的子 Fiber child: Fiber | null; // 用于标识这个 Fiber 的兄弟 Fiber sibling: Fiber | null; // 用于标识这个 Fiber 对应的组件的状态 stateNode: any; // 任务优先级 memoizedState: any; // 任务阶段 memoizedProps: any; }; \",\"它对应三种关系：\",\"return：用于标识这个 Fiber 的父 Fiber。\",\"child：用于标识这个 Fiber 的子 Fiber。\",\"siblings：用于标识这个 Fiber 的兄弟 Fiber。\",\"并且Filber中还存在任务优先级属性，用于标识这个任务的优先级，优先级越高，越先执行。\"]},\"192\":{\"title\":\"jsx转化过程\",\"header\":\"3. Fiber 转化为 DOM\",\"text\":[\"在Fiber被创建完以后，它就会被Renderer接管，Renderer会将这个Fiber转化成DOM。\"]},\"193\":{\"title\":\"jsx转化过程\",\"customFields\":{\"0\":[\"React\"],\"1\":[\"React\",\"jsx\"]}},\"194\":{\"title\":\"React Hooks\",\"header\":\"React Hooks\",\"text\":[]},\"195\":{\"title\":\"React Hooks\",\"header\":\"类组件和函数组件\",\"text\":[]},\"196\":{\"title\":\"React Hooks\",\"header\":\"类组件\",\"text\":[\"类组件使用class,类组件时继承React.Component。 类组件具有自己的状态(state),可以在constructor中初始化state,直接使用this.state来进行修改状态。\",\"import React from \\\"react\\\"; class App extends React.Component { constructor(props) { super(props); this.state = { count: 0, }; } render() { return ( <div> <h1>{this.state.count}</h1> <button onClick={() => this.setState({ count: this.state.count + 1 })}> +1 </button> </div> ); } } \"]},\"197\":{\"title\":\"React Hooks\",\"header\":\"函数组件\",\"text\":[\"函数组件是一个函数，函数组件没有自己的状态(state)，函数组件只能接收props，不能修改props。\",\"import React from \\\"react\\\"; function App(props) { return ( <div> <h1>{props.count}</h1> <button onClick={() => props.setCount(props.count + 1)}>+1</button> </div> ); } \"]},\"198\":{\"title\":\"React Hooks\",\"header\":\"类组件和函数组件的区别\",\"text\":[\"类组件有自己的状态(state)，函数组件没有自己的状态(state)。\",\"但是函数组件可以通过useState来使用状态(state)。\",\"类组件有生命周期钩子，函数组件没有生命周期钩子。\",\"但是函数组件可以通过useEffect来模拟生命周期钩子。useEffect其实就可以用来模拟componentDidMount、componentDidUpdate和componentWillUnmount这三个生命周期钩子。\",\"类组件可以使用this关键字，函数组件不能使用this关键字。\"]},\"199\":{\"title\":\"React Hooks\",\"header\":\"Hooks 种类\",\"text\":[]},\"200\":{\"title\":\"React Hooks\",\"header\":\"useState 函数\",\"text\":[\"useState函数可以让我们在函数组件中使用状态对象(this.state)，useState函数接收一个参数，这个参数就是状态对象(this.state)的初始值，useState函数返回一个数组，这个数组的第一个元素就是状态对象(this.state)，第二个元素是一个函数，这个函数可以用来修改状态对象(this.state)。\",\"import React, { useState } from \\\"react\\\"; export default function App() { const [count, setCount] = useState(0); return ( <div> <h1>{count}</h1> <button onClick={() => setCount(count + 1)}>+1</button> </div> ); } \"]},\"201\":{\"title\":\"React Hooks\",\"header\":\"useEffect 函数\",\"text\":[\"useEffect函数可以让我们在函数组件中使用生命周期钩子，useEffect函数接收一个函数作为参数，这个函数就相当于componentDidMount、componentDidUpdate和componentWillUnmount这三个生命周期钩子的集合体，这个函数会在组件初始化渲染之后执行，也会在组件更新之后执行，也会在组件卸载之前执行。\",\"import React, { useState, useEffect } from \\\"react\\\"; export default function App() { const [count, setCount] = useState(0); useEffect(() => { console.log(\\\"组件初始化渲染之后执行\\\"); return () => { console.log(\\\"组件即将被卸载之前执行\\\"); }; }, [count]); // 数组中传入的值，只有在这些值发生改变的时候，才会执行useEffect函数中的函数 return ( <div> <h1>{count}</h1> <button onClick={() => setCount(count + 1)}>+1</button> </div> ); } \",\"react18以后，useEffect会被执行两次，这是为了模拟立即卸载组件和重新挂载组件的情况。\"]},\"202\":{\"title\":\"React Hooks\",\"header\":\"useContext 函数\",\"text\":[\"useContext函数可以让我们在函数组件中使用React的上下文对象。\",\"场景： 有一个父组件，父组件中有一个状态对象(this.state)，父组件中有一个子组件，子组件中需要使用到父组件中的状态对象(this.state)，这个时候就可以使用React的上下文对象来实现。\",\"import React, { useState, useContext } from \\\"react\\\"; // 创建一个上下文对象 const MyContext = React.createContext(); export default function App() { const [count, setCount] = useState(0); return ( <MyContext.Provider value={{ count, setCount }}> <Child /> </MyContext.Provider> ); } function Child() { const { count, setCount } = useContext(MyContext); return ( <div> <h1>{count}</h1> <button onClick={() => setCount(count + 1)}>+1</button> </div> ); } \",\"需要特别注意，常见的上下文，如果不在一个文件里面，那么就需要将这个上下文暴露出去，并且在子组件里面应用，并且访问\",\"useContext进行传递参数和Props父子传参的区别：useContext可以跨越多层组件传递参数，而Props只能在父子组件之间传递参数。\",\"引申：React 之间组件通信的方式有哪些？\",\"参考链接：组件通信方式\"]},\"203\":{\"title\":\"React Hooks\",\"header\":\"useReducer 函数\",\"text\":[\"useReducer函数可以让我们在函数组件中使用Redux的reducer函数。\",\"import React, { useReducer } from \\\"react\\\"; export default function App() { const [count, dispatch] = useReducer((state, action) => { switch (action.type) { case \\\"add\\\": return state + 1; case \\\"sub\\\": return state - 1; default: return state; } }, 0); return ( <div> <h1>{count}</h1> <button onClick={() => dispatch({ type: \\\"add\\\" })}>+1</button> <button onClick={() => dispatch({ type: \\\"sub\\\" })}>-1</button> </div> ); } \"]},\"204\":{\"title\":\"React Hooks\",\"header\":\"useMemo 函数\",\"text\":[\"useMemo函数可以让我们在函数组件中缓存一些数据，这些数据只有在依赖的值发生改变的时候，他才会重新计算。\",\"import React, { useState, useMemo } from \\\"react\\\"; export default function App() { const [count, setCount] = useState(0); const [name, setName] = useState(\\\"张三\\\"); const double = useMemo(() => { console.log(\\\"计算double\\\"); return count * 2; }, [count]); return ( <div> <h1>{count}</h1> <h1>{name}</h1> <h1>{double}</h1> <button onClick={() => setCount(count + 1)}>+1</button> <button onClick={() => setName(\\\"李四\\\")}>改名</button> </div> ); } \",\"我们可以这么理解useMemo和useState的关系：\",\"我们可以将useState设置出来的状态理解为自变量，只要自变量改变(state)，那么视图就会发生变化。\",\"同样的，useMemo用来缓存因变量，只要因变量改变(count)，那么因变量就会重新计算(double)，而double的重新计算，会导致视图的重新渲染。\",\"其实可以将useMemo理解为Vue中的计算属性。\"]},\"205\":{\"title\":\"React Hooks\",\"header\":\"useCallback 函数\",\"text\":[\"useCallback函数可以让我们在函数组件中缓存一些函数，这些函数只有在依赖的值发生改变的时候，他才会重新创建。\",\"import React, { useState, useCallback } from \\\"react\\\"; export default function App() { const [count, setCount] = useState(0); const [name, setName] = useState(\\\"张三\\\"); const handleClick = useCallback(() => { console.log(\\\"handleClick\\\"); }, [count]); return ( <div> <h1>{count}</h1> <h1>{name}</h1> <button onClick={() => setCount(count + 1)}>+1</button> <button onClick={() => setName(\\\"李四\\\")}>改名</button> <button onClick={handleClick}>点击</button> </div> ); } \",\"我们可以这么理解useCallback和useState的关系：\",\"我们可以将useState设置出来的状态理解为自变量，只要自变量改变(state)，那么视图就会发生变化。\",\"同样的，useCallback用来缓存因变量函数，只要因变量改变(count)，那么因变量就会重新创建(handleClick)，而handleClick的重新创建，会导致视图的重新渲染。\",\"其实useCallback函数和useMemo函数的实现原理是一样的，只不过useCallback函数返回的是一个函数，而useMemo函数返回的是一个值。\"]},\"206\":{\"title\":\"React Hooks\",\"header\":\"useRef 函数\",\"text\":[\"useRef函数可以让我们在函数组件创建引用对象，这些数据不会导致视图的重新渲染。\",\"useRef函数它会返回一个refObj对象，这个对象有一个current属性，这个属性可以用来存储数据。 特点：更新 ref 数据，不会导致视图重新渲染\",\"一般我们会将useRef和ref结合使用，来获取DOM元素。\",\"import React, { useState, useRef } from \\\"react\\\"; export default function App() { // 创建ref对象 const inputRef = useRef(); // 获取input输入内容 const changeData = () => { console.log(inputRef.current.value); }; return ( <div> <input type=\\\"text\\\" ref={inputRef} @change=\\\"changeData\\\"/> </div> ); } \",\"useRef 可以用来引用任何类型的对象，React ref 只是一个用于引用 DOM 元素的 DOM 属性\",\"import { useState, useRef } from \\\"react\\\"; export default function Stopwatch() { const [startTime, setStartTime] = useState(null); const [now, setNow] = useState(null); // let timmer = null const timmer = useRef(null); function handleStart() { // 开始计时。 setStartTime(Date.now()); setNow(Date.now()); timmer.current = setInterval(() => { // 每 10ms 更新一次当前时间。 setNow(Date.now()); }, 10); } function handleStop() { clearInterval(timmer.current); // 这时候timmer是undefined，获取不到的，所以需要在外面定义 // timmer在外边定义，确实可以获取到，但是无法清除，因为timmer是一个局部变量，每次执行handleStart的时候，都会重新定义一个timmer，所以无法清除 // 这时候就只能用useRef了 } let secondsPassed = 0; if (startTime != null && now != null) { secondsPassed = (now - startTime) / 1000; } return ( <> <h1>时间过去了： {secondsPassed.toFixed(3)}</h1> <button onClick={handleStart}>开始</button> <button onClick={handleStop}>停止</button> </> ); } \",\"react官网也表达，当你的组件需要保存一些不需要导致视图更新的数据时，可以使用useRef。比如上面的例子，我们需要保存一个定时器，这个定时器不需要导致视图的更新，所以我们可以使用useRef。\"]},\"207\":{\"title\":\"React Hooks\",\"customFields\":{\"0\":[\"React\"],\"1\":[\"React\",\"Hooks\"]}},\"208\":{\"title\":\"React生命周期\",\"header\":\"什么是生命周期\",\"text\":[\"生命周期是组件从实例化到销毁的过程，也就是组件从生成到消亡的过程，这个过程中会伴随着一些事件，这些事件就是生命周期函数。\",\"生命周期分为三个状态：挂载(Mounting)、更新(Updating)、卸载(Unmounting)。\",\"组件的生命周期分为三个阶段：\",\"render阶段：从组件实例化到组件渲染完成的过程,用于计算当前的状态/更新信息，会根据产生的任务的优先级来决定是否执行，安排任务的调度\",\"pre-commit阶段：从组件开始渲染到组件渲染完成的过程\",\"commit阶段：从组件渲染完成到组件卸载的过程\",\"但是在React17之后，render阶段和pre-commit阶段合并为一个阶段，也就是说React17之后只有两个阶段：render阶段和commit阶段。\",\"因为react在 16.3 版本之后，推出了Fiber架构，Fiber架构的目的是为了解决react在渲染过程中，如果渲染任务过多，会造成页面卡顿，用户体验不好的问题，所以Fiber架构的目的就是为了解决这个问题，Fiber架构的核心就是render阶段和commit阶段的分离，render阶段负责计算任务，commit阶段负责执行任务，这样就可以根据任务的优先级来安排任务的调度，从而解决了react在渲染过程中，导致页面卡顿的问题。这就带来了一些生命周期钩子被废弃。\"]},\"209\":{\"title\":\"React生命周期\",\"header\":\"生命周期的分类\",\"text\":[]},\"210\":{\"title\":\"React生命周期\",\"header\":\"16.3 版本之前的生命周期\",\"text\":[]},\"211\":{\"title\":\"React生命周期\",\"header\":\"挂载阶段\",\"text\":[\"constructor：构造函数，最先被执行，我们通常在构造函数里初始化组件的状态对象(this.state)或者给自定义方法绑定this。\",\"componentWillMount：组件即将被挂载到页面上之前执行，也就是在组件即将被渲染到页面之前执行，此时可以修改组件的状态对象(this.state)，这个方法在服务端渲染中也会被调用。\",\"render: 渲染函数，它是一个纯函数，只负责渲染组件。它具有以下特性： \",\"不能修改组件的状态对象(this.state)，可能会导致组件一直被重新渲染。\",\"不能和浏览器进行交互，不能获取 DOM 元素。\",\"只能通过this.props和this.state来获取数据。\",\"只能返回一个顶级元素，不能返回多个顶级元素。\",\"componentDidMount(preProps,preState)：组件已经被挂载到页面上之后执行，也就是在组件已经被渲染到页面之后执行，此时可以获取到真实的 DOM 元素。它具有以下特性： \",\"最早可以获取到真实 DOM 元素的钩子。\"]},\"212\":{\"title\":\"React生命周期\",\"header\":\"更新阶段\",\"text\":[\"componentWillReceiveProps(nextProps)：组件即将接收到新的props之前执行，也就是说，当一个组件从父组件接收到新的props之前执行，此时可以根据新的props来修改组件的状态对象(this.state)。 特性：\",\"在组件初始化渲染的时候不会执行，父组件被重新渲染(state发生变化)，这个方法也会被执行，即使父组件传递给子组件的props没有发生改变，这个方法也会被执行。\",\"在这个钩子里面可以最早拿到新的props(父组件传递给子组件)，但是不能获取到组件之前的props。\",\"shouldComponentUpdate(nextProps,nextState)：组件是否要被更新，也就是说，当一个组件接收到新的props或者state之后，shouldComponentUpdate会在组件重新渲染之前执行，此时我们可以根据新的props或者state来判断组件是否需要重新渲染，默认返回true，如果返回false，那么这个组件就不会被重新渲染，这个生命周期函数主要用于性能优化。\",\"我们可以使用Json.stringify()来比较两个对象(this.state和nextState)是否相等，如果两个对象相等，那么就返回false，如果两个对象不相等，那么就返回true。\",\"componentWillUpdate(nextProps,nextState)：组件即将被更新之前执行，也就是说，当一个组件要被重新渲染之前执行，此时可以根据新的props或者state来修改组件的状态对象(this.state)。\",\"componentDidUpdate(preProps,preState)：组件已经被更新之后执行，也就是说，当一个组件被重新渲染之后执行，此时可以获取到真实的 DOM 元素，比如：获取到真实的 DOM元素之后，可以使用第三方库来操作这个 DOM 元素。\"]},\"213\":{\"title\":\"React生命周期\",\"header\":\"卸载阶段\",\"text\":[\"componentWillUnmount：组件即将被卸载之前执行，也就是说，当一个组件从页面上被移除之前执行，此时可以做一些清理工作，比如：清除定时器、取消网络请求、清除组件中的缓存等。\",\"但是上面的生命周期都是在react16.3之前的生命周期，react16.3之后的生命周期有所改变，react16.3之后的生命周期有以下几个：\"]},\"214\":{\"title\":\"React生命周期\",\"header\":\"16.3 版本之后的生命周期\",\"text\":[]},\"215\":{\"title\":\"React生命周期\",\"header\":\"挂载阶段\",\"text\":[\"constructor：构造函数，最先被执行，我们通常在构造函数里初始化组件的状态对象(this.state)或者给自定义方法绑定this。\",\"static getDerivedStateFromProps(props, state)：这是一个静态方法，也就是说，这个方法不能访问到组件实例(this)，这个方法在组件实例化之后和接收到新的props之后执行，这个方法的返回值会被添加到组件的状态对象(this.state)中,用于性能优化。\",\"简单来说，这个方法的作用就是根据新的props来更新组件的状态对象(this.state)，这个方法的返回值会被添加到组件的状态对象(this.state)中，如果返回null，则不会更新组件的状态对象(this.state)，就是将return到的对象替换当前的state。\",\"他在第一次渲染的时候被调用，以后每次接收到新的props之后都会被调用。\",\"render: 渲染函数，它是一个纯函数，只负责渲染组件。他和react16.3之前的render函数没有什么区别。\"]},\"216\":{\"title\":\"React生命周期\",\"header\":\"更新阶段\",\"text\":[\"getSnapshotBeforeUpdate(preProps,preState):这个方法在组件更新之前执行，此时可以获取到最新的 DOM 数据，在这个方法中返回的任何值都会作为参数传递给componentDidUpdate的第三个参数。\",\"简单来说，这个方法的作用就是在组件更新之前获取到最新的 DOM 数据，然后在componentDidUpdate中获取到这个方法的返回值。\",\"这个方法的返回值会作为参数传递给componentDidUpdate的第三个参数。\",\"这个方法在组件初始化渲染的时候不会被调用，只有在组件更新的时候才会被调用。\",\"shouldComponentUpdate(nextProps,nextState)：组件是否要被更新,用于性能优化。和react16.3之前的shouldComponentUpdate没有什么区别。\",\"componentDidUpdate(preProps,preState,snapshot)：组件已经被更新之后执行，也就是说，当一个组件被重新渲染之后执行，此时可以获取到真实的 DOM 元素。也可以在这个钩子里面根据preProps和preState来做一些性能优化。但是如果你要在这个钩子里面使用this.setState来修改状态的话，必须要有一个条件限制（判断 props），否则会导致组件陷入死循环。\"]},\"217\":{\"title\":\"React生命周期\",\"header\":\"卸载阶段\",\"text\":[\"componentWillUnmount：组件即将被卸载之前执行，也就是说，当一个组件从页面上被移除之前执行，此时可以做一些清理工作，比如：清除定时器、取消网络请求、清除组件中的缓存等。\",\"上述介绍的所有生命周期钩子，都是借助React的class组件来实现的，但是在React16.8之后，新增了一个hook函数，可以让我们在不使用class组件的情况下使用生命周期钩子。\"]},\"218\":{\"title\":\"React生命周期\",\"header\":\"hook 函数\",\"text\":[\"hook函数是React16.8之后新增的一个函数，可以让我们在不使用class组件的情况下使用生命周期钩子。\",\"其实严格来说，hook函数并不是生命周期钩子，它只是模拟了生命周期钩子的功能，因为，生命周期函数都是react.component的方法，函数组件并没有继承，所以也不会拥有\",\"useEffect: 这个函数的作用就相当于componentDidMount、componentDidUpdate和componentWillUnmount这三个生命周期函数的集合。\",\"import React, { useState, useEffect } from \\\"react\\\"; function App() { const [count, setCount] = useState(0); useEffect(() => { console.log(\\\"组件挂载完成\\\"); return () => { console.log(\\\"组件即将被卸载\\\"); }; }, []); return ( <div> <p>你点击了{count}次</p> <button onClick={() => setCount(count + 1)}>点击</button> </div> ); } \"]},\"219\":{\"title\":\"React生命周期\",\"customFields\":{\"0\":[\"React\"],\"1\":[\"生命周期\"]}},\"220\":{\"title\":\"react组件通信方式\",\"header\":\"父子组件通信\",\"text\":[]},\"221\":{\"title\":\"react组件通信方式\",\"header\":\"父传子\",\"text\":[\"使用场景: 子组件需要使用父组件的参数，这个时候我们就需要使用到父传子的方式，传递参数给子组件。一般都是使用 Props\",\"// 父组件 import React, { Component } from \\\"react\\\"; function Child(props) { console.log(props); // {name: \\\"summer\\\",children: \\\"hello,summer\\\"} return <div>{props.name}</div>; } export default function Parent() { return <Child name=\\\"summer\\\">hello,summer</Child>; } \",\"当然我们通过props不仅只能获取到参数，其实对于函数组件来说，props就是一个对象，我们可以通过props.children获取到子组件(文本或者是节点)。\"]},\"222\":{\"title\":\"react组件通信方式\",\"header\":\"子传父\",\"text\":[\"使用场景： 在子组件可能会需要修改父组件传递过来的参数，但是我们是无法直接修改 props 的，这个时候我们就需要使用到子传父的方式，通过回调函数的方式，将子组件的参数传递给父组件，然后在父组件内部修改参数。\",\"// 子组件 import React from \\\"react\\\"; export default function Child(props) { return ( <div> <button onClick={() => props.changeName(\\\"summer\\\")}>修改父组件的name</button> </div> ); } // 父组件 import React, { Component } from \\\"react\\\"; import Child from \\\"./Child\\\"; export default function Parent() { const [name, setName] = useState(\\\"summer\\\"); const changeName = (name) => { setName(name); }; return ( <div> <Child changeName={changeName} /> <div>{name}</div> </div> ); } \",\"这时候姐可以在子组件内部通过props.changeName修改父组件的 name 了。\",\"引申：传递给事件处理函数的函数，应该是直接传递的，而不是调用\",\"// 错误 <button onClick={props.changeName(\\\"summer\\\")}>修改父组件的name</button> // 这个就是直接在调用它，而不是传递给onClick // 这样只要每次渲染子组件，都会调用changeName函数，导致无限循环 // 正确 <button onClick={() => props.changeName(\\\"summer\\\")}>修改父组件的name</button> \",\"具体参考： 响应事件\",\"总结来说：事件名要么就只写时间名字，如果需要加参数(chengName(name)这种，就需要用箭头函数包裹)\",\"父子组件通信\"]},\"223\":{\"title\":\"react组件通信方式\",\"header\":\"兄弟组件通信\",\"text\":[\"一般我们会使用变量提升\",\"Q:什么是变量提升呢？ A:其实就是,如果不借助任何外力，兄弟组件是无法通信的，但是如果我们把兄弟组件的数据提升到父组件，那么兄弟组件就可以通过父组件来通信了。\",\"// 父组件 import React, { Component } from \\\"react\\\"; import Child1 from \\\"./Child1\\\"; import Child2 from \\\"./Child2\\\"; export default function Parent() { const [name, setName] = useState(\\\"summer\\\"); const changeName = (name) => { setName(name); }; return ( <div> <Child1 name={name} /> <Child2 changeName={changeName} /> </div> ); } // 子组件1 import React from \\\"react\\\"; export default function Child1(props) { return <div>{props.name}</div>; } // 子组件2 import React from \\\"react\\\"; export default function Child2(props) { return ( <div> <button onClick={() => props.changeName(\\\"alex\\\")}>修改父组件的name</button> </div> ); } \",\"在兄弟组件通信中，如果你使用的是利用变量提升的方式\",\"那么你的组件的层级是不能太深的，因为如果层级太深，那么你就需要一层一层的传递参数，这样就会导致代码的可读性变差。\",\"兄弟组件需要用到的参数，都需要提升到父组件，这样会导致父组件的参数变多，也会导致父组件的可读性变差。\",\"兄弟组件通信\"]},\"224\":{\"title\":\"react组件通信方式\",\"header\":\"跨级组件通信\",\"text\":[\"正如上面所说的，要想实现跨级的组件通信，我们就需要使用到变量提升的方式，将参数提升到父组件，然后再通过父组件来传递参数，但是这样会带来很多问题，比如说：父组件的状态会非常多以及组件的层级会非常深，这样会导致代码的可读性变差,这时候我们需要使用Context来解决这个问题。\"]},\"225\":{\"title\":\"react组件通信方式\",\"header\":\"Context\",\"text\":[\"Context是 React 提供的一种跨组件传递参数的方式，它可以让我们在不需要一层一层的传递参数的情况下，就可以实现跨组件传递参数。\",\"Context的使用分为三步：\",\"创建 Context\",\"const MyContext = React.createContext(); \",\"如果创建的 Context,子组件获取不到，这时候需要暴露\",\"使用 Context.Provider 组件包裹需要传递参数的组件\",\"<MyContext.Provider value={contextValue}> <Child /> </MyContext.Provider> \",\"在需要使用参数的组件中，使用 Context.Consumer 组件来获取参数\",\"let contextValue = React.useContext(MyContext); \",\"任意组件通信\"]},\"226\":{\"title\":\"react组件通信方式\",\"header\":\"任意组件通信\",\"text\":[\"我可以使用redux实现任意组件通信\",\"引申： Redux 是什么？\"]},\"227\":{\"title\":\"react组件通信方式\",\"customFields\":{\"0\":[\"React\"],\"1\":[\"React\",\"组件通信\"]}},\"228\":{\"title\":\"受控组件和非受控组件\",\"header\":\"受控组件\",\"text\":[\"受控组件是指表单数据由 React 组件来管理的组件。表单元素的值被 React 的 state 所控制，React 的 state 是唯一数据源，所以 React 的 state 变化时，表单元素的值也会跟着变化。由于表单元素的值由 React 的 state 所控制，所以我们称这种组件为受控组件。\",\"简单来说，受控组件就是表单数据被 React 组件所控制的组件。数据使用State或者Redux来管理。\",\"export default function App() { const [name, setName] = useState(\\\"summer\\\"); return ( <div> <input value={name} onChange={(e) => setName(e.target.value)} /> </div> ); } \"]},\"229\":{\"title\":\"受控组件和非受控组件\",\"header\":\"非受控组件\",\"text\":[\"非受控组件是指表单数据由 DOM 元素本身来管理的组件。表单元素的值被 DOM 元素本身所控制，React 的 state 并不参与管理。由于表单元素的值由 DOM 元素本身所控制，所以我们称这种组件为非受控组件。\",\"简单来说，就是这个表单数据不受React的state控制，使用的ref从DOM中获取元素的值。\",\"export default function App() { const inputRef = useRef(null); const handleClick = () => { console.log(inputRef.current.value); }; return ( <div> <input ref={inputRef} /> <button onClick={handleClick}>获取</button> </div> ); } \"]},\"230\":{\"title\":\"受控组件和非受控组件\",\"customFields\":{\"0\":[\"React\"],\"1\":[\"React\",\"状态\"]}},\"231\":{\"title\":\"场景题\",\"customFields\":{\"0\":[\"场景题\"]}},\"232\":{\"title\":\"记录上次浏览的位置\",\"header\":\"场景\",\"text\":[\"Question：打开一个页面浏览后，关闭页面，再次打开页面时，能够记录上次浏览的位置。\"]},\"233\":{\"title\":\"记录上次浏览的位置\",\"header\":\"解决方案\",\"text\":[]},\"234\":{\"title\":\"记录上次浏览的位置\",\"header\":\"方案一：使用 localStorage\",\"text\":[\"利用localStorage来记录上次浏览的位置，当再次打开页面时，从localStorage中读取上次浏览的位置，然后跳转到该位置。\",\"// 读取上次浏览的位置 const lastScrollTop = localStorage.getItem(\\\"lastScrollTop\\\"); // 跳转到上次浏览的位置 window.scrollTo(0, lastScrollTop); // 监听滚动事件，记录滚动位置 window.addEventListener(\\\"scroll\\\", () => { localStorage.setItem(\\\"lastScrollTop\\\", window.scrollY); }); \",\"我们主要利用的就是window.scrollTo和window.scrollY这两个方法，window.scrollTo可以跳转到指定位置，window.scrollY可以获取当前滚动的位置(文档从顶部开始滚动的像素值)。\",\"在React中，我们可以使用useEffect来监听滚动事件，记录滚动位置。\",\"import React, { useEffect, useRef } from \\\"react\\\"; const Post = () => { const scrollRef = useRef(null); // 读取上次浏览的位置 useEffect(() => { const scrollPosition = localStorage.getItem(\\\"scrollPosition\\\"); // 跳转到上次浏览的位置 if (scrollPosition) { window.scrollTo(0, scrollPosition); } }, []); // 组件将要销毁时，监听滚动事件，记录滚动位置 useEffect(() => { return () => { localStorage.setItem(\\\"scrollPosition\\\", window.scrollY); }; }, []); return ( <div ref={scrollRef}> <h1>Post</h1> <p>Content...</p> </div> ); }; \"]},\"235\":{\"title\":\"记录上次浏览的位置\",\"header\":\"方案二：使用路由参数\",\"text\":[\"利用路由参数来记录上次浏览的位置，当再次打开页面时，从路由参数中读取上次浏览的位置，然后跳转到该位置。\",\"// 从路由中获取到上次浏览的位置 const lastScrollTop = this.$route.query.lastScrollTop; // 跳转到上次浏览的位置 window.scrollTo(0, lastScrollTop); // 监听滚动事件，记录滚动位置 window.addEventListener(\\\"scroll\\\", () => { this.$router.replace({ query: { lastScrollTop: window.scrollY, }, }); }); \",\"假如在React项目中，我们可以使用useParams来获取路由参数，然后利用useEffect来监听滚动事件，记录滚动位置。\",\"import React, { useEffect, useRef } from \\\"react\\\"; import { useParams } from \\\"react-router-dom\\\"; const Post = () => { const { id } = useParams(); const scrollRef = useRef(null); useEffect(() => { const scrollPosition = localStorage.getItem(`scrollPosition-${id}`); if (scrollPosition) { scrollRef.current.scrollTo(0, scrollPosition); } }, [id]); useEffect(() => { return () => { localStorage.setItem(`scrollPosition-${id}`, scrollRef.current.scrollTop); }; }, [id]); return ( <div ref={scrollRef}> <h1>Post {id}</h1> <p>Content...</p> </div> ); }; export default Post; \",\"代码逻辑：\",\"首先，我们使用useParams来获取路由参数id，然后使用useRef来获取div元素的引用。\",\"然后，我们使用useEffect来监听路由参数id的变化，当路由参数id发生变化时，我们就从localStorage中读取上次浏览的位置，然后跳转到该位置。\",\"最后，我们使用useEffect来监听滚动事件，当滚动事件触发时，我们就将滚动位置记录到localStorage中。\"]},\"236\":{\"title\":\"记录上次浏览的位置\",\"customFields\":{\"0\":[\"场景题\"],\"1\":[\"场景题\",\"项目\"]}},\"237\":{\"title\":\"首屏加载慢\",\"header\":\"场景\",\"text\":[\"Question：首页有很多文章数目，每篇文章都有很多内容，当用户打开首页时，会加载所有文章，导致首页加载很慢，用户体验不好。如何优化首页加载速度？\"]},\"238\":{\"title\":\"首屏加载慢\",\"header\":\"解决方案\",\"text\":[]},\"239\":{\"title\":\"首屏加载慢\",\"header\":\"方案一：分页加载\",\"text\":[\"对于数据，我们采用分批次加载的方式，每次加载一定数量的数据，当用户滚动到页面底部时，再加载下一批数据。\",\"// 当用户滚动到页面底部时，加载下一批数据 window.addEventListener(\\\"scroll\\\", () => { if (window.scrollY + window.innerHeight >= document.body.scrollHeight) { // 加载下一批数据 } }); \",\"这边我们来解释一下window.scrollY、window.innerHeight和document.body.scrollHeight这三个属性的含义：\",\"window.scrollY：文档从顶部开始滚动的像素值,就是滚动条滚动的距离。\",\"window.innerHeight：浏览器窗口的视口（viewport）高度。（100vh）\",\"document.body.scrollHeight：文档的高度。（文档的高度 = 视口高度 + 滚动条滚动的距离）\",\"我们将window.scrollY和window.innerHeight相加，就可以得到滚动条滚动到底部时，文档的高度，当这个值等于document.body.scrollHeight时，就说明滚动条滚动到底部了。\",\"我们这个其实也可以使用IntersectionObserver来实现，当用户滚动到页面底部时，加载下一批数据。\",\"const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting) { // 加载下一批数据 } }); observer.observe(document.querySelector(\\\"#loadMore\\\")); \"]},\"240\":{\"title\":\"首屏加载慢\",\"header\":\"方案二：图片懒加载\",\"text\":[\"对于图片，我们采用懒加载的方式，当用户滚动到图片位置时，再加载图片。\",\"// 当用户滚动到图片位置时，加载图片 window.addEventListener(\\\"scroll\\\", () => { const images = document.querySelectorAll(\\\"img\\\"); images.forEach((image) => { if (image.offsetTop < window.scrollY + window.innerHeight) { // 加载图片 } }); }); \",\"在React中，我们可以借助React.lazy和Suspense来实现图片懒加载。\",\"import React, { Suspense } from \\\"react\\\"; // LazyImage组件会被动态加载 const LazyImage = React.lazy(() => import(\\\"./LazyImage\\\")); const App = () => { return ( <Suspense fallback={<div>Loading...</div>}> <LazyImage /> </Suspense> ); }; \",\"当然你也可以使用IntersectionObserver来实现图片懒加载。 IntersectionObserver是浏览器提供的一个API，可以用来监听元素是否进入可视区域。\",\"const images = document.querySelectorAll(\\\"img\\\"); // 为什么是entries，因为可能同时监听多个元素,监听到的元素会放到entries数组中 const observer = new IntersectionObserver((entries) => { entries.forEach((entry) => { if (entry.isIntersecting) { // 加载图片 } }); }); images.forEach((image) => { // 监听，图片列表中的图片，是不是进入可视区域，进入可视区域就会触发回调函数 observer.observe(image); }); \"]},\"241\":{\"title\":\"首屏加载慢\",\"header\":\"方案三：前端缓存\",\"text\":[\"对于静态资源，我们可以利用浏览器的缓存机制，将静态资源缓存到浏览器中，当用户再次访问时，直接从缓存中读取，不需要再次请求服务器。 将一些幂等性的请求数据缓存到浏览器中，当用户再次访问时，直接从缓存中读取，不需要再次请求服务器。\"]},\"242\":{\"title\":\"首屏加载慢\",\"header\":\"方案四：虚拟列表\",\"text\":[\"对于文章列表，我们可以采用虚拟列表的方式，只渲染可视区域的文章，当用户滚动时，再渲染可视区域的文章。\",\"// 当用户滚动时，渲染可视区域的文章 window.addEventListener(\\\"scroll\\\", () => { const articles = document.querySelectorAll(\\\"article\\\"); articles.forEach((article) => { // 当文章在可视区域时，渲染文章 if (article.offsetTop < window.scrollY + window.innerHeight) { // 渲染文章 } }); }); \",\"在React中，我们可以借助react-window来实现虚拟列表。\",\"import React from \\\"react\\\"; import { FixedSizeList as List } from \\\"react-window\\\"; const App = () => { return ( <List height={window.innerHeight} // 列表可视区域的高度 itemCount={1000} // 列表项的数量 itemSize={35} // 列表项的高度 width={300} // 列表可视区域的宽度 > {({ index, style }) => <div style={style}>Row {index}</div>} </List> ); }; \"]},\"243\":{\"title\":\"首屏加载慢\",\"header\":\"方案五：骨架屏\",\"text\":[\"对于文章列表，我们可以采用骨架屏的方式，先渲染骨架屏，当文章加载完成后，再渲染文章。\",\"其实我们可以设置一个loading状态，当文章加载完成后，再将loading状态设置为false，这样就可以实现骨架屏的效果。\",\"import React, { useState, useEffect } from \\\"react\\\"; const App = () => { const [loading, setLoading] = useState(true); const [articles, setArticles] = useState([]); useEffect(() => { fetchArticles().then((articles) => { setArticles(articles); setLoading(false); }); }, []); return ( <div> {loading ? ( <div>loading...</div> ) : ( <ul> {articles.map((article) => ( <li>{article.title}</li> ))} </ul> )} </div> ); }; \"]},\"244\":{\"title\":\"首屏加载慢\",\"customFields\":{\"0\":[\"场景题\"],\"1\":[\"首屏加载慢\",\"性能优化\"]}},\"245\":{\"title\":\"TypeScript篇\",\"customFields\":{\"0\":[\"TypeScript篇\"]}},\"246\":{\"title\":\"泛型理解\",\"header\":\"什么是泛型\",\"text\":[\"泛型就是在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。\",\"我们可以这么理解，TS的泛型使得TS,更加像一个面向对象的语言，因为我们可以在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型。\",\"而且泛型帮助我们在代码编译的时候就知道我们传入的参数类型，从而提前发现错误。\"]},\"247\":{\"title\":\"泛型理解\",\"header\":\"泛型使用方式\",\"text\":[\"泛型分类为：泛型函数、泛型接口、泛型类\"]},\"248\":{\"title\":\"泛型理解\",\"header\":\"泛型函数\",\"text\":[\"应用场景： 有时候我们定义的函数，需要传入的参数和返回的参数是一致的，这时候我们就可以使用泛型来解决这个问题。\",\"function fn<T>(arg: T): T { return arg; } \"]},\"249\":{\"title\":\"泛型理解\",\"header\":\"泛型接口\",\"text\":[\"interface IBase<T, U> { name: T; age: T; sex: U; } \"]},\"250\":{\"title\":\"泛型理解\",\"header\":\"泛型类\",\"text\":[\"class Base<T> { name: T; age: T; constructor(name: T, age: T) { this.name = name; this.age = age; } } \"]},\"251\":{\"title\":\"泛型理解\",\"header\":\"泛型约束\",\"text\":[\"泛型约束就是指定泛型的类型，这样我们就可以在函数内部使用泛型的属性和方法了。\",\"interface IBase { length: number; } function fn<T extends IBase>(arg: T): T { console.log(arg.length); return arg; } \"]},\"252\":{\"title\":\"泛型理解\",\"header\":\"泛型别名\",\"text\":[\"泛型别名就是给泛型起一个别名，这样我们就可以在别的地方使用这个别名了。\",\"type IBase<T> = { name: T; age: T; }; function fn<T>(arg: IBase<T>): IBase<T> { return arg; } \",\"泛型约束和泛型别名的区别：\",\"泛型约束：\",\"约束泛型的类型，这样我们就可以在函数内部使用泛型的属性和方法了\",\"语法：<T extends IBase>，一般需要使用extends\",\"泛型别名：\",\"给泛型起一个别名，这样我们就可以在别的地方使用这个别名了。\",\"语法：arg: IBase<T>，一般不需要使用extends\",\"泛型约束是为了更加安全的访问属性或者方法(保证了这个对象必须存在某个属性或者方法)，但是泛型别名，是为了更好的复用\"]},\"253\":{\"title\":\"泛型理解\",\"header\":\"索引类型\",\"text\":[\"索引类型是指我们可以通过索引的方式访问对象的属性，Keyof T将传入的对象的属性名联合成一个联合类型。\",\"interface IBase { name: string; age: number; } function fn<T extends keyof IBase>(arg: T): T { return arg; } \"]},\"254\":{\"title\":\"泛型理解\",\"customFields\":{\"0\":[\"TypeScript\"],\"1\":[\"泛型\"]}},\"255\":{\"title\":\"Vue篇\",\"customFields\":{\"0\":[\"Vue篇\"]}},\"256\":{\"title\":\"v-show vs v-if\",\"header\":\"相同点\",\"text\":[\"都能够达到控制元素显示隐藏的效果\",\"<template> <div> <div v-show=\\\"isShow\\\">v-show</div> <div v-if=\\\"isShow\\\">v-if</div> </div> </template> \"]},\"257\":{\"title\":\"v-show vs v-if\",\"header\":\"不同点\",\"text\":[\"但是他们达到效果的方式不同\"]},\"258\":{\"title\":\"v-show vs v-if\",\"header\":\"方式\",\"text\":[\"v-show 是通过控制元素的 display 属性来实现的\",\"假如 isShow 为 false，那么 v-show 会将元素的 display 属性设置为 none\",\"假如isShow 为 true，那么 v-show 会将元素的 display 属性设置为 block\",\"v-if 是通过控制元素的 DOM 结构来实现的\",\"假如 isShow 为 false，那么 v-if 会将元素从 DOM 结构中移除\",\"假如 isShow 为 true，那么 v-if 会将元素添加到 DOM 结构中\",\"同样的当DOM结构中的元素被移除后，那么该元素的事件监听器也会被移除\"]},\"259\":{\"title\":\"v-show vs v-if\",\"header\":\"编译过程\",\"text\":[\"v-show: 在编译过程中，会在元素上添加一个 style 属性，用来控制元素的 display 属性,只涉及CSS的变化，不会涉及到DOM结构的变化\",\"v-if：在编译过程中，会在元素上添加一个 ifConditions 属性，用来控制元素的 DOM 结构，涉及到DOM结构的变化\"]},\"260\":{\"title\":\"v-show vs v-if\",\"header\":\"触发生命周期\",\"text\":[\"v-show: 不会触发任何生命周期，因为只涉及到CSS的变化，不会涉及到DOM结构的变化\",\"v-if: 会触发元素的生命周期，因为涉及到DOM结构的变化 \",\"当isShow从false变为true时，会触发元素的beforeCreate、created、beforeMount、mounted生命周期\",\"当isShow从true变为false时，会触发元素的beforeUnmount、unmounted生命周期\"]},\"261\":{\"title\":\"v-show vs v-if\",\"header\":\"性能\",\"text\":[\"v-show: 由于只涉及到CSS的变化，所以性能比较好\",\"v-if: 由于涉及到DOM结构的变化，所以性能比较差\"]},\"262\":{\"title\":\"v-show vs v-if\",\"customFields\":{\"0\":[\"Vue\"],\"1\":[\"v-show\",\"v-if\"]}},\"263\":{\"title\":\"生命周期\",\"header\":\"Vue2\",\"text\":[\"生命周期包括：创建前后，挂载前后，更新前后，销毁前后\"]},\"264\":{\"title\":\"生命周期\",\"header\":\"创建前后\",\"text\":[\"beforeCreate: 在实例初始化之后，数据观测和事件配置之前被调用 \",\"在这个阶段，实例的属性和方法的运算都不能访问到data、props、computed、watch上的数据和方法，因为这些数据和方法都还没有初始化\",\"一般我们会进行一些全局的配置，例如Vue-router、Vuex、axios等\",\"Created: 在实例创建完成后被立即调用 \",\"在这个阶段已经完成init Option的初始化，此时我们可以访问到data、props、computed、watch上的数据和方法，建议在这个时候进行一些 fetch 数据操作\",\"在这个阶段，不能进行DOM操作，因为还没有进行模板编译(compile)，所以DOM还没有挂载，如果需要进行DOM操作，可以在mounted中进行\"]},\"265\":{\"title\":\"生命周期\",\"header\":\"挂载前后\",\"text\":[\"beforeMount: 在挂载开始之前被调用，相关的render函数首次被调用\",\"mounted: 在挂载完成后被调用，此时DOM节点已经生成，$el属性可以访问 \",\"在这个钩子里，我们可以进行一些DOM操作，例如获取DOM、操作DOM、获取DOM的尺寸等，但是这些操作最好放在nextTick中，因为这个时候DOM并不是一定渲染完成了，所以如果直接操作DOM，可能会出现问题\"]},\"266\":{\"title\":\"生命周期\",\"header\":\"更新前后\",\"text\":[\"beforeUpdate: 在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在这个钩子中进一步地更改状态，不会触发附加的重渲染过程\",\"updated: 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后被调用，调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作，但是注意不要在这个钩子函数中操作数据，这可能会导致无限循环的更新，如果需要修改数据，可以使用watch监听数据的变化，然后在watch中修改数据\"]},\"267\":{\"title\":\"生命周期\",\"header\":\"销毁前后\",\"text\":[\"beforeDestroy: 在实例销毁之前调用，实例仍然完全可用\",\"destroyed: 在实例销毁之后调用，调用后，所有的事件监听器会被移除，所有的子实例也会被销毁\"]},\"268\":{\"title\":\"生命周期\",\"header\":\"其他\",\"text\":[\"activated: 在组件章节被激活时调用，这里的激活指的是keep-alive中组件被激活时调用\",\"devtivated: 在组件章节被移除时调用，这里的移除指的是keep-alive中组件被移除时调用\",\"errorCaptured: 当捕获一个来自子孙组件的错误时被调用，此时，错误可以被阻止向上传播\"]},\"269\":{\"title\":\"生命周期\",\"header\":\"Vue3\",\"text\":[\"生命周期其实并没有特别大的变化\"]},\"270\":{\"title\":\"生命周期\",\"header\":\"创建前后\",\"text\":[\"setup: 在组件实例创建之后，但是在组件实例创建之前被调用，此时，props和context都已经解析完成，但是setup中的props属性是reactive的，而不是ref的，所以不能直接使用props，而是需要使用toRefs将其转换为ref的形式 \",\"我们可以认为setup是beforeCreate和created的结合体\"]},\"271\":{\"title\":\"生命周期\",\"header\":\"挂载前后\",\"text\":[\"onBeforeMount: 在挂载开始之前被调用，相关的render函数首次被调用\",\"mounted: 在挂载完成后被调用，此时DOM节点已经生成，$el属性可以访问\"]},\"272\":{\"title\":\"生命周期\",\"header\":\"更新前后\",\"text\":[\"onBeforeUpdate: 在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在这个钩子中进一步地更改状态，不会触发附加的重渲染过程\",\"updated: 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后被调用，调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作，但是注意不要在这个钩子函数中操作数据，这可能会导致无限循环的更新，如果需要修改数据，可以使用watch监听数据的变化，然后在watch中修改数据\"]},\"273\":{\"title\":\"生命周期\",\"header\":\"销毁前后\",\"text\":[\"onBeforeUnmount: 在实例销毁之前调用，实例仍然完全可用\",\"unmounted: 在实例销毁之后调用，调用后，所有的事件监听器会被移除，所有的子实例也会被销毁\"]},\"274\":{\"title\":\"生命周期\",\"header\":\"其他\",\"text\":[\"onActivated: 在组件章节被激活时调用，这里的激活指的是keep-alive中组件被激活时调用\",\"deactivated: 在组件章节被移除时调用，这里的移除指的是keep-alive中组件被移除时调用\",\"这边附上 vue 的生命周期图\",\"vue生命周期图\"]},\"275\":{\"title\":\"生命周期\",\"header\":\"引申 1： keep-alive 的是什么？\",\"text\":[\"定义：keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染，keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们，可以通过include和exclude属性来指定缓存哪些组件，哪些组件不缓存，keep-alive是惰性的，只有在组件切换时才会触发activated和deactivated这两个生命周期钩子函数\",\"例子：\",\"keep-alive可以接受三个属性(只能三选一)：\",\"include: 字符串或正则表达式，只有匹配的组件会被缓存\",\"exclude: 字符串或正则表达式，任何匹配的组件都不会被缓存\",\"is: 字符串,如果组件的名字和is匹配，那么这个组件会被缓存\"]},\"276\":{\"title\":\"生命周期\",\"header\":\"引申 2：当父组件发生更新，那么子组件的生命周期会发生怎么样的变化？\",\"text\":[\"假如父组件的状态更新，但是子组件的状态并没有更新，那么子组件的生命周期同样也会发生更新，子组件只会调用onBeforeUpdate和updated和render()这两个生命周期函数和render函数\",\"但是如果父组件的状态更新，子组件的状态也更新了，那么子组件会调用上面三个函数，然后继续调用这三个函数，直到子组件的状态不再发生变化，这时，子组件的生命周期就会停止更新\"]},\"277\":{\"title\":\"生命周期\",\"header\":\"引申 3： keep-alive 是否类似于 React 中的 memo ？\",\"text\":[\"相同点：\",\"keep-alive和memo都是用来优化性能的，都是用来缓存组件的\",\"不同点：\",\"keep-alive是将组件缓存起来，当组件被激活时，才会重新渲染组件\",\"而memo是将组件的props缓存起来，当props发生变化时，才会重新渲染组件\"]},\"278\":{\"title\":\"生命周期\",\"header\":\"引申 4： keep-alive 下的组件生命周期\",\"text\":[\"被keep-alive组件包裹的组件，他们的生命周期函数会增加两个activated和deactivated，这两个生命周期函数只有在组件被激活时才会被调用。\"]},\"279\":{\"title\":\"生命周期\",\"header\":\"第一次渲染\",\"text\":[\"组件的create和mounted生命周期函数会被正常调用\"]},\"280\":{\"title\":\"生命周期\",\"header\":\"组件被激活\",\"text\":[\"组件的activated生命周期函数会被调用，在这个生命周期中我们可以重新激活组件，比如重新发送请求，重新获取数据等等\"]},\"281\":{\"title\":\"生命周期\",\"header\":\"组件被移除\",\"text\":[\"组件的deactivated生命周期函数会被调用，在这个生命周期中我们可以将组件的状态保存起来，比如保存组件的滚动位置，停止定时器等等\"]},\"282\":{\"title\":\"生命周期\",\"header\":\"组件被销毁\",\"text\":[\"组件的unmounted和beforeUnmount生命周期函数会被正常调用\"]},\"283\":{\"title\":\"生命周期\",\"text\":[\"其实Vue2和Vue3的生命周期并没有太大的区别，除了将beforeCreated和created合并为setUp\"],\"customFields\":{\"0\":[\"Vue\"],\"1\":[\"生命周期\"]}}},\"dirtCount\":0,\"index\":[[\"除了将beforecreated和created合并为setup\",{\"3\":{\"283\":1}}],[\"停止定时器等等\",{\"3\":{\"281\":1}}],[\"被keep\",{\"3\":{\"278\":1}}],[\"被赋值为\",{\"3\":{\"4\":1}}],[\"哪些组件不缓存\",{\"3\":{\"275\":1}}],[\"或避免重新渲染\",{\"3\":{\"275\":1}}],[\"或者给自定义方法绑定this\",{\"3\":{\"211\":1,\"215\":1}}],[\"或者当一个对象没有赋值的属性时\",{\"3\":{\"132\":1}}],[\"或者在字符串中嵌入变量\",{\"3\":{\"62\":1}}],[\"操作dom\",{\"3\":{\"265\":1}}],[\"操作方法我们也是从crud\",{\"3\":{\"110\":1}}],[\"操作方法我们可以从crud\",{\"3\":{\"101\":1}}],[\"操作方法\",{\"0\":{\"101\":1,\"110\":1},\"2\":{\"101\":1,\"110\":1}}],[\"建议在这个时候进行一些\",{\"3\":{\"264\":1}}],[\"建立连接\",{\"3\":{\"173\":1}}],[\"销毁前后\",{\"0\":{\"267\":1,\"273\":1},\"2\":{\"267\":1,\"273\":1},\"3\":{\"263\":1}}],[\"性能\",{\"0\":{\"261\":1},\"2\":{\"261\":1}}],[\"触发生命周期\",{\"0\":{\"260\":1},\"2\":{\"260\":1}}],[\"涉及到dom结构的变化\",{\"3\":{\"259\":1}}],[\"编译过程\",{\"0\":{\"259\":1},\"2\":{\"259\":1}}],[\"结构\",{\"3\":{\"259\":1}}],[\"结构中\",{\"3\":{\"258\":1}}],[\"结构中移除\",{\"3\":{\"258\":1}}],[\"结构来实现的\",{\"3\":{\"258\":1}}],[\"结合上面两个代码\",{\"3\":{\"71\":1}}],[\"为\",{\"3\":{\"258\":4}}],[\"为什么是entries\",{\"3\":{\"240\":1}}],[\"为什么在\",{\"3\":{\"190\":1}}],[\"为什么结果输出为\",{\"3\":{\"145\":1}}],[\"为什么会有\",{\"0\":{\"38\":1},\"2\":{\"38\":1}}],[\"为什么会导致内存泄漏\",{\"0\":{\"2\":1},\"2\":{\"2\":1}}],[\"为什么不是直接使用settimeout来延迟函数的执行呢\",{\"3\":{\"5\":1}}],[\"为什么要使用闭包来延迟函数的执行呢\",{\"3\":{\"5\":1}}],[\"索引类型是指我们可以通过索引的方式访问对象的属性\",{\"3\":{\"253\":1}}],[\"索引类型\",{\"0\":{\"253\":1},\"2\":{\"253\":1}}],[\"保证了这个对象必须存在某个属性或者方法\",{\"3\":{\"252\":1}}],[\"给泛型起一个别名\",{\"3\":{\"252\":1}}],[\"约束泛型的类型\",{\"3\":{\"252\":1}}],[\"更加像一个面向对象的语言\",{\"3\":{\"246\":1}}],[\"更新前后\",{\"0\":{\"266\":1,\"272\":1},\"2\":{\"266\":1,\"272\":1},\"3\":{\"263\":1}}],[\"更新阶段\",{\"0\":{\"212\":1,\"216\":1},\"2\":{\"212\":1,\"216\":1}}],[\"更新信息\",{\"3\":{\"208\":1}}],[\"更新一次当前时间\",{\"3\":{\"206\":1}}],[\"更新\",{\"3\":{\"206\":1,\"208\":1}}],[\"泛型别名就是给泛型起一个别名\",{\"3\":{\"252\":1}}],[\"泛型别名\",{\"0\":{\"252\":1},\"2\":{\"252\":1},\"3\":{\"252\":1}}],[\"泛型约束是为了更加安全的访问属性或者方法\",{\"3\":{\"252\":1}}],[\"泛型约束和泛型别名的区别\",{\"3\":{\"252\":1}}],[\"泛型约束就是指定泛型的类型\",{\"3\":{\"251\":1}}],[\"泛型约束\",{\"0\":{\"251\":1},\"2\":{\"251\":1},\"3\":{\"252\":1}}],[\"泛型类\",{\"0\":{\"250\":1},\"2\":{\"250\":1},\"3\":{\"247\":1}}],[\"泛型接口\",{\"0\":{\"249\":1},\"2\":{\"249\":1},\"3\":{\"247\":1}}],[\"泛型函数\",{\"0\":{\"248\":1},\"2\":{\"248\":1},\"3\":{\"247\":1}}],[\"泛型分类为\",{\"3\":{\"247\":1}}],[\"泛型使用方式\",{\"0\":{\"247\":1},\"2\":{\"247\":1}}],[\"泛型就是在定义函数\",{\"3\":{\"246\":1}}],[\"泛型理解\",{\"1\":{\"246\":1,\"247\":1,\"248\":1,\"249\":1,\"250\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":1}}],[\"先渲染骨架屏\",{\"3\":{\"243\":1}}],[\"先挂载\",{\"3\":{\"183\":1}}],[\"骨架屏\",{\"0\":{\"243\":1},\"2\":{\"243\":1}}],[\"虚拟列表\",{\"0\":{\"242\":1},\"2\":{\"242\":1}}],[\"前端缓存\",{\"0\":{\"241\":1},\"2\":{\"241\":1}}],[\"前一个任务执行完毕\",{\"3\":{\"138\":1}}],[\"监听\",{\"3\":{\"240\":1}}],[\"监听到的元素会放到entries数组中\",{\"3\":{\"240\":1}}],[\"监听滚动事件\",{\"3\":{\"234\":2,\"235\":1}}],[\"图片列表中的图片\",{\"3\":{\"240\":1}}],[\"图片懒加载\",{\"0\":{\"240\":1},\"2\":{\"240\":1}}],[\"图片优化\",{\"3\":{\"43\":1}}],[\"滚动条滚动的距离\",{\"3\":{\"239\":1}}],[\"视口高度\",{\"3\":{\"239\":1}}],[\"视窗高度和视窗宽度\",{\"3\":{\"27\":1}}],[\"利用路由参数来记录上次浏览的位置\",{\"3\":{\"235\":1}}],[\"利用localstorage来记录上次浏览的位置\",{\"3\":{\"234\":1}}],[\"文档的高度\",{\"3\":{\"239\":3}}],[\"文档从顶部开始滚动的像素值\",{\"3\":{\"234\":1,\"239\":1}}],[\"文本或者是节点\",{\"3\":{\"221\":1}}],[\"文本装饰\",{\"3\":{\"25\":1}}],[\"文本对齐方式\",{\"3\":{\"25\":1}}],[\"文本颜色\",{\"3\":{\"25\":1}}],[\"文本类\",{\"3\":{\"25\":2}}],[\"跳转到上次浏览的位置\",{\"3\":{\"234\":2,\"235\":1}}],[\"读取上次浏览的位置\",{\"3\":{\"234\":2}}],[\"方式\",{\"0\":{\"258\":1},\"2\":{\"258\":1}}],[\"方案五\",{\"0\":{\"243\":1},\"2\":{\"243\":1}}],[\"方案四\",{\"0\":{\"242\":1},\"2\":{\"242\":1}}],[\"方案三\",{\"0\":{\"241\":1},\"2\":{\"241\":1}}],[\"方案二\",{\"0\":{\"235\":1,\"240\":1},\"2\":{\"235\":1,\"240\":1}}],[\"方案一\",{\"0\":{\"234\":1,\"239\":1},\"2\":{\"234\":1,\"239\":1}}],[\"方法返回的promise对象就会变为resolved状态\",{\"3\":{\"79\":1}}],[\"方法返回的promise对象就会变为rejected状态\",{\"3\":{\"79\":2}}],[\"方法返回的promise对象才会变为resolved状态\",{\"3\":{\"79\":1}}],[\"方法\",{\"3\":{\"29\":1,\"71\":1,\"72\":1,\"76\":1,\"79\":2,\"83\":2,\"104\":1,\"119\":1}}],[\"能够记录上次浏览的位置\",{\"3\":{\"232\":1}}],[\"关闭页面\",{\"3\":{\"232\":1}}],[\"关于扩展运算符和解构赋值\",{\"3\":{\"67\":1}}],[\"打开一个页面浏览后\",{\"3\":{\"232\":1}}],[\"非受控组件是指表单数据由\",{\"3\":{\"229\":1}}],[\"非受控组件\",{\"0\":{\"229\":1},\"2\":{\"229\":1}}],[\"变化时\",{\"3\":{\"228\":1}}],[\"变量使用$\",{\"3\":{\"111\":1}}],[\"变量的值就等于undefined\",{\"3\":{\"64\":1}}],[\"变量的值就等于\",{\"3\":{\"64\":1}}],[\"变量提升就是在代码执行之前\",{\"3\":{\"58\":1}}],[\"变量提升\",{\"0\":{\"58\":1},\"2\":{\"58\":1}}],[\"受控组件就是表单数据被\",{\"3\":{\"228\":1}}],[\"受控组件是指表单数据由\",{\"3\":{\"228\":1}}],[\"受控组件和非受控组件\",{\"1\":{\"228\":1,\"229\":1,\"230\":1}}],[\"受控组件\",{\"0\":{\"228\":1},\"2\":{\"228\":1}}],[\"任何匹配的组件都不会被缓存\",{\"3\":{\"275\":1}}],[\"任意组件通信\",{\"0\":{\"226\":1},\"2\":{\"226\":1},\"3\":{\"225\":1}}],[\"任务阶段\",{\"3\":{\"191\":1}}],[\"任务优先级\",{\"3\":{\"191\":1}}],[\"任务队列中的任务分为两种\",{\"3\":{\"138\":1}}],[\"任务队列\",{\"0\":{\"138\":1},\"2\":{\"138\":1}}],[\"提供的一种跨组件传递参数的方式\",{\"3\":{\"225\":1}}],[\"提前缓存\",{\"3\":{\"45\":1}}],[\"提前加载\",{\"3\":{\"45\":1}}],[\"要想实现跨级的组件通信\",{\"3\":{\"224\":1}}],[\"要先进行三次握手\",{\"3\":{\"173\":1}}],[\"跨级组件通信\",{\"0\":{\"224\":1},\"2\":{\"224\":1}}],[\"跨域\",{\"0\":{\"15\":1,\"16\":1},\"2\":{\"15\":1,\"16\":1}}],[\"跨域是指浏览器不能执行其他网站的脚本\",{\"3\":{\"12\":1}}],[\"跨域问腿\",{\"1\":{\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"16\":1,\"17\":1,\"18\":1}}],[\"兄弟组件需要用到的参数\",{\"3\":{\"223\":1}}],[\"兄弟组件是无法通信的\",{\"3\":{\"223\":1}}],[\"兄弟组件通信\",{\"0\":{\"223\":1},\"2\":{\"223\":1},\"3\":{\"223\":1}}],[\"兄弟选择器\",{\"3\":{\"23\":2}}],[\"响应事件\",{\"3\":{\"222\":1}}],[\"响应式布局\",{\"3\":{\"43\":1}}],[\"正如上面所说的\",{\"3\":{\"224\":1}}],[\"正确\",{\"3\":{\"222\":1}}],[\"正常浏览器会存在垃圾回收机制\",{\"3\":{\"2\":1}}],[\"错误可以被阻止向上传播\",{\"3\":{\"268\":1}}],[\"错误\",{\"3\":{\"222\":1}}],[\"应该是直接传递的\",{\"3\":{\"222\":1}}],[\"应用层将数据交给传输层\",{\"3\":{\"167\":1}}],[\"应用层是工作在操作系统的用户态\",{\"3\":{\"164\":1}}],[\"应用层是网络应用程序及它们的应用层协议存留的地方\",{\"3\":{\"164\":1}}],[\"应用层不关心数据传输的细节\",{\"3\":{\"164\":1}}],[\"应用层\",{\"0\":{\"164\":1},\"2\":{\"164\":1}}],[\"应用场景\",{\"0\":{\"34\":1},\"2\":{\"34\":1},\"3\":{\"67\":1,\"248\":1}}],[\"了\",{\"3\":{\"222\":1}}],[\"父传子\",{\"0\":{\"221\":1},\"2\":{\"221\":1}}],[\"父子组件通信\",{\"0\":{\"220\":1},\"2\":{\"220\":1},\"3\":{\"222\":1}}],[\"父组件的状态会非常多以及组件的层级会非常深\",{\"3\":{\"224\":1}}],[\"父组件\",{\"3\":{\"221\":1,\"222\":1,\"223\":1}}],[\"父组件传递给子组件\",{\"3\":{\"212\":1}}],[\"父组件被重新渲染\",{\"3\":{\"212\":1}}],[\"父组件中有一个子组件\",{\"3\":{\"202\":1}}],[\"父组件中有一个状态对象\",{\"3\":{\"202\":1}}],[\"次<\",{\"3\":{\"218\":1}}],[\"判断\",{\"3\":{\"216\":1}}],[\"必须要有一个条件限制\",{\"3\":{\"216\":1}}],[\"则不会更新组件的状态对象\",{\"3\":{\"215\":1}}],[\"取消网络请求\",{\"3\":{\"213\":1,\"217\":1}}],[\"清除组件中的缓存等\",{\"3\":{\"213\":1,\"217\":1}}],[\"清除定时器\",{\"3\":{\"213\":1,\"217\":1}}],[\"清除浮动\",{\"3\":{\"34\":1}}],[\"特性\",{\"3\":{\"212\":1}}],[\"特点\",{\"3\":{\"61\":1,\"206\":1}}],[\"渲染文章\",{\"3\":{\"242\":2}}],[\"渲染可视区域的文章\",{\"3\":{\"242\":1}}],[\"渲染函数\",{\"3\":{\"211\":1,\"215\":1}}],[\"渲染阻塞会阻塞dom树的构建\",{\"3\":{\"37\":1}}],[\"渲染阻塞\",{\"0\":{\"37\":1,\"38\":1,\"39\":1},\"2\":{\"37\":1,\"38\":1,\"39\":1}}],[\"版本之前的生命周期\",{\"0\":{\"210\":1},\"2\":{\"210\":1}}],[\"版本之后的生命周期\",{\"0\":{\"214\":1},\"2\":{\"214\":1}}],[\"版本之后\",{\"3\":{\"208\":1}}],[\"推出了fiber架构\",{\"3\":{\"208\":1}}],[\"安排任务的调度\",{\"3\":{\"208\":1}}],[\"卸载阶段\",{\"0\":{\"213\":1,\"217\":1},\"2\":{\"213\":1,\"217\":1}}],[\"卸载\",{\"3\":{\"208\":1}}],[\"挂载前后\",{\"0\":{\"265\":1,\"271\":1},\"2\":{\"265\":1,\"271\":1},\"3\":{\"263\":1}}],[\"挂载阶段\",{\"0\":{\"211\":1,\"215\":1},\"2\":{\"211\":1,\"215\":1}}],[\"挂载\",{\"3\":{\"208\":1}}],[\"生命周期其实并没有特别大的变化\",{\"3\":{\"269\":1}}],[\"生命周期包括\",{\"3\":{\"263\":1}}],[\"生命周期\",{\"1\":{\"263\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":1,\"271\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":1,\"276\":1,\"277\":1,\"278\":1,\"279\":1,\"280\":1,\"281\":1,\"282\":1,\"283\":1}}],[\"生命周期函数都是react\",{\"3\":{\"218\":1}}],[\"生命周期的分类\",{\"0\":{\"209\":1},\"2\":{\"209\":1}}],[\"生命周期分为三个状态\",{\"3\":{\"208\":1}}],[\"生命周期是组件从实例化到销毁的过程\",{\"3\":{\"208\":1}}],[\"生效则返回\",{\"3\":{\"10\":1}}],[\"生效则直接使用缓存\",{\"3\":{\"10\":1}}],[\"确实可以获取到\",{\"3\":{\"206\":1}}],[\"确认\",{\"3\":{\"145\":1}}],[\"开始计时\",{\"3\":{\"206\":1}}],[\"开始执行宏任务队列中的任务\",{\"3\":{\"141\":5}}],[\"开始执行微任务队列中的任务\",{\"3\":{\"141\":3}}],[\"李四\",{\"3\":{\"204\":1,\"205\":1}}],[\"计算double\",{\"3\":{\"204\":1}}],[\"之间组件通信的方式有哪些\",{\"3\":{\"202\":1}}],[\"之类的\",{\"3\":{\"16\":1}}],[\"之类弱引用的数据结构\",{\"3\":{\"3\":1}}],[\"组件被销毁\",{\"0\":{\"282\":1},\"2\":{\"282\":1}}],[\"组件被移除\",{\"0\":{\"281\":1},\"2\":{\"281\":1}}],[\"组件被激活\",{\"0\":{\"280\":1},\"2\":{\"280\":1}}],[\"组件的unmounted和beforeunmount生命周期函数会被正常调用\",{\"3\":{\"282\":1}}],[\"组件的deactivated生命周期函数会被调用\",{\"3\":{\"281\":1}}],[\"组件的activated生命周期函数会被调用\",{\"3\":{\"280\":1}}],[\"组件的create和mounted生命周期函数会被正常调用\",{\"3\":{\"279\":1}}],[\"组件的生命周期分为三个阶段\",{\"3\":{\"208\":1}}],[\"组件\",{\"3\":{\"266\":1,\"272\":1}}],[\"组件将要销毁时\",{\"3\":{\"234\":1}}],[\"组件所控制的组件\",{\"3\":{\"228\":1}}],[\"组件来管理的组件\",{\"3\":{\"228\":1}}],[\"组件来获取参数\",{\"3\":{\"225\":1}}],[\"组件包裹需要传递参数的组件\",{\"3\":{\"225\":1}}],[\"组件挂载完成\",{\"3\":{\"218\":1}}],[\"组件已经被更新之后执行\",{\"3\":{\"212\":1,\"216\":1}}],[\"组件已经被挂载到页面上之后执行\",{\"3\":{\"211\":1}}],[\"组件是否要被更新\",{\"3\":{\"212\":1,\"216\":1}}],[\"组件即将接收到新的props之前执行\",{\"3\":{\"212\":1}}],[\"组件即将被卸载\",{\"3\":{\"218\":1}}],[\"组件即将被卸载之前执行\",{\"3\":{\"201\":1,\"213\":1,\"217\":1}}],[\"组件即将被更新之前执行\",{\"3\":{\"212\":1}}],[\"组件即将被挂载到页面上之前执行\",{\"3\":{\"211\":1}}],[\"组件通信方式\",{\"3\":{\"202\":1}}],[\"组件初始化渲染之后执行\",{\"3\":{\"201\":1}}],[\"组合继承\",{\"3\":{\"159\":1}}],[\"种类\",{\"0\":{\"199\":1},\"2\":{\"199\":1}}],[\"越先执行\",{\"3\":{\"191\":1}}],[\"|\",{\"3\":{\"191\":7}}],[\"导致首页加载很慢\",{\"3\":{\"237\":1}}],[\"导致无限循环\",{\"3\":{\"222\":1}}],[\"导致页面卡顿的问题\",{\"3\":{\"208\":1}}],[\"导致垃圾回收机制无法回收\",{\"3\":{\"2\":1}}],[\"导入的函数\",{\"3\":{\"190\":1}}],[\"需要传入的参数和返回的参数是一致的\",{\"3\":{\"248\":1}}],[\"需要特别注意\",{\"3\":{\"202\":1}}],[\"需要引入\",{\"3\":{\"190\":2}}],[\"需要对列表的每一项都能进行一些相同的事件\",{\"3\":{\"148\":1}}],[\"语法\",{\"3\":{\"252\":2}}],[\"语法时\",{\"3\":{\"190\":2}}],[\"语法改进\",{\"3\":{\"42\":1}}],[\"老版本中\",{\"3\":{\"190\":1}}],[\"值为\",{\"3\":{\"189\":1}}],[\"值为5\",{\"3\":{\"5\":1}}],[\"记录滚动位置\",{\"3\":{\"234\":3,\"235\":2}}],[\"记录上次浏览的位置\",{\"1\":{\"232\":1,\"233\":1,\"234\":1,\"235\":1,\"236\":1}}],[\"记录创建这个元素的组件\",{\"3\":{\"189\":1}}],[\"记一下\",{\"3\":{\"141\":1}}],[\"举一个例子\",{\"3\":{\"188\":1}}],[\"举例\",{\"3\":{\"148\":1}}],[\"创建前后\",{\"0\":{\"264\":1,\"270\":1},\"2\":{\"264\":1,\"270\":1},\"3\":{\"263\":1}}],[\"创建\",{\"3\":{\"225\":1}}],[\"创建ref对象\",{\"3\":{\"206\":1}}],[\"创建一个上下文对象\",{\"3\":{\"202\":1}}],[\"创建了两个\",{\"0\":{\"183\":1},\"2\":{\"183\":1}}],[\"创建闭包的最常见的方式就是在一个函数内创建另一个函数\",{\"3\":{\"4\":1}}],[\"系统加载\",{\"1\":{\"181\":1,\"182\":1,\"183\":1,\"184\":1}}],[\"交换机的端口因为无法获取到mac地址\",{\"3\":{\"177\":1}}],[\"交换机\",{\"0\":{\"177\":1},\"2\":{\"177\":1}}],[\"帧里面包含了mac头部和ip头部\",{\"3\":{\"175\":1}}],[\"询问目的主机的mac地址\",{\"3\":{\"175\":1}}],[\"发生在虚拟dom重新渲染和打补丁之前\",{\"3\":{\"266\":1,\"272\":1}}],[\"发生了什么\",{\"1\":{\"171\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1}}],[\"发送到路由器上\",{\"3\":{\"176\":1}}],[\"发送方的mac在网卡生产的时候就已经固定了\",{\"3\":{\"175\":1}}],[\"双方建立好连接以后\",{\"3\":{\"173\":1}}],[\"双重非运算符\",{\"3\":{\"89\":1}}],[\"向dns发送请求采用的是迭代查询\",{\"3\":{\"172\":1}}],[\"锚点等信息\",{\"3\":{\"171\":1}}],[\"查询字符串\",{\"3\":{\"171\":1}}],[\"查找路由表\",{\"3\":{\"178\":1}}],[\"查找字符串中是否包含searchvalue\",{\"3\":{\"114\":2}}],[\"查找元素\",{\"0\":{\"105\":1,\"114\":1},\"2\":{\"105\":1,\"114\":1}}],[\"路径\",{\"3\":{\"171\":1}}],[\"路由器会根据ip头部的目的ip地址\",{\"3\":{\"178\":1}}],[\"路由器\",{\"0\":{\"178\":1},\"2\":{\"178\":1}}],[\"路由器寻址工作中\",{\"3\":{\"167\":1}}],[\"路由更像在操作方向盘\",{\"3\":{\"167\":1}}],[\"路由则是根据\",{\"3\":{\"167\":1}}],[\"获取dom的尺寸等\",{\"3\":{\"265\":1}}],[\"获取到真实的\",{\"3\":{\"212\":1}}],[\"获取不到的\",{\"3\":{\"206\":1}}],[\"获取input输入内容\",{\"3\":{\"206\":1}}],[\"获取协议\",{\"3\":{\"171\":1}}],[\"获取数组的部分元素\",{\"3\":{\"67\":1}}],[\"键入网址到页面显示\",{\"1\":{\"171\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1}}],[\"每次加载一定数量的数据\",{\"3\":{\"239\":1}}],[\"每次执行handlestart的时候\",{\"3\":{\"206\":1}}],[\"每篇文章都有很多内容\",{\"3\":{\"237\":1}}],[\"每\",{\"3\":{\"206\":1}}],[\"每一层的封装格式\",{\"3\":{\"169\":1}}],[\"每个小的数据包都会被封装成一个tcp段\",{\"3\":{\"166\":1}}],[\"每个对象都有一个\",{\"3\":{\"156\":1}}],[\"每个函数都有一个\",{\"3\":{\"155\":1}}],[\"每个元素用指定的字符串隔开\",{\"3\":{\"108\":1}}],[\"每个元素用\",{\"3\":{\"108\":1}}],[\"每个变量存储的是一个指针\",{\"3\":{\"99\":1}}],[\"每个变量都有自己的内存空间\",{\"3\":{\"99\":1}}],[\"物理层是整个网络模型的最底层\",{\"3\":{\"169\":1}}],[\"物理层\",{\"0\":{\"169\":1},\"2\":{\"169\":1}}],[\"链路层是网络层的下一层\",{\"3\":{\"168\":1}}],[\"链路层\",{\"0\":{\"168\":1},\"2\":{\"168\":1}}],[\"寻址更像在导航\",{\"3\":{\"167\":1}}],[\"下的组件生命周期\",{\"2\":{\"278\":1}}],[\"下一个目的地\",{\"3\":{\"167\":1}}],[\"下面给出一些例子\",{\"3\":{\"122\":1}}],[\"找到后进而把数据包转发给对应的网络内\",{\"3\":{\"167\":1}}],[\"两个主机并不是直接通过一条链路相连的\",{\"3\":{\"167\":1}}],[\"选择路径\",{\"3\":{\"167\":1}}],[\"选择不同的路由\",{\"3\":{\"167\":1}}],[\"选择器+属性选择器\",{\"3\":{\"24\":1}}],[\"选择器\",{\"0\":{\"23\":1},\"2\":{\"23\":1},\"3\":{\"23\":1,\"24\":2}}],[\"网络包经过交换机转发到路由器上\",{\"3\":{\"178\":1}}],[\"网络层使用协议\",{\"3\":{\"167\":1}}],[\"网络层\",{\"0\":{\"167\":1},\"2\":{\"167\":1}}],[\"网卡会将数据包转换为电信号\",{\"3\":{\"176\":1}}],[\"网卡\",{\"0\":{\"176\":1},\"2\":{\"176\":1}}],[\"网页首次加载时\",{\"3\":{\"41\":1}}],[\"超过了输出层的数据包大小的时候\",{\"3\":{\"166\":1}}],[\"尽最大努力的数据传输服务\",{\"3\":{\"165\":1}}],[\"电脑上的软件\",{\"3\":{\"164\":1}}],[\"面试官\",{\"3\":{\"163\":1}}],[\"小林x图解计算机基础\",{\"3\":{\"163\":1}}],[\"子传父\",{\"0\":{\"222\":1},\"2\":{\"222\":1}}],[\"子组件的生命周期就会停止更新\",{\"3\":{\"276\":1}}],[\"子组件的状态也更新了\",{\"3\":{\"276\":1}}],[\"子组件只会调用onbeforeupdate和updated和render\",{\"3\":{\"276\":1}}],[\"子组件获取不到\",{\"3\":{\"225\":1}}],[\"子组件2\",{\"3\":{\"223\":1}}],[\"子组件1\",{\"3\":{\"223\":1}}],[\"子组件\",{\"3\":{\"222\":1}}],[\"子组件需要使用父组件的参数\",{\"3\":{\"221\":1}}],[\"子组件中需要使用到父组件中的状态对象\",{\"3\":{\"202\":1}}],[\"子类\",{\"3\":{\"160\":1}}],[\"子类无法获取到父类原型上的方法\",{\"3\":{\"159\":1}}],[\"子代选择器\",{\"3\":{\"23\":1}}],[\"构造函数继承获取到父类的属性\",{\"3\":{\"159\":1}}],[\"构造函数继承+原型链继承\",{\"3\":{\"159\":1}}],[\"构造函数\",{\"3\":{\"159\":2,\"211\":1,\"215\":1}}],[\"构造函数方法\",{\"0\":{\"79\":1},\"2\":{\"79\":1}}],[\"点击div3时\",{\"3\":{\"153\":1}}],[\"点击事件这类\",{\"3\":{\"148\":1}}],[\"现在我们可以分析上述代码\",{\"3\":{\"153\":1}}],[\"现在可以改写成\",{\"3\":{\"42\":2}}],[\"现代浏览器的事件模型\",{\"3\":{\"153\":1}}],[\"原型对象也是对象\",{\"3\":{\"156\":1}}],[\"原型对象中有一个\",{\"3\":{\"155\":1}}],[\"原型链继承获取到父类的方法\",{\"3\":{\"159\":1}}],[\"原型链继承\",{\"3\":{\"159\":1}}],[\"原型链\",{\"0\":{\"156\":1},\"2\":{\"156\":1}}],[\"原型\",{\"0\":{\"155\":1},\"2\":{\"155\":1}}],[\"原始事件模型就是指在ie8及其以下版本中使用的事件模型\",{\"3\":{\"152\":1}}],[\"原始事件模型\",{\"0\":{\"152\":1},\"2\":{\"152\":1},\"3\":{\"151\":1,\"152\":1}}],[\"原因\",{\"3\":{\"5\":1}}],[\"冒泡阶段\",{\"3\":{\"150\":1}}],[\"目标阶段\",{\"3\":{\"150\":1}}],[\"捕获阶段\",{\"3\":{\"150\":1}}],[\"既然提到事件委托\",{\"3\":{\"148\":1}}],[\"既不是成功也不是失败\",{\"3\":{\"77\":1}}],[\"适合事件委托的事件有\",{\"3\":{\"148\":1}}],[\"假如父组件的状态更新\",{\"3\":{\"276\":1}}],[\"假如isshow\",{\"3\":{\"258\":1}}],[\"假如\",{\"3\":{\"258\":3}}],[\"假如在react项目中\",{\"3\":{\"235\":1}}],[\"假如我们在登录成功后\",{\"3\":{\"181\":1}}],[\"假如我们为每一个列表项都增加点击事件\",{\"3\":{\"148\":1}}],[\"假如使用变量let\",{\"3\":{\"5\":1}}],[\"补充\",{\"3\":{\"148\":1}}],[\"补充weakmap\",{\"3\":{\"127\":1}}],[\"事件名要么就只写时间名字\",{\"3\":{\"222\":1}}],[\"事件处理程序\",{\"3\":{\"153\":1}}],[\"事件处理程序就会创建一个执行上下文\",{\"3\":{\"148\":1}}],[\"事件类型\",{\"3\":{\"153\":1}}],[\"事件流阶段\",{\"3\":{\"150\":1}}],[\"事件的执行的先后顺序问题\",{\"3\":{\"150\":1}}],[\"事件和事件流\",{\"0\":{\"150\":1},\"2\":{\"150\":1}}],[\"事件模型分为两种\",{\"3\":{\"151\":1}}],[\"事件模型\",{\"0\":{\"149\":1,\"151\":1},\"2\":{\"149\":1,\"151\":1}}],[\"事件委托适用于那些场景\",{\"3\":{\"148\":1}}],[\"事件委托就是利用事件冒泡\",{\"3\":{\"148\":1}}],[\"事件委托\",{\"0\":{\"148\":1},\"2\":{\"148\":1}}],[\"事件循环是指\",{\"3\":{\"139\":1}}],[\"事件循环\",{\"0\":{\"139\":1},\"1\":{\"137\":1,\"138\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1},\"2\":{\"139\":1}}],[\"queryselector\",{\"3\":{\"239\":1}}],[\"queryselectorall\",{\"3\":{\"67\":1,\"240\":2,\"242\":1}}],[\"query\",{\"3\":{\"235\":2}}],[\"question\",{\"3\":{\"232\":1,\"237\":1}}],[\"q\",{\"3\":{\"145\":1,\"223\":1}}],[\"词法作用域就是指作用域是由代码中函数声明的位置来决定的\",{\"3\":{\"145\":1}}],[\"词法作用域\",{\"0\":{\"145\":1},\"2\":{\"145\":1}}],[\"直接从缓存中读取\",{\"3\":{\"241\":2}}],[\"直接使用this\",{\"3\":{\"196\":1}}],[\"直接跳转到首页\",{\"3\":{\"181\":1}}],[\"直接返回false\",{\"3\":{\"122\":1,\"123\":1}}],[\"直到子组件的状态不再发生变化\",{\"3\":{\"276\":1}}],[\"直到最后返回一个ip地址\",{\"3\":{\"172\":1}}],[\"直到div3\",{\"3\":{\"153\":1}}],[\"直到根元素div1\",{\"3\":{\"152\":1}}],[\"直到找到该变量或者到全局作用域\",{\"3\":{\"144\":1,\"145\":1}}],[\"深入浅出浏览器事件循环\",{\"3\":{\"141\":1}}],[\"深拷贝会拷贝所有的属性\",{\"3\":{\"127\":1}}],[\"深拷贝就是能够实现真正意义上的对象拷贝\",{\"3\":{\"127\":1}}],[\"深拷贝\",{\"0\":{\"127\":1},\"2\":{\"127\":1}}],[\"深拷贝vs浅拷贝\",{\"1\":{\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"130\":1}}],[\"深拷贝和浅拷贝\",{\"3\":{\"85\":1}}],[\"去执行微任务队列中的任务\",{\"3\":{\"141\":1}}],[\"去除字符串两端的空格\",{\"3\":{\"113\":1}}],[\"输出8\",{\"3\":{\"141\":1}}],[\"输出7\",{\"3\":{\"141\":1}}],[\"输出6\",{\"3\":{\"141\":2}}],[\"输出5\",{\"3\":{\"141\":3}}],[\"输出3\",{\"3\":{\"141\":3}}],[\"输出2\",{\"3\":{\"141\":3}}],[\"输出4\",{\"3\":{\"141\":3}}],[\"输出1\",{\"3\":{\"141\":3}}],[\"输出settimeout\",{\"3\":{\"141\":1}}],[\"输出script\",{\"3\":{\"141\":2}}],[\"输出promise1\",{\"3\":{\"141\":1}}],[\"遇到了setimmediate\",{\"3\":{\"141\":2}}],[\"遇到了process\",{\"3\":{\"141\":2}}],[\"遇到了promise\",{\"3\":{\"141\":2}}],[\"遇到promise\",{\"3\":{\"141\":3}}],[\"遇到settimeout\",{\"3\":{\"141\":3}}],[\"遇到不可以转化的就截断\",{\"3\":{\"87\":1}}],[\"首页有很多文章数目\",{\"3\":{\"237\":1}}],[\"首屏加载慢\",{\"1\":{\"237\":1,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":1}}],[\"首先\",{\"3\":{\"235\":1}}],[\"首先jsx会被babel转化成react\",{\"3\":{\"188\":1}}],[\"首先先来介绍一下原型和原型链\",{\"3\":{\"158\":1}}],[\"首先进行同步任务\",{\"3\":{\"141\":1}}],[\"首先执行同步任务\",{\"3\":{\"141\":1}}],[\"首行缩进\",{\"3\":{\"25\":1}}],[\"执行操作\",{\"3\":{\"148\":1}}],[\"执行宏任务队列中的任务\",{\"3\":{\"141\":1}}],[\"执行微任务队列中的任务\",{\"3\":{\"141\":5}}],[\"执行同步任务\",{\"3\":{\"141\":1}}],[\"执行顺序\",{\"3\":{\"140\":1}}],[\"执行到reject时\",{\"3\":{\"76\":1}}],[\"执行到resolve时\",{\"3\":{\"76\":1}}],[\"微任务队列空闲\",{\"3\":{\"141\":1}}],[\"微任务队列中的任务执行完毕\",{\"3\":{\"141\":3}}],[\"微任务\",{\"3\":{\"140\":1}}],[\"宏任务\",{\"3\":{\"140\":1}}],[\"宏任务和微任务都是异步任务\",{\"3\":{\"140\":1}}],[\"宏任务和微任务有哪些区别\",{\"3\":{\"140\":1}}],[\"宏任务和微任务\",{\"0\":{\"140\":1},\"2\":{\"140\":1}}],[\"主线程空闲\",{\"3\":{\"141\":1}}],[\"主线程不断从任务队列中读取任务\",{\"3\":{\"139\":1}}],[\"主要就是export和import两个关键字\",{\"3\":{\"74\":1}}],[\"主要原则就是\",{\"3\":{\"24\":1}}],[\"异步执行\",{\"3\":{\"141\":1}}],[\"异步任务则会在异步任务有了结果后\",{\"3\":{\"138\":1}}],[\"异步操作\",{\"3\":{\"76\":1,\"79\":7}}],[\"同样的当dom结构中的元素被移除后\",{\"3\":{\"258\":1}}],[\"同样的\",{\"3\":{\"204\":1,\"205\":1}}],[\"同时支持冒泡阶段和捕获阶段\",{\"3\":{\"153\":1}}],[\"同步执行\",{\"3\":{\"141\":1}}],[\"同步任务执行完毕\",{\"3\":{\"141\":1}}],[\"同步任务\",{\"3\":{\"141\":2}}],[\"同步任务会在主线程上排队执行\",{\"3\":{\"138\":1}}],[\"同源\",{\"3\":{\"13\":1}}],[\"同源策略是浏览器的安全策略\",{\"3\":{\"17\":1}}],[\"同源策略\",{\"0\":{\"13\":1},\"2\":{\"13\":1}}],[\"还需要在数据链路层生成mac头部\",{\"3\":{\"175\":1}}],[\"还有一种常见场景\",{\"3\":{\"148\":1}}],[\"还有一个特性\",{\"3\":{\"137\":1}}],[\"还是没有考虑到\",{\"3\":{\"127\":1}}],[\"产生原因\",{\"3\":{\"150\":1}}],[\"产生的原因\",{\"0\":{\"137\":1},\"2\":{\"137\":1}}],[\"产生时间\",{\"0\":{\"55\":1},\"2\":{\"55\":1}}],[\"条件判断的时候\",{\"3\":{\"134\":1}}],[\"赋值为null的对象\",{\"3\":{\"133\":1}}],[\"赋值为null\",{\"3\":{\"133\":1}}],[\"赋值还是在后面\",{\"3\":{\"58\":1}}],[\"已经更新\",{\"3\":{\"266\":1,\"272\":1}}],[\"已经赋值为null了\",{\"3\":{\"133\":1}}],[\"已经被销毁\",{\"3\":{\"4\":1}}],[\"没有赋值的对象属性\",{\"3\":{\"132\":1}}],[\"没有赋值的变量\",{\"3\":{\"132\":1}}],[\"没有返回值\",{\"3\":{\"107\":1}}],[\"参考链接\",{\"3\":{\"202\":1}}],[\"参考文档\",{\"3\":{\"141\":1,\"163\":1}}],[\"参考文章\",{\"0\":{\"129\":1},\"2\":{\"129\":1}}],[\"参数列表\",{\"3\":{\"67\":1}}],[\"参数的逆运算\",{\"3\":{\"67\":1}}],[\"有时候我们定义的函数\",{\"3\":{\"248\":1}}],[\"有一个父组件\",{\"3\":{\"202\":1}}],[\"有兴趣的可以自己写一下\",{\"3\":{\"127\":1}}],[\"有什么区别\",{\"3\":{\"87\":1}}],[\"把map换为weakmap\",{\"3\":{\"127\":1}}],[\"接口或类的时候\",{\"3\":{\"246\":2}}],[\"接受三个参数\",{\"3\":{\"189\":1,\"190\":1}}],[\"接着执行微任务队列中的任务\",{\"3\":{\"141\":2}}],[\"接着我们可以参考\",{\"3\":{\"127\":1}}],[\"接收一个数组\",{\"3\":{\"79\":2}}],[\"接收一个参数\",{\"3\":{\"78\":2,\"79\":2}}],[\"接收两个参数\",{\"3\":{\"78\":1}}],[\"拓展运算符\",{\"3\":{\"126\":1}}],[\"笼统来说\",{\"3\":{\"125\":1}}],[\"笼统的说\",{\"3\":{\"121\":1}}],[\"拷贝的就是内存地址\",{\"3\":{\"125\":1}}],[\"拷贝的就是基本类型的值\",{\"3\":{\"125\":1}}],[\"浅拷贝只是复制了一层对象的属性\",{\"3\":{\"125\":1}}],[\"浅拷贝\",{\"0\":{\"125\":1},\"2\":{\"125\":1}}],[\"完全等于===属于比较运算符\",{\"3\":{\"122\":1}}],[\"完全等于\",{\"0\":{\"122\":1},\"2\":{\"122\":1}}],[\"栈内存里面的地址必须相同\",{\"3\":{\"121\":1}}],[\"意思就是\",{\"3\":{\"121\":1}}],[\"意味着对\",{\"3\":{\"4\":1}}],[\"算术运算符\",{\"3\":{\"119\":1}}],[\"隐式类型转化发生的场景\",{\"3\":{\"119\":1}}],[\"隐式类型转化\",{\"0\":{\"119\":1},\"2\":{\"119\":1}}],[\"隐式绑定\",{\"3\":{\"82\":1}}],[\"显示类型转化\",{\"0\":{\"118\":1},\"2\":{\"118\":1}}],[\"显示绑定\",{\"3\":{\"82\":1}}],[\"转换成相同的类型\",{\"3\":{\"121\":1,\"123\":1}}],[\"转换规则如下\",{\"3\":{\"121\":1}}],[\"转换方法\",{\"0\":{\"115\":1},\"2\":{\"115\":1}}],[\"转化过程\",{\"0\":{\"187\":1},\"2\":{\"187\":1}}],[\"转化应该调用的是number\",{\"3\":{\"119\":1}}],[\"转化方法\",{\"0\":{\"108\":1},\"2\":{\"108\":1}}],[\"转化为\",{\"0\":{\"188\":1,\"192\":1},\"2\":{\"188\":1,\"192\":1}}],[\"转化为数字的时候\",{\"3\":{\"135\":3}}],[\"转化为数字的方法parseint\",{\"3\":{\"87\":1}}],[\"转化为boolean的方法\",{\"3\":{\"118\":1}}],[\"转化为string的方法\",{\"3\":{\"118\":1}}],[\"转化为number的方法\",{\"3\":{\"118\":1}}],[\"转化为布尔值的方法\",{\"3\":{\"89\":1}}],[\"大写\",{\"3\":{\"113\":1}}],[\"大于\",{\"3\":{\"106\":1}}],[\"截取字符串\",{\"3\":{\"112\":3}}],[\"加载图片\",{\"3\":{\"240\":3}}],[\"加载下一批数据\",{\"3\":{\"239\":4}}],[\"加载不同的图片\",{\"3\":{\"43\":1}}],[\"加载不同的样式\",{\"3\":{\"43\":1}}],[\"加号\",{\"3\":{\"111\":1}}],[\"连接字符串\",{\"3\":{\"111\":1}}],[\"连接两个或多个数组\",{\"3\":{\"102\":1}}],[\"隔开\",{\"3\":{\"108\":1}}],[\"该服务器会返回一个ip地址\",{\"3\":{\"172\":1}}],[\"该值会作为下一次迭代的prev\",{\"3\":{\"107\":1}}],[\"该项目将缩小\",{\"3\":{\"50\":1}}],[\"才会重新渲染组件\",{\"3\":{\"277\":2}}],[\"才会执行useeffect函数中的函数\",{\"3\":{\"201\":1}}],[\"才会执行后一个任务\",{\"3\":{\"138\":1}}],[\"才会执行任务队列中的代码\",{\"3\":{\"5\":1}}],[\"才是\",{\"3\":{\"145\":1}}],[\"才返回true\",{\"3\":{\"107\":1}}],[\"遍历数组\",{\"3\":{\"107\":6}}],[\"迭代方法\",{\"0\":{\"107\":1},\"2\":{\"107\":1}}],[\"分页加载\",{\"0\":{\"239\":1},\"2\":{\"239\":1}}],[\"分析词法作用域\",{\"3\":{\"145\":1}}],[\"分析一下上述代码\",{\"3\":{\"5\":1}}],[\"分别表示小于\",{\"3\":{\"106\":1}}],[\"比较这两个对象是不是同一个对象\",{\"3\":{\"121\":1}}],[\"比较运算符\",{\"3\":{\"119\":1}}],[\"比较函数返回值为\",{\"3\":{\"106\":1}}],[\"比如保存组件的滚动位置\",{\"3\":{\"281\":1}}],[\"比如重新发送请求\",{\"3\":{\"280\":1}}],[\"比如说\",{\"3\":{\"224\":1}}],[\"比如上面的例子\",{\"3\":{\"206\":1}}],[\"比如settimeout\",{\"3\":{\"140\":1}}],[\"比如\",{\"3\":{\"89\":1,\"127\":1,\"189\":1,\"190\":1,\"212\":1,\"213\":1,\"217\":1}}],[\"比如你在请求一个跨域的接口\",{\"3\":{\"13\":1}}],[\"比如cdn\",{\"3\":{\"8\":1}}],[\"排序方法\",{\"0\":{\"106\":1},\"2\":{\"106\":1}}],[\"排列越靠前\",{\"3\":{\"50\":1}}],[\"修改数组\",{\"3\":{\"104\":1}}],[\"修改元素\",{\"0\":{\"104\":1,\"113\":1},\"2\":{\"104\":1,\"113\":1}}],[\"从路由中获取到上次浏览的位置\",{\"3\":{\"235\":1}}],[\"从路由参数中读取上次浏览的位置\",{\"3\":{\"235\":1}}],[\"从localstorage中读取上次浏览的位置\",{\"3\":{\"234\":1}}],[\"从而提前发现错误\",{\"3\":{\"246\":1}}],[\"从而解决了react在渲染过程中\",{\"3\":{\"208\":1}}],[\"从而实现数据从一端传到另一端\",{\"3\":{\"167\":2}}],[\"从组件渲染完成到组件卸载的过程\",{\"3\":{\"208\":1}}],[\"从组件开始渲染到组件渲染完成的过程\",{\"3\":{\"208\":1}}],[\"从组件实例化到组件渲染完成的过程\",{\"3\":{\"208\":1}}],[\"从当前元素开始往外查找\",{\"3\":{\"150\":1}}],[\"从根元素开始往下寻找\",{\"3\":{\"150\":1}}],[\"从start位置开始删除deletecount个\",{\"3\":{\"103\":1}}],[\"从上面的代码可以看出\",{\"3\":{\"76\":1}}],[\"从上述代码我们可以知道\",{\"3\":{\"4\":1}}],[\"删除数组开头的元素\",{\"3\":{\"103\":1}}],[\"删除数组末尾的元素\",{\"3\":{\"103\":1}}],[\"删除元素\",{\"0\":{\"103\":1,\"112\":1},\"2\":{\"103\":1,\"112\":1}}],[\"删除线等\",{\"3\":{\"25\":1}}],[\"增加元素\",{\"0\":{\"102\":1,\"111\":1},\"2\":{\"102\":1,\"111\":1}}],[\"增删改查\",{\"3\":{\"101\":1,\"110\":1}}],[\"四个方面来进行分类\",{\"3\":{\"101\":1}}],[\"互不影响\",{\"3\":{\"99\":1}}],[\"存储位置\",{\"0\":{\"99\":1},\"2\":{\"99\":1}}],[\"引擎会维护一个任务队列\",{\"3\":{\"138\":1}}],[\"引用数据类型的值是存储在堆内存中的\",{\"3\":{\"99\":1}}],[\"引用数据类型\",{\"0\":{\"93\":1},\"2\":{\"93\":1}}],[\"引申\",{\"0\":{\"149\":1,\"275\":1,\"276\":1,\"277\":1,\"278\":1},\"2\":{\"149\":1,\"275\":1,\"276\":1,\"277\":1,\"278\":1},\"3\":{\"3\":1,\"8\":1,\"12\":1,\"41\":1,\"61\":1,\"67\":1,\"140\":1,\"190\":1,\"202\":1,\"222\":1,\"226\":1}}],[\"空字符串\",{\"3\":{\"89\":1}}],[\"返回类型\",{\"3\":{\"189\":1,\"190\":1}}],[\"返回替换后的字符串\",{\"3\":{\"116\":1}}],[\"返回匹配到的第一个字符串的位置\",{\"3\":{\"116\":1}}],[\"返回匹配到的字符串数组\",{\"3\":{\"116\":1}}],[\"返回指定位置的字符\",{\"3\":{\"114\":1}}],[\"返回true\",{\"3\":{\"114\":1}}],[\"返回第一次出现的位置\",{\"3\":{\"114\":1}}],[\"返回第一个符合条件的元素\",{\"3\":{\"105\":1}}],[\"返回一个新的字符串\",{\"3\":{\"113\":1}}],[\"返回一个新数组\",{\"3\":{\"103\":1,\"107\":2}}],[\"返回一个值\",{\"3\":{\"107\":1}}],[\"返回一个布尔值\",{\"3\":{\"107\":2}}],[\"返回布尔值\",{\"3\":{\"105\":1}}],[\"返回\",{\"3\":{\"105\":1}}],[\"返回元素在数组中的位置\",{\"3\":{\"105\":1}}],[\"返回删除的元素\",{\"3\":{\"103\":2}}],[\"返回删除的元素组成的数组\",{\"3\":{\"102\":1,\"103\":1}}],[\"返回数组长度\",{\"3\":{\"102\":2}}],[\"返回新数组\",{\"3\":{\"102\":1}}],[\"返回nan\",{\"3\":{\"87\":1}}],[\"返回已经转化的数字\",{\"3\":{\"87\":1}}],[\"返回的都是一个新的string\",{\"3\":{\"112\":1}}],[\"返回的promise对象就会变为rejected状态\",{\"3\":{\"79\":1}}],[\"返回的promise对象就会变为resolved状态\",{\"3\":{\"79\":1}}],[\"返回的promise对象的状态就会跟随参数的promise对象的状态\",{\"3\":{\"79\":1}}],[\"返回的是一个对象\",{\"3\":{\"65\":1}}],[\"返回的是一个数组\",{\"3\":{\"64\":1}}],[\"布尔值转化为false的情况\",{\"3\":{\"89\":1}}],[\"布尔值\",{\"3\":{\"87\":1}}],[\"布局的主要思想是让容器有能力让其子元素改变自身的宽度\",{\"3\":{\"47\":1}}],[\"布局是一种一维布局模型\",{\"3\":{\"47\":1}}],[\"长度为\",{\"3\":{\"87\":1}}],[\"多个请求同时进行\",{\"3\":{\"85\":1}}],[\"多根轴线的对齐方式\",{\"3\":{\"49\":1}}],[\"你对mvvm的理解\",{\"3\":{\"85\":1}}],[\"你设置多大的width和height\",{\"3\":{\"21\":1}}],[\"节流和防抖\",{\"3\":{\"85\":1}}],[\"怎么比较的\",{\"3\":{\"85\":1}}],[\"怎样执行的\",{\"3\":{\"85\":1}}],[\"页面是如何缓存的\",{\"3\":{\"85\":1}}],[\"介绍一下项目\",{\"3\":{\"85\":1}}],[\"自动转化为数字除了+会转化为字符串\",{\"3\":{\"119\":1}}],[\"自动转化为字符串一般遇到+\",{\"3\":{\"119\":1}}],[\"自我介绍\",{\"3\":{\"85\":1}}],[\"自适应两栏布局\",{\"3\":{\"34\":1}}],[\"总的来说\",{\"3\":{\"84\":1}}],[\"总结来说\",{\"3\":{\"222\":1}}],[\"总结\",{\"0\":{\"10\":1,\"123\":1},\"2\":{\"10\":1,\"123\":1}}],[\"传递给事件处理函数的函数\",{\"3\":{\"222\":1}}],[\"传递参数给子组件\",{\"3\":{\"221\":1}}],[\"传递出去\",{\"3\":{\"83\":1}}],[\"传输层只是为应用层提供了端到端的通信\",{\"3\":{\"167\":1}}],[\"传输层有两个协议\",{\"3\":{\"165\":1}}],[\"传输层为两台主机上的应用程序提供端到端的通信\",{\"3\":{\"165\":1}}],[\"传输层\",{\"0\":{\"165\":1},\"2\":{\"165\":1}}],[\"传输层及以下是工作在操作系统的内核态\",{\"3\":{\"164\":1}}],[\"传输层会帮我们处理数据传输的细节\",{\"3\":{\"164\":1}}],[\"传参并指定回调执行函数为onback\",{\"3\":{\"15\":1}}],[\"虽然apply接受的参数是一个数组\",{\"3\":{\"83\":1}}],[\"虽然fn3被销毁了\",{\"3\":{\"4\":1}}],[\"我可以使用redux实现任意组件通信\",{\"3\":{\"226\":1}}],[\"我的理解是\",{\"3\":{\"83\":1}}],[\"我们采用懒加载的方式\",{\"3\":{\"240\":1}}],[\"我们采用分批次加载的方式\",{\"3\":{\"239\":1}}],[\"我们这个其实也可以使用intersectionobserver来实现\",{\"3\":{\"239\":1}}],[\"我们将window\",{\"3\":{\"239\":1}}],[\"我们就将滚动位置记录到localstorage中\",{\"3\":{\"235\":1}}],[\"我们就从localstorage中读取上次浏览的位置\",{\"3\":{\"235\":1}}],[\"我们就需要使用到变量提升的方式\",{\"3\":{\"224\":1}}],[\"我们使用useeffect来监听滚动事件\",{\"3\":{\"235\":1}}],[\"我们使用useeffect来监听路由参数id的变化\",{\"3\":{\"235\":1}}],[\"我们使用useparams来获取路由参数id\",{\"3\":{\"235\":1}}],[\"我们主要利用的就是window\",{\"3\":{\"234\":1}}],[\"我们通常在构造函数里初始化组件的状态对象\",{\"3\":{\"211\":1,\"215\":1}}],[\"我们需要保存一个定时器\",{\"3\":{\"206\":1}}],[\"我们需要使用其他的方法来隐藏元素\",{\"3\":{\"29\":1}}],[\"我们并不能确定数据是否传输成功\",{\"3\":{\"165\":1}}],[\"我们手机上的app\",{\"3\":{\"164\":1}}],[\"我们会使用遍历或者sort方法\",{\"3\":{\"83\":1}}],[\"我们也可以看一个稍微复杂一点的例子\",{\"3\":{\"82\":1}}],[\"我们可以认为setup是beforecreate和created的结合体\",{\"3\":{\"270\":1}}],[\"我们可以进行一些dom操作\",{\"3\":{\"265\":1}}],[\"我们可以这么理解\",{\"3\":{\"246\":1}}],[\"我们可以这么理解usecallback和usestate的关系\",{\"3\":{\"205\":1}}],[\"我们可以这么理解usememo和usestate的关系\",{\"3\":{\"204\":1}}],[\"我们可以采用骨架屏的方式\",{\"3\":{\"243\":1}}],[\"我们可以采用虚拟列表的方式\",{\"3\":{\"242\":1}}],[\"我们可以利用浏览器的缓存机制\",{\"3\":{\"241\":1}}],[\"我们可以借助react\",{\"3\":{\"240\":1,\"242\":1}}],[\"我们可以通过props\",{\"3\":{\"221\":1}}],[\"我们可以使用useparams来获取路由参数\",{\"3\":{\"235\":1}}],[\"我们可以使用useeffect来监听滚动事件\",{\"3\":{\"234\":1}}],[\"我们可以使用json\",{\"3\":{\"212\":1}}],[\"我们可以使用媒体查询来指定css的加载时机\",{\"3\":{\"41\":1}}],[\"我们可以将usestate设置出来的状态理解为自变量\",{\"3\":{\"204\":1,\"205\":1}}],[\"我们可以分析出\",{\"3\":{\"147\":1}}],[\"我们可以看出\",{\"3\":{\"71\":1}}],[\"我们可以去配置nginx来做反向代理\",{\"3\":{\"17\":1}}],[\"我们一般使用display\",{\"3\":{\"29\":1}}],[\"我们在客户端提前设置好一个函数\",{\"3\":{\"15\":1}}],[\"运算符\",{\"3\":{\"83\":1}}],[\"求数组的最大值和最小值\",{\"3\":{\"83\":1}}],[\"新数组中的元素是通过测试的元素\",{\"3\":{\"107\":1}}],[\"新的函数的this指向的是bind的第一个参数\",{\"3\":{\"83\":1}}],[\"新增了一个hook函数\",{\"3\":{\"217\":1}}],[\"新增\",{\"3\":{\"67\":2}}],[\"来比较两个对象\",{\"3\":{\"212\":1}}],[\"来获取dom元素\",{\"3\":{\"206\":1}}],[\"来标识\",{\"3\":{\"111\":2}}],[\"来直接改变\",{\"3\":{\"82\":1}}],[\"来隐藏元素\",{\"3\":{\"29\":1}}],[\"采用一些方法\",{\"3\":{\"82\":1}}],[\"谁先来的就跟着谁变化\",{\"3\":{\"79\":1}}],[\"兜底的作用\",{\"3\":{\"78\":1}}],[\"第一次渲染\",{\"0\":{\"279\":1},\"2\":{\"279\":1}}],[\"第一个参数\",{\"3\":{\"153\":1}}],[\"第一个参数是resolve的回调函数\",{\"3\":{\"76\":1,\"78\":1}}],[\"第二个元素是一个函数\",{\"3\":{\"200\":1}}],[\"第二个参数\",{\"3\":{\"153\":1}}],[\"第二个参数是reject的回调函数\",{\"3\":{\"76\":1,\"78\":1}}],[\"第三个参数\",{\"3\":{\"153\":1}}],[\"状态变为rejected\",{\"3\":{\"76\":1}}],[\"状态变为resolved\",{\"3\":{\"76\":1}}],[\"失败状态\",{\"3\":{\"77\":1}}],[\"失败\",{\"3\":{\"76\":1,\"79\":3}}],[\"失败的回调函数\",{\"3\":{\"76\":1,\"79\":7}}],[\"成功状态\",{\"3\":{\"77\":1}}],[\"成功\",{\"3\":{\"76\":1,\"79\":3}}],[\"成功的回调函数\",{\"3\":{\"76\":1,\"79\":7}}],[\"调用后\",{\"3\":{\"267\":1,\"273\":1}}],[\"调用时\",{\"3\":{\"266\":1,\"272\":1}}],[\"调用父类的构造函数\",{\"3\":{\"159\":1,\"160\":2}}],[\"调用的地方\",{\"3\":{\"145\":1}}],[\"调用race\",{\"3\":{\"79\":1}}],[\"调用\",{\"3\":{\"76\":1,\"79\":2}}],[\"模板匹配方法\",{\"0\":{\"116\":1},\"2\":{\"116\":1}}],[\"模板字符串是增强版的字符串\",{\"3\":{\"62\":1}}],[\"模板字符串\",{\"0\":{\"62\":1},\"2\":{\"62\":1},\"3\":{\"111\":1}}],[\"模块化\",{\"0\":{\"74\":1},\"2\":{\"74\":1}}],[\"添加静态方法\",{\"3\":{\"160\":1}}],[\"添加原型方法\",{\"3\":{\"160\":1}}],[\"添加方法\",{\"3\":{\"72\":2}}],[\"添加下划线\",{\"3\":{\"25\":1}}],[\"本质上还是\",{\"3\":{\"71\":1}}],[\"实现\",{\"0\":{\"182\":1},\"2\":{\"182\":1}}],[\"实现方法\",{\"3\":{\"159\":1}}],[\"实现数组的拼接\",{\"3\":{\"83\":1}}],[\"实现http缓存的方式有很多\",{\"3\":{\"7\":1}}],[\"实例仍然完全可用\",{\"3\":{\"267\":1,\"273\":1}}],[\"实例的属性和方法的运算都不能访问到data\",{\"3\":{\"264\":1}}],[\"实例后加载\",{\"3\":{\"183\":1}}],[\"实例先加载\",{\"3\":{\"183\":1}}],[\"实例\",{\"0\":{\"183\":1},\"2\":{\"183\":1},\"3\":{\"183\":2}}],[\"实例方法\",{\"0\":{\"78\":1},\"2\":{\"78\":1}}],[\"实例化\",{\"3\":{\"70\":1,\"71\":1,\"72\":2,\"159\":3,\"160\":1}}],[\"具有可迭代性的对象\",{\"3\":{\"67\":1}}],[\"具体可以参考javascript\",{\"3\":{\"118\":1}}],[\"具体参考\",{\"3\":{\"61\":1,\"73\":1,\"222\":1}}],[\"具体流程如下\",{\"3\":{\"9\":1,\"16\":1}}],[\"都能够达到控制元素显示隐藏的效果\",{\"3\":{\"256\":1}}],[\"都需要提升到父组件\",{\"3\":{\"223\":1}}],[\"都需要对象具有可迭代性\",{\"3\":{\"67\":1}}],[\"都是用来缓存组件的\",{\"3\":{\"277\":1}}],[\"都是借助react的class组件来实现的\",{\"3\":{\"217\":1}}],[\"都是应用层的东西\",{\"3\":{\"164\":1}}],[\"都当做一个参数\",{\"3\":{\"83\":1}}],[\"都会调用changename函数\",{\"3\":{\"222\":1}}],[\"都会执行\",{\"3\":{\"78\":1}}],[\"都会重新定义一个timmer\",{\"3\":{\"206\":1}}],[\"都会重新定义\",{\"3\":{\"5\":1}}],[\"进入可视区域就会触发回调函数\",{\"3\":{\"240\":1}}],[\"进行深拷贝\",{\"3\":{\"67\":1}}],[\"进程\",{\"3\":{\"8\":1}}],[\"字符串或正则表达式\",{\"3\":{\"275\":2}}],[\"字符串转换为数字\",{\"3\":{\"121\":1}}],[\"字符串转数组\",{\"3\":{\"67\":1}}],[\"字符串拼接\",{\"3\":{\"111\":1}}],[\"字符串常用方法\",{\"1\":{\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"116\":1,\"117\":1}}],[\"字符串\",{\"3\":{\"67\":1,\"275\":1}}],[\"字体类\",{\"3\":{\"25\":1}}],[\"与解构赋值结合\",{\"3\":{\"67\":1}}],[\"扩展运算符以及for\",{\"3\":{\"67\":1}}],[\"扩展运算符是三个点\",{\"3\":{\"67\":1}}],[\"扩展运算符\",{\"0\":{\"67\":1},\"2\":{\"67\":1}}],[\"keep\",{\"0\":{\"275\":1,\"277\":1,\"278\":1},\"2\":{\"275\":1,\"277\":1,\"278\":1},\"3\":{\"275\":4,\"277\":2}}],[\"keyof\",{\"3\":{\"253\":2}}],[\"key\",{\"3\":{\"189\":5,\"191\":1}}],[\"keyup\",{\"3\":{\"148\":1}}],[\"keypress\",{\"3\":{\"148\":1}}],[\"keydown\",{\"3\":{\"148\":1}}],[\"k\",{\"3\":{\"64\":1}}],[\"剩余运算符只能放在最后一位\",{\"3\":{\"64\":1,\"65\":1}}],[\"剩余运算符\",{\"3\":{\"64\":1,\"65\":1}}],[\"数据操作\",{\"3\":{\"264\":1}}],[\"数据观测和事件配置之前被调用\",{\"3\":{\"264\":1}}],[\"数据使用state或者redux来管理\",{\"3\":{\"228\":1}}],[\"数据\",{\"3\":{\"206\":1,\"216\":2}}],[\"数据包会被封装为帧吗\",{\"3\":{\"175\":1}}],[\"数据会经过很多的路由器\",{\"3\":{\"167\":1}}],[\"数据类型\",{\"3\":{\"118\":1}}],[\"数据类型的存储位置\",{\"3\":{\"99\":1}}],[\"数字\",{\"3\":{\"89\":1}}],[\"数组中传入的值\",{\"3\":{\"201\":1}}],[\"数组中的每一项都是一个promise对象\",{\"3\":{\"79\":2}}],[\"数组本身就是一个特殊的对象\",{\"3\":{\"157\":1}}],[\"数组的原型链\",{\"0\":{\"157\":1},\"1\":{\"155\":1,\"156\":1,\"157\":1,\"158\":1},\"2\":{\"157\":1}}],[\"数组的解构赋值\",{\"0\":{\"64\":1},\"2\":{\"64\":1}}],[\"数组转化为字符串\",{\"3\":{\"108\":1}}],[\"数组常用方法\",{\"1\":{\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"107\":1,\"108\":1,\"109\":1}}],[\"数组是怎么遍历的\",{\"3\":{\"85\":1}}],[\"数组\",{\"3\":{\"67\":1}}],[\"数组合并\",{\"3\":{\"67\":1}}],[\"数值越小\",{\"3\":{\"50\":1}}],[\"解决方案\",{\"0\":{\"233\":1,\"238\":1},\"2\":{\"233\":1,\"238\":1}}],[\"解构不成功\",{\"3\":{\"64\":1}}],[\"解构赋值是对赋值运算符的扩展\",{\"3\":{\"63\":1}}],[\"解构赋值\",{\"0\":{\"63\":1},\"2\":{\"63\":1}}],[\"解析完毕后\",{\"3\":{\"38\":1}}],[\"years\",{\"3\":{\"62\":2,\"70\":2,\"71\":2,\"72\":4,\"159\":5,\"160\":3}}],[\"yellow\",{\"3\":{\"52\":1}}],[\"$el属性可以访问\",{\"3\":{\"265\":1,\"271\":1}}],[\"$router\",{\"3\":{\"235\":1}}],[\"$route\",{\"3\":{\"235\":1}}],[\"$typeof\",{\"3\":{\"189\":2}}],[\"$\",{\"3\":{\"62\":2,\"70\":2,\"71\":2,\"72\":4,\"159\":6,\"160\":2,\"235\":2}}],[\"`scrollposition\",{\"3\":{\"235\":2}}],[\"``\",{\"3\":{\"111\":1}}],[\"`my\",{\"3\":{\"62\":1,\"70\":1,\"71\":1,\"72\":2,\"159\":3,\"160\":1}}],[\"`\",{\"3\":{\"62\":2,\"70\":1,\"71\":1,\"72\":2,\"159\":3,\"160\":1,\"235\":2}}],[\"用户体验不好\",{\"3\":{\"237\":1}}],[\"用户体验不好的问题\",{\"3\":{\"208\":1}}],[\"用于性能优化\",{\"3\":{\"215\":1,\"216\":1}}],[\"用于计算当前的状态\",{\"3\":{\"208\":1}}],[\"用于标识这个任务的优先级\",{\"3\":{\"191\":1}}],[\"用于标识这个\",{\"3\":{\"191\":12}}],[\"用于标识这个元素或者组件的\",{\"3\":{\"189\":1}}],[\"用于标识这个元素的属性\",{\"3\":{\"189\":1}}],[\"用于标识这个元素的\",{\"3\":{\"189\":1}}],[\"用于标识这个元素的类型\",{\"3\":{\"189\":2}}],[\"用于标识这是一个\",{\"3\":{\"189\":2}}],[\"用padstring填充字符串\",{\"3\":{\"113\":1}}],[\"用什么\",{\"3\":{\"85\":1}}],[\"用反引号\",{\"3\":{\"62\":1}}],[\"用来控制元素的\",{\"3\":{\"259\":2}}],[\"用来接收参数\",{\"3\":{\"71\":1}}],[\"用来检测媒体类型的特性\",{\"3\":{\"42\":1}}],[\"用来指定资源的过期时间\",{\"3\":{\"8\":2}}],[\"包括自己\",{\"3\":{\"121\":1}}],[\"包括嵌套的p元素\",{\"3\":{\"23\":1}}],[\"包含从start到end\",{\"3\":{\"103\":1}}],[\"包含了函数的所有参数\",{\"3\":{\"61\":1}}],[\"指向创建它的构造函数的原型对象\",{\"3\":{\"156\":2}}],[\"指向函数本身\",{\"3\":{\"155\":1}}],[\"指向谁\",{\"3\":{\"145\":1}}],[\"指向存储在堆内存中的对象\",{\"3\":{\"99\":1}}],[\"指向问题\",{\"3\":{\"61\":1}}],[\"指向的是函数使用时所在的对象\",{\"3\":{\"61\":1}}],[\"指定媒体类型\",{\"3\":{\"42\":1}}],[\"指定资源的过期时间\",{\"3\":{\"8\":1}}],[\"形式\",{\"3\":{\"61\":1}}],[\"箭头函数没有arguments\",{\"3\":{\"61\":1}}],[\"箭头函数没有this\",{\"3\":{\"61\":1}}],[\"箭头函数\",{\"0\":{\"61\":1},\"2\":{\"61\":1}}],[\"重新获取数据等等\",{\"3\":{\"280\":1}}],[\"重新获取请求结果\",{\"3\":{\"10\":1}}],[\"重复字符串\",{\"3\":{\"113\":1}}],[\"重复声明\",{\"0\":{\"59\":1},\"2\":{\"59\":1}}],[\"报错\",{\"3\":{\"58\":2,\"59\":2,\"60\":1,\"61\":1,\"159\":1}}],[\"上述介绍的所有生命周期钩子\",{\"3\":{\"217\":1}}],[\"上述代码表明\",{\"3\":{\"57\":1}}],[\"上面的代码表明\",{\"3\":{\"60\":1,\"82\":2}}],[\"上面这段代码表明\",{\"3\":{\"58\":3,\"59\":2}}],[\"临时死亡区就是代码块的起始位置到变量声明的位置\",{\"3\":{\"58\":1}}],[\"临时死亡区\",{\"0\":{\"58\":1},\"2\":{\"58\":1}}],[\"仅在当前这个作用域生效\",{\"3\":{\"57\":1}}],[\"9ec5e242\",{\"0\":{\"228\":1,\"229\":1,\"230\":1}}],[\"9\",{\"3\":{\"57\":2}}],[\"96英寸\",{\"3\":{\"27\":1}}],[\"函数组件并没有继承\",{\"3\":{\"218\":1}}],[\"函数组件不能使用this关键字\",{\"3\":{\"198\":1}}],[\"函数组件没有生命周期钩子\",{\"3\":{\"198\":1}}],[\"函数组件没有自己的状态\",{\"3\":{\"197\":1,\"198\":1}}],[\"函数组件只能接收props\",{\"3\":{\"197\":1}}],[\"函数组件是一个函数\",{\"3\":{\"197\":1}}],[\"函数组件\",{\"0\":{\"197\":1},\"2\":{\"197\":1}}],[\"函数是一个\",{\"3\":{\"190\":1}}],[\"函数\",{\"2\":{\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1,\"206\":1,\"218\":1},\"3\":{\"190\":1}}],[\"函数fn1的作用域是foo的作用域\",{\"3\":{\"147\":1}}],[\"函数foo的作用域是全局作用域\",{\"3\":{\"145\":1,\"147\":1}}],[\"函数bar的作用域是全局作用域\",{\"3\":{\"145\":1}}],[\"函数的解构赋值其实是针对于函数的参数而言的\",{\"3\":{\"66\":1}}],[\"函数的解构赋值\",{\"0\":{\"66\":1},\"2\":{\"66\":1}}],[\"函数作用域\",{\"3\":{\"57\":2,\"143\":1}}],[\"函数可以访问其声明外部的函数的作用域\",{\"3\":{\"4\":1}}],[\"块级作用域\",{\"3\":{\"57\":2,\"143\":1}}],[\"全局作用域\",{\"3\":{\"57\":2,\"143\":1,\"145\":3,\"147\":2}}],[\"左右两边固定宽度\",{\"3\":{\"52\":1}}],[\"三栏布局\",{\"0\":{\"52\":1},\"2\":{\"52\":1},\"3\":{\"52\":1}}],[\"且会根据剩余空间的大小进行放大\",{\"3\":{\"50\":1}}],[\"且很重要\",{\"3\":{\"50\":1}}],[\"场景题\",{\"1\":{\"231\":1}}],[\"场景\",{\"0\":{\"181\":1,\"232\":1,\"237\":1},\"2\":{\"181\":1,\"232\":1,\"237\":1},\"3\":{\"50\":1,\"202\":1}}],[\"基于构造函数继承\",{\"3\":{\"159\":1}}],[\"基于原型链的继承\",{\"3\":{\"159\":1}}],[\"基本数据类型的值是存储在栈内存中的\",{\"3\":{\"99\":1}}],[\"基本数据类型\",{\"0\":{\"86\":1},\"2\":{\"86\":1}}],[\"基本类型怎么进行拷贝的\",{\"3\":{\"85\":1}}],[\"基准值为\",{\"3\":{\"50\":1}}],[\"基础概念\",{\"0\":{\"47\":1},\"2\":{\"47\":1}}],[\"缩小比例为\",{\"3\":{\"50\":1}}],[\"缩小\",{\"3\":{\"50\":1}}],[\"放大比例为\",{\"3\":{\"50\":1}}],[\"放大\",{\"3\":{\"50\":2}}],[\"放在\",{\"2\":{\"40\":1}}],[\"放在head标签中\",{\"0\":{\"40\":1}}],[\"相关的render函数首次被调用\",{\"3\":{\"265\":1,\"271\":1}}],[\"相同点\",{\"0\":{\"256\":1},\"2\":{\"256\":1},\"3\":{\"277\":1}}],[\"相当于person\",{\"3\":{\"160\":1}}],[\"相当于将父类的实例复制了一份给了子类\",{\"3\":{\"159\":1}}],[\"相当于flex\",{\"3\":{\"50\":3}}],[\"相对于显示器的分辨率\",{\"3\":{\"27\":1}}],[\"后两个属性可选\",{\"3\":{\"50\":1}}],[\"后代选择器\",{\"3\":{\"23\":2}}],[\"项目复盘\",{\"1\":{\"180\":1}}],[\"项目中你如何做的\",{\"3\":{\"85\":1}}],[\"项目占据的主轴空间\",{\"3\":{\"50\":1}}],[\"项目属性\",{\"0\":{\"50\":1},\"2\":{\"50\":1}}],[\"定义\",{\"3\":{\"275\":1}}],[\"定义子类\",{\"3\":{\"159\":3,\"160\":1}}],[\"定义父类的方法\",{\"3\":{\"159\":1}}],[\"定义父类\",{\"3\":{\"159\":1,\"160\":1}}],[\"定义一个\",{\"3\":{\"76\":1,\"79\":3}}],[\"定义方法\",{\"3\":{\"70\":1,\"159\":1}}],[\"定义构造函数\",{\"3\":{\"70\":1}}],[\"定义类\",{\"0\":{\"69\":1},\"2\":{\"69\":1}}],[\"定义在分配多余空间之前\",{\"3\":{\"50\":1}}],[\"定义项目的缩小比例\",{\"3\":{\"50\":1}}],[\"定义项目的放大比例\",{\"3\":{\"50\":1}}],[\"定义项目的排列顺序\",{\"3\":{\"50\":1}}],[\"决定元素是否换行\",{\"3\":{\"49\":1}}],[\"决定主轴的方向\",{\"3\":{\"49\":1}}],[\"容器属性\",{\"0\":{\"49\":1},\"2\":{\"49\":1}}],[\"属性设置为\",{\"3\":{\"258\":2}}],[\"属性来实现的\",{\"3\":{\"258\":1}}],[\"属性\",{\"0\":{\"48\":1},\"2\":{\"48\":1},\"3\":{\"155\":2,\"156\":2,\"189\":2,\"206\":1,\"259\":3}}],[\"属性选择器\",{\"3\":{\"23\":1,\"24\":1}}],[\"以后每次接收到新的props之后都会被调用\",{\"3\":{\"215\":1}}],[\"以最适合当前的显示环境\",{\"3\":{\"47\":1}}],[\"以及对齐方式等\",{\"3\":{\"47\":1}}],[\"顺序\",{\"3\":{\"47\":1}}],[\"高度\",{\"3\":{\"47\":1,\"239\":1}}],[\"预加载\",{\"3\":{\"45\":1}}],[\"作用域链的场景\",{\"0\":{\"146\":1},\"2\":{\"146\":1}}],[\"作用域链\",{\"0\":{\"144\":1},\"1\":{\"143\":1,\"144\":1,\"145\":1,\"146\":1,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"151\":1,\"152\":1,\"153\":1,\"154\":1},\"2\":{\"144\":1}}],[\"作用域链分类\",{\"0\":{\"143\":1},\"2\":{\"143\":1}}],[\"作用域分类\",{\"3\":{\"57\":1}}],[\"作用域就是变量和函数的可访问范围\",{\"3\":{\"57\":1}}],[\"作用域补充\",{\"0\":{\"57\":1},\"2\":{\"57\":1}}],[\"作用域\",{\"0\":{\"56\":1},\"2\":{\"56\":1}}],[\"作用就是\",{\"3\":{\"45\":1}}],[\"作为\",{\"3\":{\"4\":1}}],[\"动态样式\",{\"3\":{\"43\":1}}],[\"至多是60em\",{\"3\":{\"42\":2}}],[\"至多多少\",{\"3\":{\"42\":1}}],[\"至少多少\",{\"3\":{\"42\":1}}],[\"最后\",{\"3\":{\"235\":1}}],[\"最后一次修改时间\",{\"3\":{\"9\":1}}],[\"最早可以获取到真实\",{\"3\":{\"211\":1}}],[\"最先被执行\",{\"3\":{\"211\":1,\"215\":1}}],[\"最小宽度\",{\"3\":{\"42\":1}}],[\"最大宽度\",{\"3\":{\"42\":1}}],[\"简单理解为参数列表\",{\"3\":{\"61\":1}}],[\"简单来说\",{\"3\":{\"42\":1,\"79\":1,\"215\":1,\"216\":1,\"228\":1,\"229\":1}}],[\"简单易用\",{\"3\":{\"15\":1}}],[\"媒体查询的使用场景\",{\"0\":{\"43\":1},\"2\":{\"43\":1}}],[\"媒体查询的语法如下\",{\"3\":{\"42\":1}}],[\"媒体查询表达式\",{\"3\":{\"42\":1}}],[\"媒体查询就是一种检测浏览器或设备特性的方法\",{\"3\":{\"42\":1}}],[\"媒体查询\",{\"0\":{\"42\":1},\"2\":{\"42\":1},\"3\":{\"41\":1}}],[\"一直往下查找\",{\"3\":{\"153\":1}}],[\"一直往外查找\",{\"3\":{\"152\":1}}],[\"一直找到根元素为止\",{\"3\":{\"150\":1}}],[\"一直找到目标元素\",{\"3\":{\"150\":1}}],[\"一直会阻塞渲染\",{\"3\":{\"41\":1}}],[\"一个大量数据的列表\",{\"3\":{\"148\":1}}],[\"一种是微任务\",{\"3\":{\"140\":1}}],[\"一种是宏任务\",{\"3\":{\"140\":1}}],[\"一种是异步任务\",{\"3\":{\"138\":1}}],[\"一种是同步任务\",{\"3\":{\"138\":1}}],[\"一方是string\",{\"3\":{\"121\":1}}],[\"一一对应\",{\"3\":{\"64\":1,\"65\":1}}],[\"一般不需要使用extends\",{\"3\":{\"252\":1}}],[\"一般需要使用extends\",{\"3\":{\"252\":1}}],[\"一般我们会进行一些全局的配置\",{\"3\":{\"264\":1}}],[\"一般我们会使用变量提升\",{\"3\":{\"223\":1}}],[\"一般我们会将useref和ref结合使用\",{\"3\":{\"206\":1}}],[\"一般都是使用\",{\"3\":{\"221\":1}}],[\"一般都是先匹配网络号\",{\"3\":{\"167\":1}}],[\"一般都是将他直接缓存在浏览器的缓存目录下\",{\"3\":{\"45\":1}}],[\"一般使用slice\",{\"3\":{\"104\":1}}],[\"一般typeof\",{\"3\":{\"91\":1}}],[\"一般会简写\",{\"3\":{\"50\":1}}],[\"一般会在场景题里面出现\",{\"3\":{\"5\":1}}],[\"一般情况下\",{\"3\":{\"27\":2,\"148\":1}}],[\"一般在项目中\",{\"3\":{\"17\":1}}],[\"宽度至少是40em\",{\"3\":{\"41\":1,\"42\":4}}],[\"宽高度\",{\"3\":{\"25\":1}}],[\"只涉及css的变化\",{\"3\":{\"259\":1}}],[\"只渲染可视区域的文章\",{\"3\":{\"242\":1}}],[\"只负责渲染组件\",{\"3\":{\"211\":1,\"215\":1}}],[\"只是一个用于引用\",{\"3\":{\"206\":1}}],[\"只是这种数组\",{\"3\":{\"110\":1}}],[\"只不过usecallback函数返回的是一个函数\",{\"3\":{\"205\":1}}],[\"只指定一个事件处理程序\",{\"3\":{\"148\":1}}],[\"只有匹配的组件会被缓存\",{\"3\":{\"275\":1}}],[\"只有在组件切换时才会触发activated和deactivated这两个生命周期钩子函数\",{\"3\":{\"275\":1}}],[\"只有在组件更新的时候才会被调用\",{\"3\":{\"216\":1}}],[\"只有在这些值发生改变的时候\",{\"3\":{\"201\":1}}],[\"只有箭头函数\",{\"3\":{\"145\":1}}],[\"只有所有元素都通过测试\",{\"3\":{\"107\":1}}],[\"只能三选一\",{\"3\":{\"275\":1}}],[\"只能返回一个顶级元素\",{\"3\":{\"211\":1}}],[\"只能通过this\",{\"3\":{\"211\":1}}],[\"只能同时执行一个任务\",{\"3\":{\"137\":1}}],[\"只能将字符串转化为数字\",{\"3\":{\"87\":1}}],[\"只考虑了普通object情况\",{\"3\":{\"127\":1}}],[\"只读\",{\"3\":{\"110\":1}}],[\"只可以转化纯数字字符串或者空字符串\",{\"3\":{\"87\":1}}],[\"只要因变量改变\",{\"3\":{\"204\":1,\"205\":1}}],[\"只要自变量改变\",{\"3\":{\"204\":1,\"205\":1}}],[\"只要主线程空闲\",{\"3\":{\"139\":1}}],[\"只要有一个元素通过测试\",{\"3\":{\"107\":1}}],[\"只要数组的某一个promise对象变为resolved状态\",{\"3\":{\"79\":1}}],[\"只要不在函数内部或者在大括号内的都是全局作用域\",{\"3\":{\"57\":1}}],[\"只在打印内容时适用\",{\"3\":{\"41\":1}}],[\"只支持冒泡阶段\",{\"3\":{\"152\":1}}],[\"只支持\",{\"3\":{\"15\":1}}],[\"再将loading状态设置为false\",{\"3\":{\"243\":1}}],[\"再将字符串转换为对象\",{\"3\":{\"128\":1}}],[\"再渲染文章\",{\"3\":{\"243\":1}}],[\"再渲染可视区域的文章\",{\"3\":{\"242\":1}}],[\"再加载图片\",{\"3\":{\"240\":1}}],[\"再加载下一批数据\",{\"3\":{\"239\":1}}],[\"再加载首页的数据\",{\"3\":{\"181\":1}}],[\"再次打开页面时\",{\"3\":{\"232\":1}}],[\"再挂载\",{\"3\":{\"183\":1}}],[\"再跳转到首页\",{\"3\":{\"181\":1}}],[\"再匹配主机号\",{\"3\":{\"167\":1}}],[\"再进行值的比较\",{\"3\":{\"122\":1,\"123\":1}}],[\"再进行比较\",{\"3\":{\"121\":3,\"123\":1}}],[\"再举一个例子\",{\"3\":{\"61\":1}}],[\"再去渲染dom树\",{\"3\":{\"38\":1}}],[\"再继续生成dom树\",{\"3\":{\"38\":1}}],[\"再继续解析html\",{\"3\":{\"37\":1}}],[\"再存入浏览器缓存中\",{\"3\":{\"10\":1}}],[\"等待事件冒泡\",{\"3\":{\"148\":1}}],[\"等待主线程的空闲时间来执行\",{\"3\":{\"138\":1}}],[\"等待状态\",{\"3\":{\"77\":1}}],[\"等于==属于比较运算符\",{\"3\":{\"121\":1}}],[\"等于vs完全等于\",{\"1\":{\"121\":1,\"122\":1,\"123\":1,\"124\":1}}],[\"等于\",{\"0\":{\"121\":1},\"2\":{\"121\":1},\"3\":{\"106\":1}}],[\"等\",{\"3\":{\"89\":1,\"189\":1,\"190\":1}}],[\"等css加载完毕后\",{\"3\":{\"37\":1,\"38\":1}}],[\"等到执行栈中的代码执行完毕后\",{\"3\":{\"5\":1}}],[\"6cfad872\",{\"0\":{\"162\":1}}],[\"66e2f8be\",{\"0\":{\"86\":1,\"87\":1,\"88\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1,\"96\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1}}],[\"6\",{\"3\":{\"57\":2,\"67\":2,\"83\":4,\"141\":5}}],[\"600px\",{\"3\":{\"52\":1}}],[\"60em\",{\"3\":{\"42\":2}}],[\"6237d1b1\",{\"0\":{\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"41\":1,\"42\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":1}}],[\"6e32d892\",{\"0\":{\"29\":1,\"30\":1}}],[\"743faa02\",{\"0\":{\"255\":1}}],[\"74376a60\",{\"0\":{\"81\":1}}],[\"74368525\",{\"0\":{\"36\":1}}],[\"7\",{\"1\":{\"85\":1},\"3\":{\"57\":2,\"79\":2,\"141\":4}}],[\"75c3ec6e\",{\"0\":{\"27\":1,\"28\":1}}],[\"防止margin塌陷\",{\"3\":{\"34\":1}}],[\"浮动元素会参与高度计算\",{\"3\":{\"33\":1}}],[\"浮动元素\",{\"3\":{\"32\":1}}],[\"根域名服务器会返回一个ip地址\",{\"3\":{\"172\":1}}],[\"根元素或包含根元素的元素<html>\",{\"3\":{\"32\":1}}],[\"根据不同的设备\",{\"3\":{\"43\":1}}],[\"根据不同的设备特性\",{\"3\":{\"43\":1}}],[\"根据根元素html的font\",{\"3\":{\"27\":1}}],[\"根据当前盒子的父元素的font\",{\"3\":{\"27\":1}}],[\"根据上述代码进行分析\",{\"3\":{\"4\":1}}],[\"使其长度为targetlength\",{\"3\":{\"113\":1}}],[\"使内外元素的定位不会相互影响\",{\"3\":{\"31\":1}}],[\"使用路由参数\",{\"0\":{\"235\":1},\"2\":{\"235\":1}}],[\"使用场景\",{\"3\":{\"221\":1,\"222\":1}}],[\"使用call\",{\"3\":{\"159\":1}}],[\"使用的ref从dom中获取元素的值\",{\"3\":{\"229\":1}}],[\"使用的是addeventlistener这种方式绑定事件\",{\"3\":{\"153\":1}}],[\"使用的是onclick这种方式绑定事件\",{\"3\":{\"152\":1}}],[\"使用的什么库\",{\"3\":{\"85\":1}}],[\"使用==进行比较的时候\",{\"3\":{\"134\":1}}],[\"使用反引号\",{\"3\":{\"111\":1}}],[\"使用剩余运算符\",{\"3\":{\"66\":1}}],[\"使用省略号\",{\"3\":{\"64\":1,\"65\":1}}],[\"使用preload和prefetch\",{\"0\":{\"45\":1}}],[\"使用内联样式\",{\"0\":{\"44\":1},\"2\":{\"44\":1}}],[\"使用媒体查询\",{\"0\":{\"41\":1},\"2\":{\"41\":1}}],[\"使用abcd法则计算权重\",{\"3\":{\"24\":1}}],[\"使用定时器时\",{\"3\":{\"3\":1}}],[\"使用闭包时\",{\"3\":{\"3\":1}}],[\"使用\",{\"0\":{\"183\":1,\"234\":1},\"2\":{\"45\":1,\"183\":1,\"234\":1},\"3\":{\"3\":1,\"72\":1,\"190\":1,\"225\":2}}],[\"使用全局变量\",{\"3\":{\"2\":1}}],[\"让处于\",{\"3\":{\"31\":1}}],[\"设置别名\",{\"3\":{\"65\":1}}],[\"设置默认值\",{\"3\":{\"64\":1,\"65\":1,\"66\":1}}],[\"设置打印样式\",{\"3\":{\"43\":1}}],[\"设置元素不显示\",{\"3\":{\"30\":1}}],[\"设置元素高度为\",{\"3\":{\"30\":1}}],[\"设置绝对定位\",{\"3\":{\"30\":1}}],[\"设置z\",{\"3\":{\"30\":1}}],[\"设置透明度为\",{\"3\":{\"30\":1}}],[\"设置可见性为隐藏\",{\"3\":{\"30\":1}}],[\"设置响应体\",{\"3\":{\"16\":1}}],[\"设置响应头\",{\"3\":{\"16\":3}}],[\"常见的上下文\",{\"3\":{\"202\":1}}],[\"常见的深拷贝方法\",{\"0\":{\"128\":1},\"2\":{\"128\":1}}],[\"常见的浅拷贝方法\",{\"0\":{\"126\":1},\"2\":{\"126\":1}}],[\"常见的隐藏元素的方法有以下几种\",{\"3\":{\"30\":1}}],[\"常见布局\",{\"0\":{\"51\":1},\"2\":{\"51\":1}}],[\"常用的有以下几个\",{\"3\":{\"8\":1}}],[\"z\",{\"3\":{\"29\":1,\"30\":1}}],[\"否则会导致组件陷入死循环\",{\"3\":{\"216\":1}}],[\"否则返回false\",{\"3\":{\"114\":1}}],[\"否则返回\",{\"3\":{\"114\":1}}],[\"否则就报错\",{\"3\":{\"13\":1}}],[\"否\",{\"3\":{\"29\":10}}],[\"区别\",{\"0\":{\"29\":1},\"2\":{\"29\":1}}],[\"百分比\",{\"3\":{\"27\":1}}],[\"像素点\",{\"3\":{\"27\":1}}],[\"单位\",{\"0\":{\"27\":1},\"2\":{\"27\":1}}],[\"单位是秒\",{\"3\":{\"8\":1}}],[\"背景类\",{\"3\":{\"25\":1}}],[\"边框\",{\"3\":{\"25\":1}}],[\"边框和外边距\",{\"3\":{\"19\":1}}],[\"外边距\",{\"3\":{\"25\":1}}],[\"垂直对齐方式\",{\"3\":{\"25\":1}}],[\"其他\",{\"0\":{\"268\":1,\"274\":1},\"2\":{\"268\":1,\"274\":1}}],[\"其他都是转为数字\",{\"3\":{\"119\":1}}],[\"其他情况都是转化为true\",{\"3\":{\"89\":1}}],[\"其他的都是可以继承的\",{\"3\":{\"25\":1}}],[\"其实vue2和vue3的生命周期并没有太大的区别\",{\"3\":{\"283\":1}}],[\"其实我们可以设置一个loading状态\",{\"3\":{\"243\":1}}],[\"其实就是\",{\"3\":{\"223\":1}}],[\"其实就是进行正则匹配的方法\",{\"3\":{\"116\":1}}],[\"其实对于函数组件来说\",{\"3\":{\"221\":1}}],[\"其实严格来说\",{\"3\":{\"218\":1}}],[\"其实usecallback函数和usememo函数的实现原理是一样的\",{\"3\":{\"205\":1}}],[\"其实可以将usememo理解为vue中的计算属性\",{\"3\":{\"204\":1}}],[\"其实可以将字符串看作是一种string\",{\"3\":{\"110\":1}}],[\"其实\",{\"3\":{\"140\":1}}],[\"其实日常开发中\",{\"3\":{\"29\":1}}],[\"其实只要记录一些比较特殊的不可继承属性就可以了\",{\"3\":{\"25\":1}}],[\"其中\",{\"3\":{\"9\":1}}],[\"列表可视区域的宽度\",{\"3\":{\"242\":1}}],[\"列表可视区域的高度\",{\"3\":{\"242\":1}}],[\"列表项的高度\",{\"3\":{\"242\":1}}],[\"列表项的数量\",{\"3\":{\"242\":1}}],[\"列表项标记的图像\",{\"3\":{\"25\":1}}],[\"列表项标记的位置\",{\"3\":{\"25\":1}}],[\"列表项标记的类型\",{\"3\":{\"25\":1}}],[\"列表不是很大\",{\"3\":{\"148\":1}}],[\"列表类\",{\"3\":{\"25\":1}}],[\"表单元素的值也会跟着变化\",{\"3\":{\"228\":1}}],[\"表单元素的值被\",{\"3\":{\"228\":1,\"229\":1}}],[\"表明\",{\"3\":{\"50\":4}}],[\"表示当前元素的子元素\",{\"3\":{\"189\":1,\"190\":1}}],[\"表示元素的属性\",{\"3\":{\"189\":1,\"190\":1}}],[\"表示元素的类型\",{\"3\":{\"189\":1,\"190\":1}}],[\"表示一个空对象\",{\"3\":{\"133\":1}}],[\"表示是否找到了元素\",{\"3\":{\"105\":1}}],[\"表示只匹配媒体类型的情况\",{\"3\":{\"42\":1}}],[\"表示不匹配媒体类型的情况\",{\"3\":{\"42\":1}}],[\"表示的是资源的唯一标识\",{\"3\":{\"9\":1}}],[\"表示的是时间\",{\"3\":{\"9\":1}}],[\"表格边框是否合并\",{\"3\":{\"25\":1}}],[\"表格的布局方式\",{\"3\":{\"25\":1}}],[\"表格标题的位置\",{\"3\":{\"25\":1}}],[\"表格类\",{\"3\":{\"25\":1}}],[\"元素本身所控制\",{\"3\":{\"229\":2}}],[\"元素本身来管理的组件\",{\"3\":{\"229\":1}}],[\"元素的钩子\",{\"3\":{\"211\":1}}],[\"元素的\",{\"3\":{\"206\":1}}],[\"元素的类型\",{\"3\":{\"189\":1}}],[\"元素转化为\",{\"0\":{\"191\":1},\"2\":{\"191\":1}}],[\"元素\",{\"0\":{\"188\":1},\"2\":{\"188\":1},\"3\":{\"186\":1,\"189\":4,\"190\":1,\"191\":5,\"211\":2,\"212\":2,\"216\":1}}],[\"元素不占据空间\",{\"3\":{\"30\":2}}],[\"元素可见\",{\"3\":{\"29\":1}}],[\"元素可见性\",{\"3\":{\"25\":1}}],[\"元素可点击\",{\"3\":{\"29\":1}}],[\"元素占据空间\",{\"3\":{\"29\":1}}],[\"元素是否可见\",{\"3\":{\"25\":1}}],[\"元素选择器\",{\"3\":{\"23\":1,\"24\":1}}],[\"继续执行宏任务队列中的任务\",{\"3\":{\"141\":1}}],[\"继续使用缓存\",{\"3\":{\"10\":1}}],[\"继承方法\",{\"3\":{\"160\":1}}],[\"继承父类\",{\"3\":{\"159\":1}}],[\"继承=＞call\",{\"3\":{\"85\":1}}],[\"继承\",{\"3\":{\"73\":1}}],[\"继承属性\",{\"0\":{\"25\":1},\"2\":{\"25\":1},\"3\":{\"160\":1}}],[\"updated\",{\"3\":{\"266\":1,\"272\":1}}],[\"updating\",{\"3\":{\"208\":1}}],[\"u>\",{\"3\":{\"249\":1}}],[\"udp提供无连接的\",{\"3\":{\"165\":1}}],[\"udp等\",{\"3\":{\"165\":1}}],[\"ui\",{\"3\":{\"140\":1}}],[\"unmounted\",{\"3\":{\"273\":1}}],[\"unmounted生命周期\",{\"3\":{\"260\":1}}],[\"unmounting\",{\"3\":{\"208\":1}}],[\"unmount\",{\"3\":{\"183\":1}}],[\"unshift\",{\"3\":{\"103\":1}}],[\"undefined转化为nan\",{\"3\":{\"135\":1}}],[\"undefined转化为数字是nan\",{\"3\":{\"91\":1}}],[\"undefined和null都会转换为false\",{\"3\":{\"134\":1}}],[\"undefined和null的区别\",{\"3\":{\"91\":1}}],[\"undefined的类型是undefined\",{\"3\":{\"91\":1}}],[\"undefined是变量声明\",{\"3\":{\"91\":1}}],[\"undefined是一个变量\",{\"3\":{\"91\":1}}],[\"undefined是一个全局变量\",{\"3\":{\"91\":1,\"132\":1}}],[\"undefined会返回undefined\",{\"3\":{\"91\":1}}],[\"undefined\",{\"0\":{\"91\":1,\"132\":1,\"134\":1,\"135\":1},\"2\":{\"91\":1,\"132\":1,\"134\":1,\"135\":1},\"3\":{\"58\":1,\"61\":1,\"64\":1,\"89\":1,\"91\":1,\"119\":1,\"121\":1,\"122\":3,\"123\":2,\"132\":2,\"134\":4,\"135\":1}}],[\"useparams\",{\"3\":{\"235\":2}}],[\"usecallback用来缓存因变量函数\",{\"3\":{\"205\":1}}],[\"usecallback\",{\"2\":{\"205\":1},\"3\":{\"205\":2}}],[\"usecallback函数可以让我们在函数组件中缓存一些函数\",{\"3\":{\"205\":1}}],[\"usecallback函数\",{\"0\":{\"205\":1}}],[\"usecontext可以跨越多层组件传递参数\",{\"3\":{\"202\":1}}],[\"usecontext进行传递参数和props父子传参的区别\",{\"3\":{\"202\":1}}],[\"usecontext\",{\"2\":{\"202\":1},\"3\":{\"202\":2,\"225\":1}}],[\"usecontext函数可以让我们在函数组件中使用react的上下文对象\",{\"3\":{\"202\":1}}],[\"usecontext函数\",{\"0\":{\"202\":1}}],[\"usememo用来缓存因变量\",{\"3\":{\"204\":1}}],[\"usememo\",{\"2\":{\"204\":1},\"3\":{\"204\":2}}],[\"usememo函数可以让我们在函数组件中缓存一些数据\",{\"3\":{\"204\":1}}],[\"usememo函数\",{\"0\":{\"204\":1}}],[\"useref\",{\"2\":{\"206\":1},\"3\":{\"206\":5,\"229\":1,\"234\":2,\"235\":2}}],[\"useref函数它会返回一个refobj对象\",{\"3\":{\"206\":1}}],[\"useref函数可以让我们在函数组件创建引用对象\",{\"3\":{\"206\":1}}],[\"useref函数\",{\"0\":{\"206\":1}}],[\"usereducer\",{\"2\":{\"203\":1},\"3\":{\"203\":2}}],[\"usereducer函数可以让我们在函数组件中使用redux的reducer函数\",{\"3\":{\"203\":1}}],[\"usereducer函数\",{\"0\":{\"203\":1}}],[\"user=admin\",{\"3\":{\"15\":1}}],[\"usestate\",{\"2\":{\"200\":1},\"3\":{\"200\":2,\"201\":2,\"202\":2,\"204\":3,\"205\":3,\"206\":4,\"218\":2,\"222\":1,\"223\":1,\"228\":1,\"243\":3}}],[\"usestate函数返回一个数组\",{\"3\":{\"200\":1}}],[\"usestate函数接收一个参数\",{\"3\":{\"200\":1}}],[\"usestate函数可以让我们在函数组件中使用状态对象\",{\"3\":{\"200\":1}}],[\"usestate函数\",{\"0\":{\"200\":1}}],[\"useeffect会被执行两次\",{\"3\":{\"201\":1}}],[\"useeffect函数接收一个函数作为参数\",{\"3\":{\"201\":1}}],[\"useeffect函数可以让我们在函数组件中使用生命周期钩子\",{\"3\":{\"201\":1}}],[\"useeffect函数\",{\"0\":{\"201\":1}}],[\"useeffect其实就可以用来模拟componentdidmount\",{\"3\":{\"198\":1}}],[\"useeffect\",{\"2\":{\"201\":1},\"3\":{\"85\":1,\"201\":2,\"218\":3,\"234\":3,\"235\":3,\"243\":2}}],[\"u\",{\"3\":{\"67\":1,\"249\":1}}],[\"ul>\",{\"3\":{\"148\":1,\"243\":1}}],[\"ul\",{\"3\":{\"24\":1,\"148\":4}}],[\"grade\",{\"3\":{\"159\":9,\"160\":6}}],[\"grow\",{\"3\":{\"50\":2}}],[\"g\",{\"3\":{\"64\":2}}],[\"global\",{\"3\":{\"24\":1}}],[\"getitem\",{\"3\":{\"234\":2,\"235\":1}}],[\"getsnapshotbeforeupdate\",{\"3\":{\"216\":1}}],[\"getderivedstatefromprops\",{\"3\":{\"215\":1}}],[\"getelementbyid\",{\"3\":{\"148\":1,\"152\":4,\"153\":4}}],[\"get\",{\"3\":{\"15\":1,\"16\":1}}],[\"getage\",{\"3\":{\"5\":4}}],[\"例子\",{\"3\":{\"24\":1,\"275\":1}}],[\"例如获取dom\",{\"3\":{\"265\":1}}],[\"例如vue\",{\"3\":{\"264\":1}}],[\"例如tcp\",{\"3\":{\"165\":1}}],[\"例如http\",{\"3\":{\"164\":1}}],[\"例如\",{\"3\":{\"13\":1,\"16\":1}}],[\"权重为1\",{\"3\":{\"24\":1}}],[\"权重为10\",{\"3\":{\"24\":1}}],[\"权重为100\",{\"3\":{\"24\":1}}],[\"权重为1000\",{\"3\":{\"24\":1}}],[\"权重越高\",{\"3\":{\"24\":1}}],[\"代码逻辑\",{\"3\":{\"235\":1}}],[\"代码分析\",{\"3\":{\"141\":4}}],[\"代码示例\",{\"0\":{\"141\":1},\"2\":{\"141\":1}}],[\"代码实现\",{\"3\":{\"125\":1,\"127\":1}}],[\"代码会变为\",{\"3\":{\"5\":1}}],[\"代表元素选择器\",{\"3\":{\"24\":1}}],[\"代表类选择器\",{\"3\":{\"24\":1}}],[\"代表\",{\"3\":{\"24\":1}}],[\"代表内联样式\",{\"3\":{\"24\":1}}],[\"优先级越高\",{\"3\":{\"24\":1,\"191\":1}}],[\"优先级\",{\"0\":{\"24\":1},\"2\":{\"24\":1}}],[\"优点\",{\"3\":{\"15\":1}}],[\"他们的生命周期函数会增加两个activated和deactivated\",{\"3\":{\"278\":1}}],[\"他们的参数\",{\"3\":{\"83\":1}}],[\"他和react16\",{\"3\":{\"215\":1}}],[\"他在第一次渲染的时候被调用\",{\"3\":{\"215\":1}}],[\"他才会重新创建\",{\"3\":{\"205\":1}}],[\"他才会重新计算\",{\"3\":{\"204\":1}}],[\"他是一个\",{\"3\":{\"189\":1}}],[\"他返回的是一个还是多个\",{\"3\":{\"85\":1}}],[\"他复制的就不是地址吗\",{\"3\":{\"85\":1}}],[\"他会选择所有的div下的紧邻的p元素\",{\"3\":{\"23\":1}}],[\"他会选择所有的div下的p元素\",{\"3\":{\"23\":1}}],[\"他的变量还在内存中被fn2引用着\",{\"3\":{\"4\":1}}],[\"群组选择器\",{\"3\":{\"23\":1}}],[\">v\",{\"3\":{\"256\":2}}],[\">row\",{\"3\":{\"242\":1}}],[\">获取<\",{\"3\":{\"229\":1}}],[\">修改父组件的name<\",{\"3\":{\"222\":3,\"223\":1}}],[\">hello\",{\"3\":{\"221\":1}}],[\">停止<\",{\"3\":{\"206\":1}}],[\">开始<\",{\"3\":{\"206\":1}}],[\">点击<\",{\"3\":{\"205\":1,\"218\":1}}],[\">改名<\",{\"3\":{\"204\":1,\"205\":1}}],[\">+1<\",{\"3\":{\"197\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1}}],[\"><\",{\"3\":{\"152\":2,\"153\":2}}],[\">=\",{\"3\":{\"42\":2,\"119\":1,\"239\":1}}],[\">\",{\"3\":{\"23\":1,\"24\":3,\"41\":7,\"45\":4,\"67\":1,\"76\":1,\"79\":7,\"119\":1,\"145\":3,\"147\":3,\"148\":1,\"152\":2,\"153\":2,\"188\":1,\"196\":1,\"202\":2,\"203\":1,\"206\":2,\"222\":1,\"223\":2,\"225\":2,\"228\":1,\"229\":1,\"234\":1,\"235\":1,\"240\":2,\"242\":1}}],[\"通配符选择器\",{\"3\":{\"23\":1}}],[\"通过回调函数的方式\",{\"3\":{\"222\":1}}],[\"通过调用super可以让子类访问到父类的方法和属性\",{\"3\":{\"160\":1}}],[\"通过new关键字创建一个promise对象\",{\"3\":{\"76\":1}}],[\"通过\",{\"0\":{\"15\":1},\"2\":{\"15\":1}}],[\"通过apply将参数传递给func\",{\"3\":{\"5\":1}}],[\"通过另一个函数访问这个函数的局部变量\",{\"3\":{\"4\":1}}],[\"伪类选择器\",{\"3\":{\"23\":1,\"24\":1}}],[\"伪元素选择器\",{\"3\":{\"23\":1,\"24\":1}}],[\"类组件可以使用this关键字\",{\"3\":{\"198\":1}}],[\"类组件有生命周期钩子\",{\"3\":{\"198\":1}}],[\"类组件有自己的状态\",{\"3\":{\"198\":1}}],[\"类组件具有自己的状态\",{\"3\":{\"196\":1}}],[\"类组件时继承react\",{\"3\":{\"196\":1}}],[\"类组件使用class\",{\"3\":{\"196\":1}}],[\"类组件\",{\"0\":{\"196\":1},\"2\":{\"196\":1}}],[\"类组件和函数组件的区别\",{\"0\":{\"198\":1},\"2\":{\"198\":1}}],[\"类组件和函数组件\",{\"0\":{\"195\":1},\"2\":{\"195\":1}}],[\"类的继承\",{\"0\":{\"73\":1},\"1\":{\"159\":1,\"160\":1,\"161\":1},\"2\":{\"73\":1}}],[\"类\",{\"0\":{\"68\":1},\"2\":{\"68\":1}}],[\"类型的值\",{\"3\":{\"189\":1}}],[\"类型转化机制\",{\"1\":{\"118\":1,\"119\":1,\"120\":1}}],[\"类型\",{\"3\":{\"64\":1,\"65\":1}}],[\"类选择器\",{\"3\":{\"23\":2}}],[\"类似\",{\"3\":{\"23\":6}}],[\"类似div\",{\"3\":{\"23\":5}}],[\"普通元素选择器\",{\"3\":{\"23\":1}}],[\"怪异盒模型\",{\"0\":{\"21\":1},\"2\":{\"21\":1}}],[\"盒子类\",{\"3\":{\"25\":1}}],[\"盒子就是多大\",{\"3\":{\"21\":1}}],[\"盒子的总高度是height+margin\",{\"3\":{\"21\":1}}],[\"盒子的总高度是height\",{\"3\":{\"20\":1}}],[\"盒子的总宽度是width+margin\",{\"3\":{\"21\":1}}],[\"盒子的总宽度是width\",{\"3\":{\"20\":1}}],[\"盒子实际宽高\",{\"3\":{\"20\":1}}],[\"盒模型图例\",{\"3\":{\"21\":1}}],[\"盒模型是一个矩形的盒子\",{\"3\":{\"19\":1}}],[\"盒模型\",{\"0\":{\"19\":1},\"2\":{\"19\":1},\"3\":{\"19\":2}}],[\"标准事件模型就是指在ie9及其以上版本中使用的事件模型\",{\"3\":{\"153\":1}}],[\"标准事件模型\",{\"0\":{\"153\":1},\"2\":{\"153\":1},\"3\":{\"151\":1}}],[\"标准盒模型其实就是width就是内容的宽度\",{\"3\":{\"20\":1}}],[\"标准盒模型\",{\"0\":{\"20\":1},\"2\":{\"20\":1},\"3\":{\"19\":2}}],[\"标准盒模型和\",{\"3\":{\"19\":1}}],[\"标识\",{\"3\":{\"62\":1}}],[\"标签中\",{\"2\":{\"40\":1}}],[\"标签\",{\"3\":{\"15\":1}}],[\"中哪些数据结构具有可迭代性\",{\"3\":{\"67\":1}}],[\"中\",{\"0\":{\"189\":1,\"190\":1},\"2\":{\"189\":1,\"190\":1},\"3\":{\"67\":1,\"190\":3,\"215\":2}}],[\"中间自适应\",{\"3\":{\"52\":1}}],[\"中有一些属性是可以继承的\",{\"3\":{\"25\":1}}],[\"中的\",{\"2\":{\"277\":1},\"3\":{\"190\":1}}],[\"中的优先级是根据选择器的权重来决定的\",{\"3\":{\"24\":1}}],[\"中的变量\",{\"3\":{\"4\":1}}],[\"中选择器主要分为以下几种\",{\"3\":{\"23\":1}}],[\"中盒模型分为两种\",{\"3\":{\"19\":1}}],[\"内部的元素与外部的元素相互隔离\",{\"3\":{\"31\":1}}],[\"内联样式\",{\"3\":{\"24\":1}}],[\"内边距\",{\"3\":{\"19\":1,\"25\":1}}],[\"内存缓存的优点是读取速度快\",{\"3\":{\"8\":1}}],[\"内存缓存和硬盘缓存\",{\"3\":{\"8\":1}}],[\"内存泄漏\",{\"1\":{\"1\":1,\"2\":1,\"3\":1,\"4\":1,\"5\":1,\"6\":1}}],[\"反向代理的原理是\",{\"3\":{\"17\":1}}],[\"反向代理\",{\"0\":{\"17\":1},\"2\":{\"17\":1}}],[\"router\",{\"3\":{\"235\":1,\"264\":1}}],[\"runtime\",{\"3\":{\"190\":2}}],[\"running\",{\"3\":{\"16\":1}}],[\"race\",{\"3\":{\"79\":4}}],[\"random\",{\"3\":{\"76\":1,\"79\":7}}],[\"r\",{\"3\":{\"67\":1}}],[\"right\",{\"3\":{\"52\":1}}],[\"render阶段负责计算任务\",{\"3\":{\"208\":1}}],[\"render阶段和commit阶段\",{\"3\":{\"208\":1}}],[\"render阶段和pre\",{\"3\":{\"208\":1}}],[\"render阶段\",{\"3\":{\"208\":1}}],[\"render\",{\"3\":{\"196\":1,\"211\":1,\"215\":1}}],[\"renderer会将这个fiber转化成dom\",{\"3\":{\"192\":1}}],[\"rendering等等\",{\"3\":{\"140\":1}}],[\"ref=\",{\"3\":{\"206\":1,\"229\":1,\"234\":1,\"235\":1}}],[\"refobject\",{\"3\":{\"191\":1}}],[\"ref\",{\"3\":{\"189\":5,\"191\":1,\"206\":2}}],[\"referenceerror\",{\"3\":{\"58\":1}}],[\"replace\",{\"3\":{\"116\":1,\"235\":1}}],[\"repeat\",{\"3\":{\"113\":1}}],[\"reverse\",{\"3\":{\"106\":1}}],[\"regexp\",{\"0\":{\"98\":1},\"2\":{\"98\":1},\"3\":{\"127\":1}}],[\"rejected\",{\"3\":{\"77\":1}}],[\"reject\",{\"3\":{\"76\":3,\"79\":22,\"141\":1}}],[\"react组件通信方式\",{\"1\":{\"220\":1,\"221\":1,\"222\":1,\"223\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1}}],[\"react生命周期\",{\"1\":{\"208\":1,\"209\":1,\"210\":1,\"211\":1,\"212\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":1,\"217\":1,\"218\":1,\"219\":1}}],[\"react官网也表达\",{\"3\":{\"206\":1}}],[\"react18以后\",{\"3\":{\"201\":1}}],[\"react17\",{\"0\":{\"190\":1},\"2\":{\"190\":1},\"3\":{\"190\":2}}],[\"react16\",{\"0\":{\"189\":1},\"2\":{\"189\":1},\"3\":{\"188\":1,\"190\":1,\"213\":2}}],[\"reactelement\",{\"3\":{\"189\":4,\"190\":1}}],[\"react篇\",{\"1\":{\"185\":1}}],[\"react\",{\"0\":{\"188\":1,\"191\":1,\"194\":1},\"1\":{\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"198\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1,\"206\":1,\"207\":1},\"2\":{\"188\":1,\"191\":1,\"194\":1,\"277\":1},\"3\":{\"67\":1,\"186\":2,\"189\":8,\"190\":10,\"196\":3,\"197\":2,\"200\":2,\"201\":2,\"202\":4,\"203\":2,\"204\":2,\"205\":2,\"206\":4,\"218\":2,\"221\":2,\"222\":4,\"223\":6,\"225\":3,\"228\":6,\"229\":1,\"234\":2,\"235\":3,\"240\":3,\"242\":3,\"243\":2}}],[\"redux\",{\"3\":{\"226\":1}}],[\"reduce\",{\"3\":{\"107\":1}}],[\"red\",{\"3\":{\"52\":1}}],[\"rel=\",{\"3\":{\"41\":3,\"45\":2}}],[\"rem区别\",{\"3\":{\"85\":1}}],[\"rem\",{\"3\":{\"27\":1}}],[\"req\",{\"3\":{\"16\":1}}],[\"requested\",{\"3\":{\"16\":1}}],[\"request\",{\"3\":{\"16\":1}}],[\"require\",{\"3\":{\"16\":1}}],[\"resolved\",{\"3\":{\"77\":1}}],[\"resolve\",{\"3\":{\"76\":3,\"79\":24,\"141\":15}}],[\"rest\",{\"3\":{\"65\":2,\"66\":2,\"67\":1}}],[\"res\",{\"3\":{\"15\":2,\"16\":6,\"141\":2}}],[\"return\",{\"3\":{\"4\":2,\"5\":3,\"67\":1,\"147\":1,\"189\":1,\"191\":2,\"196\":1,\"197\":1,\"200\":1,\"201\":2,\"202\":2,\"203\":4,\"204\":2,\"205\":1,\"206\":2,\"218\":2,\"221\":2,\"222\":2,\"223\":3,\"228\":1,\"229\":1,\"234\":2,\"235\":2,\"240\":1,\"242\":1,\"243\":1,\"248\":1,\"251\":1,\"252\":1,\"253\":1}}],[\"x\",{\"3\":{\"16\":1}}],[\"xss\",{\"3\":{\"15\":1}}],[\"允许单个项目有与其他项目不一样的对齐方式\",{\"3\":{\"50\":1}}],[\"允许前端获取哪个请求头\",{\"3\":{\"16\":1}}],[\"允许跨域携带cookie\",{\"3\":{\"16\":1}}],[\"允许跨域的请求方式\",{\"3\":{\"16\":1}}],[\"允许跨域\",{\"3\":{\"16\":1}}],[\"告诉浏览器允许这种请求\",{\"3\":{\"16\":1}}],[\"攻击\",{\"3\":{\"15\":1}}],[\"可能会出现问题\",{\"3\":{\"265\":1}}],[\"可能会导致组件一直被重新渲染\",{\"3\":{\"211\":1}}],[\"可能会遭受\",{\"3\":{\"15\":1}}],[\"可靠的数据传输服务\",{\"3\":{\"165\":1}}],[\"可变性\",{\"0\":{\"60\":1},\"2\":{\"60\":1}}],[\"可被改变\",{\"3\":{\"57\":1}}],[\"可覆盖align\",{\"3\":{\"50\":1}}],[\"可以通过include和exclude属性来指定缓存哪些组件\",{\"3\":{\"275\":1}}],[\"可以通过作用域链来访问属性和方法和e事件对象\",{\"3\":{\"148\":1}}],[\"可以使被包含的组件保留状态\",{\"3\":{\"275\":1}}],[\"可以使用watch监听数据的变化\",{\"3\":{\"266\":1,\"272\":1}}],[\"可以使用第三方库来操作这个\",{\"3\":{\"212\":1}}],[\"可以使用useref\",{\"3\":{\"206\":1}}],[\"可以使用super调用父类的构造函数\",{\"3\":{\"160\":1}}],[\"可以使用\",{\"3\":{\"83\":1}}],[\"可以使用解构赋值\",{\"3\":{\"67\":1}}],[\"可以使用扩展运算符来传递\",{\"3\":{\"67\":1}}],[\"可以使用剩余运算符\",{\"3\":{\"64\":1,\"65\":1}}],[\"可以使用flex\",{\"3\":{\"50\":2}}],[\"可以使用闭包来延迟函数的执行\",{\"3\":{\"5\":1}}],[\"可以让我们在不使用class组件的情况下使用生命周期钩子\",{\"3\":{\"217\":1,\"218\":1}}],[\"可以用来监听元素是否进入可视区域\",{\"3\":{\"240\":1}}],[\"可以用来引用任何类型的对象\",{\"3\":{\"206\":1}}],[\"可以用来指定资源的加载时机\",{\"3\":{\"45\":1}}],[\"可以在这个钩子中进一步地更改状态\",{\"3\":{\"266\":1,\"272\":1}}],[\"可以在mounted中进行\",{\"3\":{\"264\":1}}],[\"可以在constructor中初始化state\",{\"3\":{\"196\":1}}],[\"可以在里面插入样式\",{\"3\":{\"23\":1}}],[\"可以在里面插入内容\",{\"3\":{\"23\":1}}],[\"可以是原生的\",{\"3\":{\"189\":2,\"190\":1}}],[\"可以是一个值\",{\"3\":{\"79\":1}}],[\"可以生成\",{\"3\":{\"186\":1}}],[\"可以根据ip地址的不同\",{\"3\":{\"167\":1}}],[\"可以根据不同的特性来加载不同的css\",{\"3\":{\"42\":1}}],[\"可以借助子网掩码就可以计算出网络号和主机号\",{\"3\":{\"167\":1}}],[\"可以这么说\",{\"3\":{\"145\":1}}],[\"可以传入一个比较函数\",{\"3\":{\"106\":1}}],[\"可以认为\",{\"3\":{\"71\":1}}],[\"可以给变量设置别名\",{\"3\":{\"65\":1}}],[\"可以给变量设置默认值\",{\"3\":{\"64\":1,\"65\":1}}],[\"可以跳过某些元素\",{\"3\":{\"64\":2}}],[\"可以实现更加灵活的布局方式\",{\"3\":{\"47\":1}}],[\"可以确保css在dom树生成之前就加载完毕\",{\"3\":{\"40\":1}}],[\"可以设置access\",{\"3\":{\"16\":1}}],[\"可以访问到\",{\"3\":{\"4\":1}}],[\"请求\",{\"3\":{\"15\":1}}],[\"缺点\",{\"3\":{\"15\":1}}],[\"支持浏览器与服务器双向通信\",{\"3\":{\"15\":1}}],[\"兼容性好\",{\"3\":{\"15\":1}}],[\"格式返回给客户端\",{\"3\":{\"15\":1}}],[\"然后继续调用这三个函数\",{\"3\":{\"276\":1}}],[\"然后\",{\"3\":{\"235\":1}}],[\"然后使用useref来获取div元素的引用\",{\"3\":{\"235\":1}}],[\"然后利用useeffect来监听滚动事件\",{\"3\":{\"235\":1}}],[\"然后跳转到该位置\",{\"3\":{\"234\":1,\"235\":2}}],[\"然后在watch中修改数据\",{\"3\":{\"266\":1,\"272\":1}}],[\"然后在父组件内部修改参数\",{\"3\":{\"222\":1}}],[\"然后在componentdidupdate中获取到这个方法的返回值\",{\"3\":{\"216\":1}}],[\"然后在接收端再将其组装起来\",{\"3\":{\"173\":1}}],[\"然后将数据包转发到下一个路由器\",{\"3\":{\"178\":1}}],[\"然后将其存储到mac地址表中\",{\"3\":{\"177\":1}}],[\"然后将元素移除屏幕\",{\"3\":{\"30\":1}}],[\"然后通过网线发送出去\",{\"3\":{\"176\":1}}],[\"然后目的主机会向发送方回复mac地址\",{\"3\":{\"175\":1}}],[\"然后发送到数据链路层\",{\"3\":{\"174\":1}}],[\"然后从上往下传输到传输层\",{\"3\":{\"172\":1}}],[\"然后执行事件处理程序\",{\"3\":{\"152\":1,\"153\":1}}],[\"然后执行\",{\"3\":{\"150\":1}}],[\"然后再通过父组件来传递参数\",{\"3\":{\"224\":1}}],[\"然后再通过物理层进行传输\",{\"3\":{\"168\":1}}],[\"然后再发送到物理层\",{\"3\":{\"175\":1}}],[\"然后再发送请求\",{\"3\":{\"171\":1}}],[\"然后再向该ip地址对应的服务器发送请求\",{\"3\":{\"172\":2}}],[\"然后再传输到传输层\",{\"3\":{\"166\":1}}],[\"然后再执行宏任务队列中的任务\",{\"3\":{\"140\":1}}],[\"然后再进行比较\",{\"3\":{\"119\":1}}],[\"然后再将结果返回给浏览器\",{\"3\":{\"17\":1}}],[\"然后就会去调用then方法\",{\"3\":{\"76\":1}}],[\"然后就可以拿到数据\",{\"3\":{\"15\":1}}],[\"然后对其中的变量进行赋值\",{\"3\":{\"63\":1}}],[\"然后以\",{\"3\":{\"15\":1}}],[\"然后做一些事情\",{\"3\":{\"15\":1}}],[\"也会导致父组件的可读性变差\",{\"3\":{\"223\":1}}],[\"也会在组件卸载之前执行\",{\"3\":{\"201\":1}}],[\"也会在组件更新之后执行\",{\"3\":{\"201\":1}}],[\"也就是在组件已经被渲染到页面之后执行\",{\"3\":{\"211\":1}}],[\"也就是在组件即将被渲染到页面之前执行\",{\"3\":{\"211\":1}}],[\"也就是组件从生成到消亡的过程\",{\"3\":{\"208\":1}}],[\"也就是0和1\",{\"3\":{\"169\":1}}],[\"也就是说react17之后只有两个阶段\",{\"3\":{\"208\":1}}],[\"也就是说在什么范围内可以访问到变量和函数\",{\"3\":{\"57\":1}}],[\"也就是说\",{\"3\":{\"15\":1,\"137\":1,\"165\":1,\"176\":1,\"212\":4,\"213\":1,\"215\":1,\"216\":1,\"217\":1}}],[\"也有\",{\"3\":{\"156\":1}}],[\"也可以在这个钩子里面根据preprops和prestate来做一些性能优化\",{\"3\":{\"216\":1}}],[\"也可以是自定义的组件\",{\"3\":{\"189\":2,\"190\":1}}],[\"也可以是一个promise对象\",{\"3\":{\"79\":1}}],[\"也可以用来定义多行字符串\",{\"3\":{\"62\":1}}],[\"也可以配置vite\",{\"3\":{\"17\":1}}],[\"也可以发送任何请求\",{\"3\":{\"17\":1}}],[\"也不能确定数据的顺序\",{\"3\":{\"165\":1}}],[\"也不能确定数据是否乱序\",{\"3\":{\"165\":1}}],[\"也不需要额外的运算符\",{\"3\":{\"83\":1}}],[\"也不放大\",{\"3\":{\"50\":1}}],[\"也不会返回结果\",{\"3\":{\"13\":1}}],[\"也不使用协商缓存\",{\"3\":{\"8\":1}}],[\"回调执行函数\",{\"3\":{\"15\":1}}],[\"h1>\",{\"3\":{\"196\":1,\"197\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":3,\"205\":2,\"206\":1,\"234\":1,\"235\":1}}],[\"hook\",{\"2\":{\"218\":1}}],[\"hook函数并不是生命周期钩子\",{\"3\":{\"218\":1}}],[\"hook函数是react16\",{\"3\":{\"218\":1}}],[\"hook函数\",{\"0\":{\"218\":1}}],[\"hooks\",{\"0\":{\"194\":1,\"199\":1},\"1\":{\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"198\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1,\"206\":1,\"207\":1},\"2\":{\"194\":1,\"199\":1}}],[\"hover\",{\"3\":{\"23\":1}}],[\"handlestop\",{\"3\":{\"206\":2}}],[\"handlestart\",{\"3\":{\"206\":2}}],[\"handleclick\",{\"3\":{\"205\":4,\"229\":2}}],[\"handle\",{\"3\":{\"191\":1}}],[\"hi\",{\"3\":{\"160\":1}}],[\"hidden\",{\"3\":{\"29\":1,\"30\":1}}],[\"h\",{\"3\":{\"64\":1}}],[\"href=\",{\"3\":{\"41\":3,\"45\":2}}],[\"height=\",{\"3\":{\"242\":1}}],[\"height等\",{\"3\":{\"42\":1}}],[\"height\",{\"3\":{\"20\":1,\"21\":1,\"25\":1,\"29\":1,\"30\":1,\"52\":3}}],[\"hello>\",{\"3\":{\"188\":1}}],[\"hello\",{\"3\":{\"16\":1,\"160\":2,\"189\":3,\"190\":3,\"221\":1}}],[\"headers\",{\"3\":{\"16\":1}}],[\"head\",{\"2\":{\"40\":1},\"3\":{\"15\":1}}],[\"html里面的meta有什么作用\",{\"3\":{\"85\":1}}],[\"html5\",{\"3\":{\"15\":1}}],[\"html\",{\"3\":{\"13\":5}}],[\"http基本概念\",{\"1\":{\"162\":1}}],[\"http和https\",{\"3\":{\"85\":1}}],[\"https\",{\"3\":{\"13\":1}}],[\"http\",{\"3\":{\"13\":4,\"15\":1,\"16\":4,\"163\":1}}],[\"8之后新增的一个函数\",{\"3\":{\"218\":1}}],[\"8之后\",{\"3\":{\"217\":1}}],[\"8\",{\"3\":{\"57\":2,\"141\":4}}],[\"8080\",{\"3\":{\"15\":1}}],[\"81\",{\"3\":{\"13\":1}}],[\"就说明滚动条滚动到底部了\",{\"3\":{\"239\":1}}],[\"就需要用箭头函数包裹\",{\"3\":{\"222\":1}}],[\"就发送请求到dns服务器\",{\"3\":{\"172\":1}}],[\"就发送请求到服务器\",{\"3\":{\"171\":1}}],[\"就直接从缓存中获取\",{\"3\":{\"172\":1}}],[\"就直接从缓存中获取资源\",{\"3\":{\"171\":1}}],[\"就直接返回\",{\"3\":{\"127\":1}}],[\"就形成了原型链\",{\"3\":{\"156\":1}}],[\"就可以得到滚动条滚动到底部时\",{\"3\":{\"239\":1}}],[\"就可以实现跨组件传递参数\",{\"3\":{\"225\":1}}],[\"就可以销毁`loading`组件了\",{\"3\":{\"183\":1}}],[\"就可以进行数据传输了\",{\"3\":{\"173\":1}}],[\"就可以获取到目的网络的ip地址\",{\"3\":{\"172\":1}}],[\"就可以管理某一类型的所有事件\",{\"3\":{\"148\":1}}],[\"就可以确保css能够正确的渲染dom树\",{\"3\":{\"38\":1}}],[\"就返回true\",{\"3\":{\"107\":1}}],[\"就是滚动条滚动的距离\",{\"3\":{\"239\":1}}],[\"就是这个表单数据不受react的state控制\",{\"3\":{\"229\":1}}],[\"就是将return到的对象替换当前的state\",{\"3\":{\"215\":1}}],[\"就是要找到目标地址的子网\",{\"3\":{\"167\":1}}],[\"就是异步执行\",{\"3\":{\"137\":1}}],[\"就是nan\",{\"3\":{\"135\":1}}],[\"就是0\",{\"3\":{\"135\":1}}],[\"就是对于date\",{\"3\":{\"127\":1}}],[\"就是对于父元素的属性\",{\"3\":{\"49\":1}}],[\"就是循环引用的问题\",{\"3\":{\"127\":1}}],[\"就是它只管一层\",{\"3\":{\"125\":1}}],[\"就是如果两个值类型不同\",{\"3\":{\"121\":1}}],[\"就是构造函数\",{\"3\":{\"71\":1}}],[\"就是\",{\"3\":{\"15\":1,\"79\":1}}],[\"就会出现\",{\"3\":{\"150\":1}}],[\"就会从父级作用域中查找\",{\"3\":{\"145\":1}}],[\"就会从父级作用域查找\",{\"3\":{\"144\":1}}],[\"就会报错\",{\"3\":{\"144\":1,\"145\":1}}],[\"就会去读取任务队列\",{\"3\":{\"139\":1}}],[\"就会造成死循环\",{\"3\":{\"127\":1}}],[\"就会影响到另一个对象\",{\"3\":{\"125\":1}}],[\"就会停止dom树的生成\",{\"3\":{\"38\":1}}],[\"就会生成dom树\",{\"3\":{\"38\":1}}],[\"就会在响应头中加入access\",{\"3\":{\"16\":1}}],[\"就会将要返回的数据包裹在这个函数里面\",{\"3\":{\"15\":1}}],[\"就会返回200\",{\"3\":{\"9\":1}}],[\"就会返回304\",{\"3\":{\"9\":1}}],[\"就会导致任务堵塞\",{\"3\":{\"137\":1}}],[\"就会导致缓存失效\",{\"3\":{\"8\":1}}],[\"就会导致内存泄漏\",{\"3\":{\"2\":1}}],[\"就会使用缓存\",{\"3\":{\"8\":2}}],[\"就会直接从缓存中获取\",{\"3\":{\"7\":1}}],[\"template>\",{\"3\":{\"256\":1}}],[\"text\",{\"3\":{\"15\":2,\"23\":1,\"25\":3,\"206\":1}}],[\"t将传入的对象的属性名联合成一个联合类型\",{\"3\":{\"253\":1}}],[\"t\",{\"3\":{\"248\":2,\"249\":2,\"250\":4,\"251\":2,\"252\":2,\"253\":2}}],[\"ts的泛型使得ts\",{\"3\":{\"246\":1}}],[\"title\",{\"3\":{\"243\":1}}],[\"timmer在外边定义\",{\"3\":{\"206\":1}}],[\"timmer\",{\"3\":{\"206\":4}}],[\"timer是window的方法\",{\"3\":{\"61\":1}}],[\"timer\",{\"3\":{\"61\":3}}],[\"tcp会将消息体分成多个数据包\",{\"3\":{\"173\":1}}],[\"tcp在传输数据之前\",{\"3\":{\"173\":1}}],[\"tcp连接\",{\"0\":{\"173\":1},\"2\":{\"173\":1}}],[\"tcp段的由来\",{\"0\":{\"166\":1},\"2\":{\"166\":1}}],[\"tcp提供面向连接的\",{\"3\":{\"165\":1}}],[\"tcp和udp\",{\"3\":{\"165\":1}}],[\"tcp\",{\"1\":{\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":1}}],[\"target\",{\"3\":{\"148\":1,\"228\":1}}],[\"targetlength\",{\"3\":{\"113\":2}}],[\"table\",{\"3\":{\"25\":1}}],[\"tofixed\",{\"3\":{\"206\":1}}],[\"touppercase\",{\"3\":{\"113\":1}}],[\"tolowercase\",{\"3\":{\"113\":1}}],[\"tostring\",{\"3\":{\"108\":1,\"118\":1}}],[\"trimright\",{\"3\":{\"113\":1}}],[\"trimleft\",{\"3\":{\"113\":1}}],[\"trim\",{\"3\":{\"113\":1}}],[\"true\",{\"3\":{\"16\":1,\"87\":1,\"91\":1,\"119\":1,\"121\":1,\"122\":6,\"123\":1,\"134\":1,\"243\":1,\"258\":2}}],[\"then方法接收两个参数\",{\"3\":{\"76\":1}}],[\"then\",{\"3\":{\"76\":2,\"78\":1,\"79\":3,\"140\":1,\"141\":15,\"243\":1}}],[\"this会指向调用它的对象\",{\"3\":{\"84\":1}}],[\"this指向谁\",{\"3\":{\"85\":1}}],[\"this指向的是\",{\"3\":{\"82\":2}}],[\"this指向的是函数定义时所在的对象\",{\"3\":{\"61\":1}}],[\"this指向问题\",{\"1\":{\"82\":1,\"83\":1,\"84\":1}}],[\"this的指向类型\",{\"0\":{\"82\":1}}],[\"this的指向问题\",{\"3\":{\"61\":1}}],[\"this\",{\"2\":{\"82\":1},\"3\":{\"5\":3,\"61\":9,\"70\":4,\"71\":4,\"72\":8,\"82\":5,\"83\":4,\"145\":2,\"159\":17,\"160\":9,\"196\":4,\"200\":4,\"202\":2,\"211\":3,\"212\":3,\"215\":6,\"235\":2,\"250\":2}}],[\"typescript篇\",{\"1\":{\"245\":1}}],[\"typeerror\",{\"3\":{\"144\":1,\"145\":1}}],[\"typeof的值是object\",{\"3\":{\"133\":1}}],[\"typeof\",{\"3\":{\"85\":1,\"90\":1,\"133\":1}}],[\"type=\",{\"3\":{\"23\":1,\"206\":1}}],[\"type\",{\"3\":{\"15\":2,\"16\":1,\"25\":1,\"189\":7,\"190\":2,\"191\":2,\"203\":3,\"252\":1}}],[\"默认返回true\",{\"3\":{\"212\":1}}],[\"默认绑定\",{\"3\":{\"82\":1}}],[\"默认会有一个空的constructor方法\",{\"3\":{\"71\":1}}],[\"默认值为0\",{\"3\":{\"50\":1}}],[\"默认值为row\",{\"3\":{\"49\":1}}],[\"默认为false\",{\"3\":{\"153\":1}}],[\"默认为undefined\",{\"3\":{\"132\":2}}],[\"默认为\",{\"3\":{\"50\":3}}],[\"默认\",{\"3\":{\"15\":1}}],[\"端口号\",{\"3\":{\"171\":1}}],[\"端口\",{\"3\":{\"16\":1}}],[\"端口不同\",{\"3\":{\"13\":1}}],[\"端口相同\",{\"3\":{\"13\":1}}],[\"不预先指定具体的类型\",{\"3\":{\"246\":2}}],[\"不能进行dom操作\",{\"3\":{\"264\":1}}],[\"不能返回多个顶级元素\",{\"3\":{\"211\":1}}],[\"不能获取\",{\"3\":{\"211\":1}}],[\"不能和浏览器进行交互\",{\"3\":{\"211\":1}}],[\"不能修改组件的状态对象\",{\"3\":{\"211\":1}}],[\"不能修改props\",{\"3\":{\"197\":1}}],[\"不支持捕获阶段\",{\"3\":{\"152\":1}}],[\"不是作用域的地方\",{\"3\":{\"145\":1}}],[\"不是服务器的安全策略\",{\"3\":{\"17\":1}}],[\"不接受其他类型的值作为键名\",{\"3\":{\"127\":1}}],[\"不需要再次请求服务器\",{\"3\":{\"241\":2}}],[\"不需要再次拷贝\",{\"3\":{\"127\":1}}],[\"不需要引入\",{\"3\":{\"190\":1}}],[\"不需要额外的变量\",{\"3\":{\"83\":1}}],[\"不可以修改\",{\"3\":{\"110\":1}}],[\"不管promise对象的状态是resolved还是rejected\",{\"3\":{\"78\":1}}],[\"不管你有没有设置padding和border\",{\"3\":{\"21\":1}}],[\"不要加上关键词function\",{\"3\":{\"71\":1}}],[\"不放大\",{\"3\":{\"50\":1}}],[\"不缩小\",{\"3\":{\"50\":2}}],[\"不同点\",{\"0\":{\"257\":1},\"2\":{\"257\":1},\"3\":{\"277\":1}}],[\"不同分辨率\",{\"3\":{\"43\":1}}],[\"不同源\",{\"3\":{\"13\":3}}],[\"不会触发附加的重渲染过程\",{\"3\":{\"266\":1,\"272\":1}}],[\"不会触发任何生命周期\",{\"3\":{\"260\":1}}],[\"不会涉及到dom结构的变化\",{\"3\":{\"259\":1,\"260\":1}}],[\"不会导致视图重新渲染\",{\"3\":{\"206\":1}}],[\"不会重复\",{\"3\":{\"165\":1}}],[\"不会乱序\",{\"3\":{\"165\":1}}],[\"不会进行隐式类型转换\",{\"3\":{\"122\":1}}],[\"不会改变数组本身\",{\"3\":{\"102\":1,\"103\":1}}],[\"不会存在外边距合并\",{\"3\":{\"33\":1}}],[\"不会发出去\",{\"3\":{\"13\":1}}],[\"不为visible\",{\"3\":{\"32\":1}}],[\"不为none\",{\"3\":{\"32\":1}}],[\"不包括end\",{\"3\":{\"103\":1}}],[\"不包括嵌套的p元素\",{\"3\":{\"23\":1}}],[\"不包含padding和border\",{\"3\":{\"20\":1}}],[\"不安全\",{\"3\":{\"15\":1}}],[\"不使用apply时\",{\"3\":{\"83\":1}}],[\"不使用强制缓存\",{\"3\":{\"8\":2}}],[\"不使用闭包情况下\",{\"3\":{\"5\":1}}],[\"offsettop\",{\"3\":{\"240\":1,\"242\":1}}],[\"of循环\",{\"3\":{\"67\":1}}],[\"observe\",{\"3\":{\"239\":1,\"240\":1}}],[\"observer\",{\"3\":{\"239\":2,\"240\":2}}],[\"obj1\",{\"3\":{\"82\":5,\"83\":6}}],[\"obj2\",{\"3\":{\"67\":1,\"82\":4,\"83\":6}}],[\"obj\",{\"3\":{\"61\":9,\"65\":5,\"67\":4,\"82\":8,\"121\":1,\"126\":1,\"127\":3,\"128\":2,\"132\":2,\"133\":3}}],[\"object\",{\"0\":{\"94\":1},\"2\":{\"94\":1},\"3\":{\"72\":2,\"91\":1,\"119\":2,\"126\":1,\"133\":1},\"4\":{\"0\":2,\"6\":2,\"11\":2,\"18\":2,\"22\":2,\"26\":2,\"28\":2,\"30\":2,\"35\":2,\"36\":2,\"46\":2,\"53\":2,\"80\":2,\"81\":2,\"84\":2,\"85\":2,\"100\":2,\"109\":2,\"117\":2,\"120\":2,\"124\":2,\"130\":2,\"131\":2,\"136\":2,\"142\":2,\"154\":2,\"158\":2,\"161\":2,\"162\":2,\"163\":2,\"170\":2,\"179\":2,\"180\":2,\"184\":2,\"185\":2,\"193\":2,\"207\":2,\"219\":2,\"227\":2,\"230\":2,\"231\":2,\"236\":2,\"244\":2,\"245\":2,\"254\":2,\"255\":2,\"262\":2,\"283\":2}}],[\"owner\",{\"3\":{\"189\":3}}],[\"o\",{\"3\":{\"64\":1,\"140\":1}}],[\"old\",{\"3\":{\"62\":2,\"70\":2,\"71\":2,\"72\":4,\"159\":5,\"160\":3}}],[\"order\",{\"3\":{\"50\":1}}],[\"origin\",{\"3\":{\"16\":1}}],[\"origin字段来允许指定源的请求\",{\"3\":{\"16\":1}}],[\"overflow\",{\"3\":{\"32\":1}}],[\"option的初始化\",{\"3\":{\"264\":1}}],[\"options\",{\"3\":{\"16\":1}}],[\"opcitiy\",{\"3\":{\"29\":1,\"30\":1}}],[\"onactivated\",{\"3\":{\"274\":1}}],[\"onbeforeunmount\",{\"3\":{\"273\":1}}],[\"onbeforeupdate\",{\"3\":{\"272\":1}}],[\"onbeforemount\",{\"3\":{\"271\":1}}],[\"onback\",{\"3\":{\"15\":1}}],[\"onchange=\",{\"3\":{\"228\":1}}],[\"onclick=\",{\"3\":{\"196\":1,\"197\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":2,\"204\":2,\"205\":3,\"206\":2,\"218\":1,\"222\":3,\"223\":1,\"229\":1}}],[\"onclick\",{\"3\":{\"152\":4}}],[\"only\",{\"3\":{\"42\":1}}],[\"on\",{\"3\":{\"16\":1}}],[\"other\",{\"3\":{\"13\":1}}],[\"dns解析\",{\"0\":{\"172\":1},\"2\":{\"172\":1}}],[\"dns等\",{\"3\":{\"164\":1}}],[\"dnd\",{\"3\":{\"85\":1}}],[\"d4d1ccf8\",{\"0\":{\"159\":1,\"160\":1,\"161\":1}}],[\"date\",{\"0\":{\"97\":1},\"2\":{\"97\":1},\"3\":{\"206\":3}}],[\"data\",{\"3\":{\"76\":2,\"79\":6}}],[\"deactivated\",{\"3\":{\"274\":1}}],[\"devtivated\",{\"3\":{\"268\":1}}],[\"destroyed\",{\"3\":{\"267\":1}}],[\"default\",{\"3\":{\"200\":1,\"201\":1,\"202\":1,\"203\":2,\"204\":1,\"205\":1,\"206\":2,\"221\":1,\"222\":2,\"223\":3,\"228\":1,\"229\":1,\"235\":1}}],[\"decoration\",{\"3\":{\"25\":1}}],[\"deletecount\",{\"3\":{\"102\":1,\"103\":1}}],[\"delete\",{\"3\":{\"16\":1}}],[\"delaytime\",{\"3\":{\"5\":2}}],[\"delay\",{\"3\":{\"5\":2}}],[\"d\",{\"3\":{\"24\":2,\"127\":1}}],[\"dispatch\",{\"3\":{\"203\":3}}],[\"display\",{\"3\":{\"25\":1,\"29\":1,\"30\":1,\"32\":1,\"52\":1,\"258\":3,\"259\":1}}],[\"diff算法是怎样的\",{\"3\":{\"85\":1}}],[\"div4\",{\"3\":{\"152\":5,\"153\":5}}],[\"div>\",{\"3\":{\"152\":4,\"153\":4,\"188\":1,\"196\":1,\"197\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1,\"206\":1,\"218\":1,\"221\":1,\"222\":3,\"223\":3,\"228\":1,\"229\":1,\"234\":1,\"235\":1,\"240\":1,\"242\":1,\"243\":2,\"256\":3}}],[\"div3\",{\"3\":{\"152\":5,\"153\":5}}],[\"div2\",{\"3\":{\"152\":6,\"153\":6}}],[\"div1\",{\"3\":{\"152\":6,\"153\":6}}],[\"div元素垂直居中\",{\"3\":{\"85\":1}}],[\"divs\",{\"3\":{\"67\":2}}],[\"div\",{\"3\":{\"23\":2,\"67\":1,\"189\":1,\"190\":1}}],[\"direction和flex\",{\"3\":{\"49\":1}}],[\"direction\",{\"3\":{\"49\":1}}],[\"dir2\",{\"3\":{\"13\":1}}],[\"dir\",{\"3\":{\"13\":4}}],[\"double\",{\"3\":{\"204\":3}}],[\"dom元素之后\",{\"3\":{\"212\":1}}],[\"dom\",{\"0\":{\"192\":1},\"2\":{\"192\":1},\"3\":{\"189\":2,\"190\":1,\"191\":5,\"206\":2,\"211\":3,\"212\":2,\"216\":3,\"229\":3,\"235\":1,\"258\":3,\"259\":1,\"266\":2,\"272\":2}}],[\"domain2\",{\"3\":{\"15\":1}}],[\"document\",{\"3\":{\"15\":2,\"67\":1,\"148\":1,\"152\":4,\"153\":4,\"239\":3,\"240\":2,\"242\":1}}],[\"watch上的数据和方法\",{\"3\":{\"264\":2}}],[\"wd=搜索内容的形式\",{\"3\":{\"171\":1}}],[\"while\",{\"3\":{\"119\":1}}],[\"wrap的简写\",{\"3\":{\"49\":1}}],[\"wrap\",{\"3\":{\"49\":1}}],[\"winter\",{\"3\":{\"82\":3,\"83\":6}}],[\"window来实现虚拟列表\",{\"3\":{\"242\":1}}],[\"window\",{\"3\":{\"61\":3,\"82\":3,\"234\":7,\"235\":3,\"239\":6,\"240\":3,\"242\":5}}],[\"width=\",{\"3\":{\"242\":1}}],[\"width\",{\"3\":{\"19\":2,\"20\":1,\"21\":1,\"25\":2,\"41\":1,\"42\":8,\"52\":3}}],[\"with\",{\"3\":{\"16\":1}}],[\"weight\",{\"3\":{\"25\":1}}],[\"webpack等工具来做反向代理\",{\"3\":{\"17\":1}}],[\"weakmap属于弱引用\",{\"3\":{\"127\":1}}],[\"weakmap只接受对象作为键名\",{\"3\":{\"127\":1}}],[\"weakmap也会被回收\",{\"3\":{\"127\":1}}],[\"weakmap\",{\"3\":{\"3\":1}}],[\"www\",{\"3\":{\"13\":5,\"15\":1,\"171\":1}}],[\"协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走\",{\"3\":{\"167\":1}}],[\"协议不同\",{\"3\":{\"13\":1}}],[\"协议\",{\"3\":{\"13\":1,\"16\":1}}],[\"协商缓存由服务器决定是否使用缓存\",{\"3\":{\"10\":1}}],[\"协商缓存是指\",{\"3\":{\"9\":1}}],[\"协商缓存\",{\"0\":{\"9\":1},\"2\":{\"9\":1},\"3\":{\"7\":1}}],[\"域名不同\",{\"3\":{\"13\":1}}],[\"域名\",{\"3\":{\"13\":1,\"16\":1,\"171\":1}}],[\"所有的子实例也会被销毁\",{\"3\":{\"267\":1,\"273\":1}}],[\"所有的事件监听器会被移除\",{\"3\":{\"267\":1,\"273\":1}}],[\"所有的迭代方法都不会改变数组本身\",{\"3\":{\"107\":1}}],[\"所控制\",{\"3\":{\"228\":2}}],[\"所谓同源是指\",{\"3\":{\"13\":1}}],[\"所以不能直接使用props\",{\"3\":{\"270\":1}}],[\"所以不需要引入\",{\"3\":{\"190\":1}}],[\"所以可以执行依赖于\",{\"3\":{\"266\":1,\"272\":1}}],[\"所以如果直接操作dom\",{\"3\":{\"265\":1}}],[\"所以如果其中一个对象改变了这个地址\",{\"3\":{\"125\":1}}],[\"所以dom还没有挂载\",{\"3\":{\"264\":1}}],[\"所以性能比较差\",{\"3\":{\"261\":1}}],[\"所以性能比较好\",{\"3\":{\"261\":1}}],[\"所以也不会拥有\",{\"3\":{\"218\":1}}],[\"所以无法清除\",{\"3\":{\"206\":1}}],[\"所以需要在外面定义\",{\"3\":{\"206\":1}}],[\"所以需要在首页加载完成后\",{\"3\":{\"181\":1}}],[\"所以需要在用户登录后\",{\"3\":{\"181\":1}}],[\"所以交换机会根据mac地址表\",{\"3\":{\"177\":1}}],[\"所以\",{\"3\":{\"167\":1,\"228\":1}}],[\"所以数组的原型链和对象的原型链是一样的\",{\"3\":{\"157\":1}}],[\"所以当我们点击div3时\",{\"3\":{\"152\":1,\"153\":1}}],[\"所以当父子元素都绑定了事件的时候\",{\"3\":{\"150\":1}}],[\"所以fiber架构的目的就是为了解决这个问题\",{\"3\":{\"208\":1}}],[\"所以fn1的作用域链是fn1\",{\"3\":{\"147\":1}}],[\"所以foo的作用域链是foo\",{\"3\":{\"145\":1,\"147\":1}}],[\"所以bar的作用域链是bar\",{\"3\":{\"145\":1}}],[\"所以词法作用域是静态的作用域\",{\"3\":{\"145\":1}}],[\"所以先执行process\",{\"3\":{\"141\":1}}],[\"所以叫做事件循环\",{\"3\":{\"139\":1}}],[\"所以他们是相等的\",{\"3\":{\"134\":1}}],[\"所以typeof\",{\"3\":{\"133\":1}}],[\"所以this指向的是obj2\",{\"3\":{\"82\":1}}],[\"所以this指向的是obj1\",{\"3\":{\"82\":1}}],[\"所以this指向的是window\",{\"3\":{\"61\":1}}],[\"所以this指向的是使用时所在的对象\",{\"3\":{\"61\":1}}],[\"所以this指向的是函数定义时所在的对象\",{\"3\":{\"61\":2}}],[\"所以还需要对数组进行判断\",{\"3\":{\"127\":1}}],[\"所以我们称这种组件为非受控组件\",{\"3\":{\"229\":1}}],[\"所以我们称这种组件为受控组件\",{\"3\":{\"228\":1}}],[\"所以我们可以使用useref\",{\"3\":{\"206\":1}}],[\"所以我们可以通过服务器来请求接口\",{\"3\":{\"17\":1}}],[\"所以我们需要对这些特殊对象进行判断\",{\"3\":{\"127\":1}}],[\"所以我们需要一个容器来存储已经拷贝过的对象\",{\"3\":{\"127\":1}}],[\"所以我们就需要使用apply方法\",{\"3\":{\"83\":1}}],[\"所以在使用\",{\"3\":{\"190\":1}}],[\"所以在foo中查找value时\",{\"3\":{\"145\":1}}],[\"所以在声明之前访问变量会报错\",{\"3\":{\"58\":2}}],[\"所以在一些特殊的场景下\",{\"3\":{\"29\":1}}],[\"所以单独拿出来说一下\",{\"3\":{\"50\":1}}],[\"所以说\",{\"3\":{\"37\":1}}],[\"所以权重为0113\",{\"3\":{\"24\":1}}],[\"所以每次循环时\",{\"3\":{\"5\":1}}],[\"所以settimeout中访问到的i是for循环中的i\",{\"3\":{\"5\":1}}],[\"所以settimeout中访问到的i是全局作用域中的i\",{\"3\":{\"5\":1}}],[\"所以var定义的变量会被提升到全局作用域中\",{\"3\":{\"5\":1}}],[\"所以i的值会被保存在闭包中\",{\"3\":{\"5\":1}}],[\"所以会将数据包转发到所有的端口\",{\"3\":{\"177\":1}}],[\"所以会使用math\",{\"3\":{\"83\":1}}],[\"所以会输出0\",{\"3\":{\"5\":1}}],[\"所以会在循环结束后才会执行\",{\"3\":{\"5\":1}}],[\"所以会比其他函数占用更多的内存\",{\"3\":{\"4\":1}}],[\"它可以让我们在不需要一层一层的传递参数的情况下\",{\"3\":{\"225\":1}}],[\"它可以当作普通字符串使用\",{\"3\":{\"62\":1}}],[\"它只是模拟了生命周期钩子的功能\",{\"3\":{\"218\":1}}],[\"它具有以下特性\",{\"3\":{\"211\":2}}],[\"它就会被renderer接管\",{\"3\":{\"192\":1}}],[\"它就会被调度器scheduler接管\",{\"3\":{\"191\":1}}],[\"它对应三种关系\",{\"3\":{\"191\":1}}],[\"它传输的单位是比特\",{\"3\":{\"169\":1}}],[\"它的结构如下\",{\"3\":{\"189\":1,\"191\":1}}],[\"它的作用是将数据从一台主机传输到另一台主机\",{\"3\":{\"169\":1}}],[\"它的作用是将网络层传下来的ip数据报封装成帧\",{\"3\":{\"168\":1}}],[\"它的值也是undefined\",{\"3\":{\"132\":1}}],[\"它的值是undefined\",{\"3\":{\"132\":1}}],[\"它的值就是undefined\",{\"3\":{\"91\":1,\"132\":1}}],[\"它不保证数据传输的可靠性\",{\"3\":{\"165\":1}}],[\"它能够保证数据从一端传到另一端\",{\"3\":{\"165\":1}}],[\"它其实就是变量声明\",{\"3\":{\"91\":1}}],[\"它好比是\",{\"3\":{\"67\":1}}],[\"它是\",{\"3\":{\"186\":1}}],[\"它是一个纯函数\",{\"3\":{\"211\":1,\"215\":1}}],[\"它是一个链表结构\",{\"3\":{\"191\":1}}],[\"它是一个对象\",{\"3\":{\"189\":1}}],[\"它是一个空对象指针\",{\"3\":{\"133\":1}}],[\"它是一种针对数组或者对象进行模式匹配\",{\"3\":{\"63\":1}}],[\"它是基于原型的继承\",{\"3\":{\"70\":1}}],[\"它是由浏览器的同源策略造成的\",{\"3\":{\"12\":1}}],[\"它包含了元素的内容\",{\"3\":{\"19\":1}}],[\"它仍然存在\",{\"3\":{\"4\":1}}],[\"什么是泛型\",{\"0\":{\"246\":1},\"2\":{\"246\":1}}],[\"什么是生命周期\",{\"0\":{\"208\":1},\"2\":{\"208\":1}}],[\"什么是事件委托\",{\"3\":{\"148\":1}}],[\"什么是临时死亡区\",{\"3\":{\"58\":1}}],[\"什么是变量提升呢\",{\"3\":{\"223\":1}}],[\"什么是变量提升\",{\"3\":{\"58\":1}}],[\"什么是作用域\",{\"3\":{\"57\":1}}],[\"什么是\",{\"0\":{\"37\":1,\"186\":1},\"2\":{\"37\":1,\"186\":1}}],[\"什么是bfc\",{\"0\":{\"31\":1},\"2\":{\"31\":1}}],[\"什么是同源策略\",{\"3\":{\"12\":1}}],[\"什么是跨域\",{\"0\":{\"12\":1},\"2\":{\"12\":1}}],[\"什么是浏览器的缓存机制\",{\"0\":{\"7\":1},\"2\":{\"7\":1}}],[\"若协商缓存失效\",{\"3\":{\"10\":1}}],[\"若不生效则进行协商缓存\",{\"3\":{\"10\":1}}],[\"若强制缓存\",{\"3\":{\"10\":1}}],[\"并不参与管理\",{\"3\":{\"229\":1}}],[\"并不是在调用的地方\",{\"3\":{\"145\":1}}],[\"并将这个上下文添加到执行环境中\",{\"3\":{\"148\":1}}],[\"并将其放在任务队列里面\",{\"3\":{\"5\":1}}],[\"并拷贝属性指向的动态分配的内存\",{\"3\":{\"127\":1}}],[\"并且访问\",{\"3\":{\"202\":1}}],[\"并且在子组件里面应用\",{\"3\":{\"202\":1}}],[\"并且filber中还存在任务优先级属性\",{\"3\":{\"191\":1}}],[\"并且增加的item还会绑定事件\",{\"3\":{\"148\":1}}],[\"并且有字符串\",{\"3\":{\"119\":1}}],[\"并且是可以被改变的\",{\"3\":{\"57\":1}}],[\"并且返回资源内容\",{\"3\":{\"9\":1}}],[\"并且不会返回资源内容\",{\"3\":{\"9\":1}}],[\"并且会在请求头里面携带if\",{\"3\":{\"9\":1}}],[\"entry\",{\"3\":{\"240\":2}}],[\"entries\",{\"3\":{\"239\":2,\"240\":2}}],[\"end\",{\"3\":{\"16\":1,\"103\":1,\"112\":4,\"141\":2}}],[\"elementtype\",{\"3\":{\"191\":1}}],[\"element\",{\"3\":{\"189\":4}}],[\"else\",{\"3\":{\"76\":1,\"79\":7}}],[\"every\",{\"3\":{\"107\":1}}],[\"errorcaptured\",{\"3\":{\"268\":1}}],[\"error\",{\"3\":{\"127\":1}}],[\"err\",{\"3\":{\"76\":2,\"79\":6}}],[\"eating\",{\"3\":{\"72\":4}}],[\"eat\",{\"3\":{\"72\":4}}],[\"e\",{\"3\":{\"64\":2,\"67\":1,\"148\":2,\"228\":2}}],[\"es6新增的字符串拼接方法\",{\"3\":{\"111\":1}}],[\"es6新特新\",{\"1\":{\"54\":1,\"55\":1,\"56\":1,\"57\":1,\"58\":1,\"59\":1,\"60\":1,\"61\":1,\"62\":1,\"63\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":1,\"69\":1,\"70\":1,\"71\":1,\"72\":1,\"73\":1,\"74\":1,\"75\":1,\"76\":1,\"77\":1,\"78\":1,\"79\":1,\"80\":1}}],[\"es6之后\",{\"3\":{\"105\":1}}],[\"es6之前\",{\"3\":{\"105\":1}}],[\"es6篇\",{\"1\":{\"81\":1}}],[\"es6中定义的方法\",{\"3\":{\"71\":1}}],[\"es6\",{\"0\":{\"71\":1,\"160\":1},\"2\":{\"71\":1,\"160\":1},\"3\":{\"55\":1,\"67\":2,\"71\":1}}],[\"es5\",{\"0\":{\"70\":1,\"159\":1},\"2\":{\"70\":1,\"159\":1},\"3\":{\"55\":1,\"71\":1}}],[\"em\",{\"3\":{\"27\":1,\"85\":1}}],[\"empty\",{\"3\":{\"25\":1}}],[\"exclude\",{\"3\":{\"275\":1}}],[\"extends\",{\"3\":{\"160\":1,\"196\":1,\"251\":1,\"252\":1,\"253\":1}}],[\"export\",{\"3\":{\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1,\"206\":2,\"221\":1,\"222\":2,\"223\":3,\"228\":1,\"229\":1,\"235\":1}}],[\"expressions\",{\"3\":{\"42\":2}}],[\"expires是一个绝对时间\",{\"3\":{\"8\":1}}],[\"expires就被cache\",{\"3\":{\"8\":1}}],[\"expires\",{\"3\":{\"8\":1,\"10\":1}}],[\"expires和cache\",{\"3\":{\"8\":1}}],[\"example\",{\"3\":{\"13\":5}}],[\"etag的优先级会高一点\",{\"3\":{\"9\":1}}],[\"etag和if\",{\"3\":{\"9\":1}}],[\"mounted\",{\"3\":{\"265\":1,\"271\":1}}],[\"mounted生命周期\",{\"3\":{\"260\":1}}],[\"mounting\",{\"3\":{\"208\":1}}],[\"mount\",{\"3\":{\"183\":2}}],[\"mousedown\",{\"3\":{\"148\":1}}],[\"module\",{\"0\":{\"74\":1},\"2\":{\"74\":1}}],[\"modified和etag的值\",{\"3\":{\"9\":1}}],[\"modified和if\",{\"3\":{\"9\":1}}],[\"modified\",{\"3\":{\"9\":3,\"10\":2}}],[\"mycontext\",{\"3\":{\"202\":3,\"225\":3}}],[\"myage\",{\"3\":{\"65\":2}}],[\"myname\",{\"3\":{\"65\":2}}],[\"my\",{\"3\":{\"62\":1,\"70\":1,\"71\":1,\"72\":2,\"159\":2,\"160\":1}}],[\"m\",{\"3\":{\"62\":2,\"64\":1,\"67\":2,\"70\":2,\"71\":2,\"72\":8,\"159\":5,\"160\":3}}],[\"min\",{\"3\":{\"41\":1,\"42\":3,\"83\":4}}],[\"memo\",{\"2\":{\"277\":1}}],[\"memoizedprops\",{\"3\":{\"191\":1}}],[\"memoizedstate\",{\"3\":{\"191\":1}}],[\"meta\",{\"3\":{\"85\":1}}],[\"methods\",{\"3\":{\"16\":1}}],[\"methods字段\",{\"3\":{\"16\":1}}],[\"medium\",{\"3\":{\"52\":1}}],[\"mediatype\",{\"3\":{\"42\":1}}],[\"media\",{\"3\":{\"42\":5,\"43\":1}}],[\"media=\",{\"3\":{\"41\":2}}],[\"meidatype\",{\"3\":{\"42\":1}}],[\"mac头部包含源mac地址和目的mac地址\",{\"3\":{\"175\":1}}],[\"mac地址\",{\"0\":{\"175\":1},\"2\":{\"175\":1}}],[\"math\",{\"3\":{\"76\":1,\"79\":7,\"83\":4}}],[\"match的值和资源的最新修改时间或者etag的值进行对比\",{\"3\":{\"9\":1}}],[\"match字段\",{\"3\":{\"9\":1}}],[\"match\",{\"3\":{\"9\":1,\"10\":1,\"116\":1}}],[\"map返回的是啥\",{\"3\":{\"85\":1}}],[\"map和foreach区别\",{\"3\":{\"85\":1}}],[\"map\",{\"3\":{\"67\":1,\"107\":1,\"243\":1}}],[\"main\",{\"3\":{\"50\":1,\"183\":1}}],[\"margin塌陷问题\",{\"3\":{\"33\":1}}],[\"margin\",{\"3\":{\"25\":1}}],[\"maxage\",{\"3\":{\"8\":1}}],[\"max\",{\"3\":{\"8\":1,\"42\":2,\"83\":4}}],[\"控制协商缓存的字段有两组\",{\"3\":{\"9\":1}}],[\"由于涉及到dom结构的变化\",{\"3\":{\"261\":1}}],[\"由于只涉及到css的变化\",{\"3\":{\"261\":1}}],[\"由于表单元素的值由\",{\"3\":{\"228\":1,\"229\":1}}],[\"由内到外\",{\"3\":{\"148\":1}}],[\"由服务器根据缓存标识来决定是否使用缓存\",{\"3\":{\"9\":1}}],[\"由浏览器来决定\",{\"3\":{\"8\":1}}],[\"将一些幂等性的请求数据缓存到浏览器中\",{\"3\":{\"241\":1}}],[\"将一个数组转为用逗号分隔的参数序列\",{\"3\":{\"67\":1}}],[\"将静态资源缓存到浏览器中\",{\"3\":{\"241\":1}}],[\"将参数提升到父组件\",{\"3\":{\"224\":1}}],[\"将子组件的参数传递给父组件\",{\"3\":{\"222\":1}}],[\"将数据包转发到目的主机\",{\"3\":{\"177\":1}}],[\"将数组转化为字符串\",{\"3\":{\"108\":2}}],[\"将数组进行反转\",{\"3\":{\"106\":1}}],[\"将封装好的数据包传输到网络层\",{\"3\":{\"173\":1}}],[\"将属性变为实例属性\",{\"3\":{\"159\":1}}],[\"将父类的属性添加到子类的实例上\",{\"3\":{\"159\":1}}],[\"将其放入微任务队列\",{\"3\":{\"141\":6}}],[\"将其放入微任务队列中\",{\"3\":{\"141\":1}}],[\"将其放入宏任务队列\",{\"3\":{\"141\":4}}],[\"将其放入宏任务队列中\",{\"3\":{\"141\":1}}],[\"将注册的回调函数放入任务队列中\",{\"3\":{\"138\":1}}],[\"将对象转换为字符串\",{\"3\":{\"128\":1}}],[\"将null转化为0\",{\"3\":{\"119\":1}}],[\"将undefined转化为nan\",{\"3\":{\"119\":1}}],[\"将字符串按照separator分割成数组\",{\"3\":{\"115\":1}}],[\"将字符串转化为数组的方法\",{\"3\":{\"115\":1}}],[\"将字符串转化为小写\",{\"3\":{\"113\":1}}],[\"将两个数组合并并且去重\",{\"3\":{\"85\":1}}],[\"将伪数组转为真正的数组\",{\"3\":{\"67\":1}}],[\"将css放在head标签中\",{\"3\":{\"40\":1}}],[\"将css文件会存放在硬盘中\",{\"3\":{\"8\":1}}],[\"将\",{\"0\":{\"40\":1},\"2\":{\"40\":1}}],[\"将fn1的返回值给了fn3\",{\"3\":{\"4\":1}}],[\"硬盘缓存的优点是存储空间大\",{\"3\":{\"8\":1}}],[\"缓存内容将在这个时间之后失效\",{\"3\":{\"8\":1}}],[\"缓存机制\",{\"1\":{\"7\":1,\"8\":1,\"9\":1,\"10\":1,\"11\":1}}],[\"snapshot\",{\"3\":{\"216\":1}}],[\"switch\",{\"3\":{\"203\":1}}],[\"scrollheight时\",{\"3\":{\"239\":1}}],[\"scrollheight这三个属性的含义\",{\"3\":{\"239\":1}}],[\"scrollheight\",{\"3\":{\"239\":2}}],[\"scrollposition\",{\"3\":{\"234\":5,\"235\":3}}],[\"scrollref\",{\"3\":{\"234\":2,\"235\":4}}],[\"scrolly和window\",{\"3\":{\"239\":1}}],[\"scrolly可以获取当前滚动的位置\",{\"3\":{\"234\":1}}],[\"scrolly这两个方法\",{\"3\":{\"234\":1}}],[\"scrolly\",{\"3\":{\"234\":2,\"235\":1,\"239\":3,\"240\":1,\"242\":1}}],[\"scroll\",{\"3\":{\"234\":1,\"235\":1,\"239\":1,\"240\":1,\"242\":1}}],[\"scrolltop\",{\"3\":{\"235\":1}}],[\"scrollto可以跳转到指定位置\",{\"3\":{\"234\":1}}],[\"scrollto和window\",{\"3\":{\"234\":1}}],[\"scrollto\",{\"3\":{\"234\":2,\"235\":2}}],[\"script>\",{\"3\":{\"15\":1}}],[\"script\",{\"3\":{\"15\":6,\"141\":2}}],[\"scheduler会将这个reactelement放到fiber中\",{\"3\":{\"191\":1}}],[\"span\",{\"3\":{\"189\":1,\"190\":1}}],[\"span>\",{\"3\":{\"188\":1}}],[\"split\",{\"3\":{\"115\":1}}],[\"splice\",{\"3\":{\"102\":1,\"103\":1}}],[\"smtp\",{\"3\":{\"164\":1}}],[\"s1\",{\"3\":{\"159\":6,\"160\":2}}],[\"suspense>\",{\"3\":{\"240\":1}}],[\"suspense\",{\"3\":{\"240\":1}}],[\"sub\",{\"3\":{\"203\":2}}],[\"substring\",{\"3\":{\"112\":1}}],[\"substr\",{\"3\":{\"112\":1}}],[\"super可以调用原型方法和静态方法\",{\"3\":{\"160\":1}}],[\"super关键字的作用\",{\"3\":{\"160\":1}}],[\"super\",{\"3\":{\"160\":3,\"196\":1}}],[\"summer<\",{\"3\":{\"221\":1}}],[\"summer\",{\"3\":{\"61\":3,\"62\":2,\"65\":4,\"66\":6,\"67\":3,\"70\":2,\"71\":2,\"72\":4,\"82\":7,\"83\":8,\"159\":5,\"160\":2,\"221\":3,\"222\":4,\"223\":1,\"228\":1}}],[\"source\",{\"3\":{\"189\":1,\"191\":2}}],[\"some\",{\"3\":{\"107\":1}}],[\"sort\",{\"3\":{\"83\":1,\"106\":1}}],[\"slice\",{\"3\":{\"103\":1,\"112\":1}}],[\"show<\",{\"3\":{\"256\":1}}],[\"show=\",{\"3\":{\"256\":1}}],[\"show\",{\"1\":{\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"261\":1,\"262\":1},\"3\":{\"258\":3,\"259\":1,\"260\":1,\"261\":1}}],[\"shouldcomponentupdate会在组件重新渲染之前执行\",{\"3\":{\"212\":1}}],[\"shouldcomponentupdate\",{\"3\":{\"212\":1,\"216\":1}}],[\"shift\",{\"3\":{\"102\":1}}],[\"shrink和flex\",{\"3\":{\"50\":1}}],[\"shrink\",{\"3\":{\"50\":1}}],[\"symbol\",{\"0\":{\"92\":1},\"2\":{\"92\":1},\"3\":{\"189\":2}}],[\"sayhi\",{\"3\":{\"160\":1}}],[\"sayname\",{\"3\":{\"82\":7,\"83\":8}}],[\"say\",{\"3\":{\"70\":2,\"71\":2,\"72\":4,\"159\":6,\"160\":4}}],[\"siblings\",{\"3\":{\"191\":1}}],[\"sibling\",{\"3\":{\"191\":1}}],[\"side\",{\"3\":{\"25\":1}}],[\"size来计算\",{\"3\":{\"27\":2}}],[\"size\",{\"3\":{\"25\":1,\"50\":1}}],[\"sizing\",{\"3\":{\"19\":2}}],[\"sizing来进行设置\",{\"3\":{\"19\":1}}],[\"since和etag\",{\"3\":{\"10\":1}}],[\"since或者if\",{\"3\":{\"9\":2}}],[\"since\",{\"3\":{\"9\":1}}],[\"sex\",{\"3\":{\"249\":1}}],[\"secondspassed\",{\"3\":{\"206\":3}}],[\"search\",{\"3\":{\"116\":1}}],[\"separator\",{\"3\":{\"115\":1}}],[\"self\",{\"3\":{\"50\":1,\"189\":1}}],[\"server\",{\"3\":{\"16\":4}}],[\"setup\",{\"3\":{\"270\":1}}],[\"setarticles\",{\"3\":{\"243\":2}}],[\"setage\",{\"3\":{\"5\":4}}],[\"setloading\",{\"3\":{\"243\":2}}],[\"setnow\",{\"3\":{\"206\":3}}],[\"setname\",{\"3\":{\"204\":2,\"205\":2,\"222\":2,\"223\":2,\"228\":2}}],[\"setstarttime\",{\"3\":{\"206\":2}}],[\"setstate来修改状态的话\",{\"3\":{\"216\":1}}],[\"setstate\",{\"3\":{\"196\":1}}],[\"setcount\",{\"3\":{\"197\":1,\"200\":2,\"201\":2,\"202\":4,\"204\":2,\"205\":2,\"218\":2}}],[\"setitem\",{\"3\":{\"234\":2,\"235\":1}}],[\"setimmediate\",{\"3\":{\"140\":1,\"141\":2}}],[\"setinterval\",{\"3\":{\"140\":2,\"206\":1}}],[\"set\",{\"3\":{\"67\":1}}],[\"setheader\",{\"3\":{\"16\":4}}],[\"settimeout放入宏任务队列\",{\"3\":{\"141\":3}}],[\"settimeout是window的方法\",{\"3\":{\"61\":1}}],[\"settimeout\",{\"3\":{\"5\":6,\"61\":4,\"76\":1,\"79\":7,\"140\":1,\"141\":13}}],[\"stopwatch\",{\"3\":{\"206\":1}}],[\"store\",{\"3\":{\"8\":1}}],[\"state和nextstate\",{\"3\":{\"212\":1}}],[\"state发生变化\",{\"3\":{\"212\":1}}],[\"state来获取数据\",{\"3\":{\"211\":1}}],[\"state来进行修改状态\",{\"3\":{\"196\":1}}],[\"state\",{\"3\":{\"196\":4,\"197\":1,\"198\":3,\"200\":4,\"202\":2,\"203\":4,\"204\":1,\"205\":1,\"211\":3,\"212\":2,\"215\":6,\"228\":4,\"229\":1}}],[\"statenode\",{\"3\":{\"191\":1}}],[\"static\",{\"3\":{\"160\":1,\"215\":1}}],[\"starttime\",{\"3\":{\"206\":3}}],[\"start+length\",{\"3\":{\"112\":1}}],[\"start\",{\"3\":{\"102\":1,\"103\":2,\"112\":6,\"141\":4}}],[\"student\",{\"3\":{\"159\":8,\"160\":3}}],[\"stringref\",{\"3\":{\"191\":1}}],[\"string\",{\"0\":{\"88\":1},\"2\":{\"88\":1},\"3\":{\"191\":2,\"253\":1}}],[\"stringify\",{\"3\":{\"15\":1,\"128\":1,\"212\":1}}],[\"str\",{\"3\":{\"62\":2,\"67\":2}}],[\"style=\",{\"3\":{\"242\":1}}],[\"stylesheet\",{\"3\":{\"41\":3}}],[\"style\",{\"3\":{\"25\":5,\"41\":3,\"45\":4,\"189\":1,\"190\":1,\"242\":2,\"259\":1}}],[\"src\",{\"3\":{\"15\":1}}],[\"s\",{\"3\":{\"8\":1,\"67\":1,\"171\":1}}],[\"c2073362\",{\"0\":{\"180\":1}}],[\"chengname\",{\"3\":{\"222\":1}}],[\"changename修改父组件的\",{\"3\":{\"222\":1}}],[\"changename=\",{\"3\":{\"222\":1,\"223\":1}}],[\"changename\",{\"3\":{\"222\":5,\"223\":3}}],[\"change=\",{\"3\":{\"206\":1}}],[\"changedata\",{\"3\":{\"206\":2}}],[\"charat\",{\"3\":{\"114\":1}}],[\"child2\",{\"3\":{\"223\":3}}],[\"child1\",{\"3\":{\"223\":3}}],[\"child>\",{\"3\":{\"221\":1}}],[\"child\",{\"3\":{\"191\":2,\"202\":1,\"221\":1,\"222\":3}}],[\"children获取到子组件\",{\"3\":{\"221\":1}}],[\"children\",{\"3\":{\"189\":2,\"190\":5,\"221\":1}}],[\"children7\",{\"3\":{\"141\":2}}],[\"children6\",{\"3\":{\"141\":2}}],[\"children5\",{\"3\":{\"141\":2}}],[\"children4\",{\"3\":{\"141\":2}}],[\"children3\",{\"3\":{\"141\":2}}],[\"children2\",{\"3\":{\"141\":2}}],[\"clearinterval\",{\"3\":{\"206\":1}}],[\"click\",{\"3\":{\"148\":2,\"153\":4}}],[\"clonedeep\",{\"3\":{\"128\":1}}],[\"class等\",{\"3\":{\"189\":1}}],[\"classname\",{\"3\":{\"189\":2,\"190\":2}}],[\"classname=\",{\"3\":{\"188\":1}}],[\"class就是构造函数的语法糖\",{\"3\":{\"71\":1}}],[\"class\",{\"3\":{\"23\":1,\"24\":1,\"71\":1,\"72\":2,\"160\":4,\"196\":1,\"250\":1}}],[\"current\",{\"3\":{\"206\":3,\"229\":1,\"235\":2}}],[\"cur为数组的第二个元素\",{\"3\":{\"107\":1}}],[\"cur\",{\"3\":{\"107\":1}}],[\"cells\",{\"3\":{\"25\":1}}],[\"c\",{\"3\":{\"24\":2,\"57\":7,\"58\":3,\"59\":3,\"60\":3,\"64\":2,\"66\":2,\"127\":1}}],[\"css盒模型=＞box它是几部分组成的\",{\"3\":{\"85\":1}}],[\"css下载\",{\"3\":{\"38\":1}}],[\"css渲染阻塞是指浏览器在解析html时\",{\"3\":{\"37\":1}}],[\"css渲染阻塞\",{\"1\":{\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"41\":1,\"42\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":1}}],[\"css篇\",{\"1\":{\"36\":1}}],[\"css实现隐藏元素的方法\",{\"1\":{\"29\":1,\"30\":1}}],[\"css中的常见单位有以下几种\",{\"3\":{\"27\":1}}],[\"css中的单位\",{\"1\":{\"27\":1,\"28\":1}}],[\"css选择器\",{\"1\":{\"23\":1,\"24\":1,\"25\":1,\"26\":1}}],[\"css\",{\"0\":{\"37\":1,\"38\":1,\"39\":1,\"40\":1},\"2\":{\"37\":1,\"38\":1,\"39\":1,\"40\":1},\"3\":{\"19\":1,\"23\":1,\"24\":1,\"25\":1,\"37\":1,\"41\":3,\"42\":1,\"45\":2}}],[\"css的盒模型\",{\"1\":{\"19\":1,\"20\":1,\"21\":1,\"22\":1}}],[\"credentials\",{\"3\":{\"16\":1}}],[\"created\",{\"3\":{\"260\":1,\"264\":1}}],[\"createcontext\",{\"3\":{\"202\":1,\"225\":1}}],[\"createapp\",{\"0\":{\"183\":1},\"2\":{\"183\":1},\"3\":{\"183\":3}}],[\"createserver\",{\"3\":{\"16\":1}}],[\"createelement的形式\",{\"3\":{\"188\":2}}],[\"createelement\",{\"3\":{\"15\":1,\"189\":4,\"190\":2}}],[\"case\",{\"3\":{\"203\":2}}],[\"call的参数是一个一个传递的\",{\"3\":{\"83\":1}}],[\"call和apply的区别在于\",{\"3\":{\"83\":1}}],[\"call和apply都是改变this的指向\",{\"3\":{\"83\":1}}],[\"call和apply和bind的区别\",{\"0\":{\"83\":1},\"3\":{\"82\":1}}],[\"call\",{\"2\":{\"83\":1},\"3\":{\"82\":4,\"83\":4,\"84\":1,\"159\":2,\"160\":1}}],[\"callback=onback\",{\"3\":{\"15\":1}}],[\"catch\",{\"3\":{\"78\":1}}],[\"caption\",{\"3\":{\"25\":1}}],[\"cache\",{\"3\":{\"8\":4,\"10\":1}}],[\"count\",{\"3\":{\"113\":1,\"196\":4,\"197\":2,\"200\":3,\"201\":4,\"202\":5,\"203\":2,\"204\":6,\"205\":5,\"218\":3}}],[\"code\",{\"3\":{\"42\":1}}],[\"collapse\",{\"3\":{\"25\":1}}],[\"color\",{\"3\":{\"25\":2,\"52\":4}}],[\"cors\",{\"0\":{\"16\":1},\"2\":{\"16\":1},\"3\":{\"16\":1}}],[\"commit阶段负责执行任务\",{\"3\":{\"208\":1}}],[\"commit阶段合并为一个阶段\",{\"3\":{\"208\":1}}],[\"commit阶段\",{\"3\":{\"208\":2}}],[\"compile\",{\"3\":{\"264\":1}}],[\"computed\",{\"3\":{\"264\":2}}],[\"component的方法\",{\"3\":{\"218\":1}}],[\"componentwillunmount\",{\"3\":{\"213\":1,\"217\":1}}],[\"componentwillupdate\",{\"3\":{\"212\":1}}],[\"componentwillreceiveprops\",{\"3\":{\"212\":1}}],[\"componentwillmount\",{\"3\":{\"211\":1}}],[\"componentdidupdate和componentwillunmount这三个生命周期函数的集合\",{\"3\":{\"218\":1}}],[\"componentdidupdate和componentwillunmount这三个生命周期钩子的集合体\",{\"3\":{\"201\":1}}],[\"componentdidupdate和componentwillunmount这三个生命周期钩子\",{\"3\":{\"198\":1}}],[\"componentdidupdate\",{\"3\":{\"212\":1,\"216\":1}}],[\"componentdidmount\",{\"3\":{\"211\":1}}],[\"component\",{\"3\":{\"196\":2,\"221\":1,\"222\":1,\"223\":1}}],[\"compare\",{\"3\":{\"122\":1}}],[\"com\",{\"3\":{\"13\":5,\"15\":1,\"171\":1}}],[\"concat\",{\"3\":{\"102\":1,\"111\":1,\"126\":1}}],[\"contextvalue\",{\"3\":{\"225\":2}}],[\"context的使用分为三步\",{\"3\":{\"225\":1}}],[\"context是\",{\"3\":{\"225\":1}}],[\"context\",{\"0\":{\"225\":1},\"2\":{\"225\":1},\"3\":{\"31\":1,\"225\":4}}],[\"content\",{\"3\":{\"16\":1,\"19\":3,\"20\":2,\"21\":2,\"49\":2,\"52\":1}}],[\"control的优先级要高于expires\",{\"3\":{\"8\":1}}],[\"control的值有很多\",{\"3\":{\"8\":1}}],[\"control替换了\",{\"3\":{\"8\":1}}],[\"control\",{\"3\":{\"8\":2,\"10\":1,\"16\":6}}],[\"consumer\",{\"3\":{\"225\":1}}],[\"console\",{\"3\":{\"4\":2,\"5\":7,\"16\":1,\"57\":12,\"58\":6,\"59\":3,\"60\":3,\"61\":9,\"62\":1,\"64\":3,\"65\":3,\"66\":4,\"67\":4,\"70\":1,\"71\":1,\"72\":4,\"76\":2,\"79\":6,\"82\":4,\"83\":10,\"132\":2,\"133\":3,\"134\":3,\"135\":2,\"141\":39,\"145\":1,\"147\":1,\"148\":1,\"152\":4,\"153\":4,\"159\":3,\"160\":4,\"201\":2,\"204\":1,\"205\":1,\"206\":1,\"218\":2,\"221\":1,\"229\":1,\"251\":1}}],[\"constructor\",{\"3\":{\"71\":2,\"72\":2,\"155\":1,\"160\":4,\"196\":1,\"211\":1,\"215\":1,\"250\":1}}],[\"const声明的变量不会被提升到代码的最前面\",{\"3\":{\"58\":1}}],[\"const\",{\"0\":{\"54\":1},\"2\":{\"54\":1},\"3\":{\"3\":1,\"16\":2,\"57\":3,\"58\":1,\"59\":2,\"60\":1,\"61\":2,\"62\":3,\"64\":6,\"65\":5,\"67\":13,\"70\":1,\"71\":1,\"72\":2,\"76\":2,\"79\":14,\"82\":4,\"83\":13,\"159\":3,\"160\":1,\"183\":2,\"189\":2,\"200\":1,\"201\":1,\"202\":3,\"203\":1,\"204\":3,\"205\":3,\"206\":5,\"218\":1,\"222\":2,\"223\":2,\"225\":1,\"228\":1,\"229\":2,\"234\":4,\"235\":5,\"239\":1,\"240\":5,\"242\":2,\"243\":3}}],[\"c0145384\",{\"0\":{\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"16\":1,\"17\":1,\"18\":1}}],[\"资源已经发生了变化\",{\"3\":{\"8\":1}}],[\"服务器可以接收任何请求\",{\"3\":{\"17\":1}}],[\"服务器完全可以不遵守同源策略\",{\"3\":{\"17\":1}}],[\"服务器接受到请求后\",{\"3\":{\"9\":1}}],[\"服务器的时间和浏览器的时间可能就一致了\",{\"3\":{\"8\":1}}],[\"服务器会将资源的缓存策略一起返回给浏览器\",{\"3\":{\"8\":1}}],[\"即使父组件传递给子组件的props没有发生改变\",{\"3\":{\"212\":1}}],[\"即使创建它的上下文已经销毁\",{\"3\":{\"4\":1}}],[\"即发送方会向网络中的所有主机发送请求\",{\"3\":{\"175\":1}}],[\"即先向根域名服务器发送请求\",{\"3\":{\"172\":1}}],[\"即在冒泡阶段执行事件处理程序\",{\"3\":{\"153\":1}}],[\"即如果空间不足\",{\"3\":{\"50\":1}}],[\"即如果存在剩余空间\",{\"3\":{\"50\":1}}],[\"即块级格式化上下文\",{\"3\":{\"31\":1}}],[\"即到了这个时间\",{\"3\":{\"8\":2}}],[\"强制缓存优先于协商缓存进行\",{\"3\":{\"10\":1}}],[\"强制缓存主要使用的是响应头中的两个字段\",{\"3\":{\"8\":1}}],[\"强制缓存\",{\"0\":{\"8\":1},\"2\":{\"8\":1},\"3\":{\"7\":1}}],[\"而memo是将组件的props缓存起来\",{\"3\":{\"277\":1}}],[\"而usememo函数返回的是一个值\",{\"3\":{\"205\":1}}],[\"而undefined是一个未定义的值\",{\"3\":{\"135\":1}}],[\"而handleclick的重新创建\",{\"3\":{\"205\":1}}],[\"而double的重新计算\",{\"3\":{\"204\":1}}],[\"而props只能在父子组件之间传递参数\",{\"3\":{\"202\":1}}],[\"而prefetch用来指定当前页面可能会用到的资源\",{\"3\":{\"45\":1}}],[\"而\",{\"3\":{\"190\":2}}],[\"而在使用的时候再指定类型\",{\"3\":{\"246\":1}}],[\"而在使用的时候再指定类型的一种特性\",{\"3\":{\"246\":1}}],[\"而在\",{\"3\":{\"190\":1}}],[\"而是需要使用torefs将其转换为ref的形式\",{\"3\":{\"270\":1}}],[\"而是直接从react的包中引入jsx的运行时\",{\"3\":{\"188\":1}}],[\"而是通过一些路由器相连的\",{\"3\":{\"167\":1}}],[\"而接收方的mac地址是通过arp协议获取的\",{\"3\":{\"175\":1}}],[\"而settmmdiate属于宏任务\",{\"3\":{\"141\":1}}],[\"而其他任务都必须在后面排队等待\",{\"3\":{\"137\":1}}],[\"而null转化为数字是0\",{\"3\":{\"91\":1}}],[\"而null的类型是object\",{\"3\":{\"91\":1}}],[\"而null是一个空对象指针\",{\"3\":{\"91\":1}}],[\"而null是一个关键字\",{\"3\":{\"91\":1}}],[\"而apply的参数是一个数组\",{\"3\":{\"83\":1}}],[\"而bind是返回一个新的函数\",{\"3\":{\"83\":1}}],[\"而call又改变了this的指向\",{\"3\":{\"82\":1}}],[\"而const声明的变量是不可变的\",{\"3\":{\"60\":1}}],[\"而使用时是window调用的\",{\"3\":{\"61\":1}}],[\"而let和const声明的变量不能被重复声明\",{\"3\":{\"59\":1}}],[\"而且泛型帮助我们在代码编译的时候就知道我们传入的参数类型\",{\"3\":{\"246\":1}}],[\"而且还能够保证数据的顺序\",{\"3\":{\"165\":1}}],[\"而且不会丢失\",{\"3\":{\"165\":1}}],[\"而且不会随着浏览器的关闭而释放\",{\"3\":{\"8\":1}}],[\"而且bind的第一个参数是不能被改变的\",{\"3\":{\"83\":1}}],[\"而且后面的声明会覆盖前面的声明\",{\"3\":{\"59\":1}}],[\"而且会随着浏览器\",{\"3\":{\"8\":1}}],[\"而不是销毁它们\",{\"3\":{\"275\":1}}],[\"而不是ref的\",{\"3\":{\"270\":1}}],[\"而不是传递给onclick\",{\"3\":{\"222\":1}}],[\"而不是调用\",{\"3\":{\"222\":1}}],[\"而不是域名\",{\"3\":{\"174\":1}}],[\"而不是使用时所在的对象\",{\"3\":{\"61\":1}}],[\"而不是由服务器来决定\",{\"3\":{\"8\":1}}],[\"而不是再次向服务器发起请求\",{\"3\":{\"7\":1}}],[\"而全局作用域中的i在循环结束后\",{\"3\":{\"5\":1}}],[\"对应的\",{\"3\":{\"191\":5}}],[\"对应的组件的状态\",{\"3\":{\"191\":1}}],[\"对应的组件\",{\"3\":{\"191\":1}}],[\"对方法进行重写\",{\"3\":{\"160\":1}}],[\"对于文章列表\",{\"3\":{\"242\":1,\"243\":1}}],[\"对于静态资源\",{\"3\":{\"241\":1}}],[\"对于图片\",{\"3\":{\"240\":1}}],[\"对于数据\",{\"3\":{\"239\":1}}],[\"对于键盘操作这类\",{\"3\":{\"148\":1}}],[\"对于鼠标操作这类\",{\"3\":{\"148\":1}}],[\"对于一些重复性的请求\",{\"3\":{\"7\":1}}],[\"对每个元素进行操作\",{\"3\":{\"107\":6}}],[\"对类添加方法\",{\"0\":{\"72\":1},\"2\":{\"72\":1}}],[\"对象的\",{\"3\":{\"76\":1,\"79\":2}}],[\"对象的解构赋值\",{\"0\":{\"65\":1},\"2\":{\"65\":1}}],[\"对象\",{\"3\":{\"76\":1,\"79\":3,\"121\":2}}],[\"对象之前出现相互引用的情况\",{\"3\":{\"2\":1}}],[\"是通过控制元素的\",{\"3\":{\"258\":2}}],[\"是为了更好的复用\",{\"3\":{\"252\":1}}],[\"是不是进入可视区域\",{\"3\":{\"240\":1}}],[\"是不是使用缓存\",{\"3\":{\"8\":1}}],[\"是唯一数据源\",{\"3\":{\"228\":1}}],[\"是什么\",{\"3\":{\"226\":1}}],[\"是一种广播的方式\",{\"3\":{\"175\":1}}],[\"是一个函数\",{\"3\":{\"190\":1}}],[\"是一个一个的传递的\",{\"3\":{\"83\":1}}],[\"是一个独立的渲染区域\",{\"3\":{\"31\":1}}],[\"是一个相对单位\",{\"3\":{\"27\":1}}],[\"是一个相对时间\",{\"3\":{\"8\":1}}],[\"是一个字符串\",{\"3\":{\"9\":1}}],[\"是一个绝对时间\",{\"3\":{\"8\":1}}],[\"是一个闭包\",{\"3\":{\"4\":1}}],[\"是否类似于\",{\"2\":{\"277\":1}}],[\"是否相等\",{\"3\":{\"212\":1}}],[\"是否丢失\",{\"3\":{\"165\":1}}],[\"是否重复\",{\"3\":{\"165\":1}}],[\"是否在捕获阶段执行事件处理程序\",{\"3\":{\"153\":1}}],[\"是否显示表格中的空单元格\",{\"3\":{\"25\":1}}],[\"是单线程的\",{\"3\":{\"137\":1}}],[\"是resolve或reject的回调函数\",{\"3\":{\"78\":1}}],[\"是reject的回调函数\",{\"3\":{\"78\":1}}],[\"是类的方法\",{\"3\":{\"71\":1}}],[\"是window调用的\",{\"3\":{\"61\":1}}],[\"是\",{\"3\":{\"29\":8,\"189\":1}}],[\"是相对于父元素的宽度来计算的\",{\"3\":{\"27\":1}}],[\"是浏览器对javascript施加的安全限制\",{\"3\":{\"12\":1}}],[\"是由服务器来设置的\",{\"3\":{\"8\":1}}],[\"是指浏览器对于静态资源的缓存策略\",{\"3\":{\"7\":1}}],[\"浏览器窗口的视口\",{\"3\":{\"239\":1}}],[\"浏览器解析\",{\"0\":{\"171\":1},\"2\":{\"171\":1}}],[\"浏览器规定\",{\"3\":{\"13\":1}}],[\"浏览器就会自动发送一个预检请求\",{\"3\":{\"16\":1}}],[\"浏览器就会使用最新的资源\",{\"3\":{\"9\":1}}],[\"浏览器就会使用缓存\",{\"3\":{\"9\":1}}],[\"浏览器就会向服务器发起请求\",{\"3\":{\"8\":2}}],[\"浏览器再次发送请求到服务器\",{\"3\":{\"9\":1}}],[\"浏览器强制缓存\",{\"3\":{\"8\":1}}],[\"浏览器缓存主要分为两种\",{\"3\":{\"8\":1}}],[\"浏览器缓存\",{\"3\":{\"8\":1,\"10\":1}}],[\"浏览器缓存机制又可以称为是http缓存机制`\",{\"3\":{\"7\":1}}],[\"浏览器会先检查本地缓存中是否有该网址对应的ip地址\",{\"3\":{\"172\":1}}],[\"浏览器会先检查本地缓存中是否有该网址对应的资源\",{\"3\":{\"171\":1}}],[\"浏览器会解析网址\",{\"3\":{\"171\":1}}],[\"浏览器会判断输入的网址是搜索内容还是网址\",{\"3\":{\"171\":1}}],[\"浏览器会携带缓存标识向服务器发起请求\",{\"3\":{\"9\":1}}],[\"浏览器会将其转换为https\",{\"3\":{\"171\":1}}],[\"浏览器会将这个请求拦截下来\",{\"3\":{\"13\":1}}],[\"浏览器会将js和图片解析完成后将他们放在内存缓存中\",{\"3\":{\"8\":1}}],[\"浏览器会将请求的资源缓存起来\",{\"3\":{\"7\":1}}],[\"浏览器会根据缓存策略来决定是否缓存资源\",{\"3\":{\"8\":1}}],[\"浏览器在第一次请求资源时\",{\"3\":{\"8\":1}}],[\"浏览器篇\",{\"1\":{\"0\":1}}],[\"在组件实例创建之后\",{\"3\":{\"270\":1}}],[\"在组件章节被移除时调用\",{\"3\":{\"268\":1,\"274\":1}}],[\"在组件章节被激活时调用\",{\"3\":{\"268\":1,\"274\":1}}],[\"在组件初始化渲染的时候不会执行\",{\"3\":{\"212\":1}}],[\"在由于数据更改导致的虚拟dom重新渲染和打补丁之后被调用\",{\"3\":{\"266\":1,\"272\":1}}],[\"在挂载完成后被调用\",{\"3\":{\"265\":1,\"271\":1}}],[\"在挂载开始之前被调用\",{\"3\":{\"265\":1,\"271\":1}}],[\"在实例销毁之后调用\",{\"3\":{\"267\":1,\"273\":1}}],[\"在实例销毁之前调用\",{\"3\":{\"267\":1,\"273\":1}}],[\"在实例创建完成后被立即调用\",{\"3\":{\"264\":1}}],[\"在实例初始化之后\",{\"3\":{\"264\":1}}],[\"在实际生活\",{\"3\":{\"167\":1}}],[\"在编译过程中\",{\"3\":{\"259\":2}}],[\"在需要使用参数的组件中\",{\"3\":{\"225\":1}}],[\"在兄弟组件通信中\",{\"3\":{\"223\":1}}],[\"在子组件可能会需要修改父组件传递过来的参数\",{\"3\":{\"222\":1}}],[\"在子类中\",{\"3\":{\"159\":1}}],[\"在这个生命周期中我们可以将组件的状态保存起来\",{\"3\":{\"281\":1}}],[\"在这个生命周期中我们可以重新激活组件\",{\"3\":{\"280\":1}}],[\"在这个钩子里\",{\"3\":{\"265\":1}}],[\"在这个钩子里面可以最早拿到新的props\",{\"3\":{\"212\":1}}],[\"在这个阶段已经完成init\",{\"3\":{\"264\":1}}],[\"在这个阶段\",{\"3\":{\"264\":2}}],[\"在这个方法中返回的任何值都会作为参数传递给componentdidupdate的第三个参数\",{\"3\":{\"216\":1}}],[\"在这个执行环境中\",{\"3\":{\"148\":1}}],[\"在fiber被创建完以后\",{\"3\":{\"192\":1}}],[\"在react中\",{\"3\":{\"234\":1,\"240\":1,\"242\":1}}],[\"在reactelement被创建完以后\",{\"3\":{\"191\":1}}],[\"在react17以后\",{\"3\":{\"188\":1}}],[\"在项目中\",{\"3\":{\"181\":1}}],[\"在数据更新之前被调用\",{\"3\":{\"266\":1,\"272\":1}}],[\"在数据链路层\",{\"3\":{\"175\":1}}],[\"在数组中间添加元素\",{\"3\":{\"102\":1}}],[\"在数组开头添加元素\",{\"3\":{\"102\":1}}],[\"在数组末尾添加元素\",{\"3\":{\"102\":1}}],[\"在dns解析完成以后\",{\"3\":{\"172\":1}}],[\"在寻址过程中\",{\"3\":{\"167\":1}}],[\"在那里调用\",{\"3\":{\"145\":1}}],[\"在宏任务队列中\",{\"3\":{\"141\":3}}],[\"在微任务队列中\",{\"3\":{\"141\":2}}],[\"在javascript中\",{\"3\":{\"132\":1}}],[\"在还未执行到resolve或reject时\",{\"3\":{\"76\":1}}],[\"在原型链上添加方法\",{\"3\":{\"72\":1}}],[\"在\",{\"0\":{\"189\":1,\"190\":1},\"2\":{\"189\":1,\"190\":1},\"3\":{\"67\":2}}],[\"在函数内部可以访问到的变量和函数\",{\"3\":{\"57\":1}}],[\"在函数中使用settimeout\",{\"3\":{\"5\":1}}],[\"在大括号内可以访问到的变量和函数\",{\"3\":{\"57\":1}}],[\"在代码的任何地方都可以访问到的变量和函数\",{\"3\":{\"57\":1}}],[\"在空间有剩余的情况下\",{\"3\":{\"50\":2}}],[\"在空间不足的情况下\",{\"3\":{\"50\":2}}],[\"在主轴上如何对齐\",{\"3\":{\"49\":1}}],[\"在副轴上如何对齐\",{\"3\":{\"49\":1}}],[\"在css中通过box\",{\"3\":{\"19\":1}}],[\"在每次循环时\",{\"3\":{\"5\":1}}],[\"+1\",{\"3\":{\"196\":1}}],[\"+this\",{\"3\":{\"160\":4}}],[\"+\",{\"3\":{\"5\":2,\"16\":2,\"19\":2,\"20\":4,\"21\":4,\"23\":2,\"111\":1,\"119\":9,\"196\":1,\"197\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1,\"218\":1,\"239\":2,\"240\":1,\"242\":1}}],[\"button>\",{\"3\":{\"196\":1,\"197\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":2,\"204\":2,\"205\":3,\"206\":2,\"218\":1,\"222\":3,\"223\":1,\"229\":1}}],[\"b53997e2\",{\"0\":{\"181\":1,\"182\":1,\"183\":1,\"184\":1}}],[\"bce0ae32\",{\"0\":{\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":1}}],[\"bind改变了this的指向\",{\"3\":{\"82\":1}}],[\"bind\",{\"2\":{\"83\":1},\"3\":{\"82\":3,\"83\":2,\"84\":1}}],[\"blue\",{\"3\":{\"52\":1}}],[\"block\",{\"3\":{\"31\":1,\"258\":1}}],[\"base<t>\",{\"3\":{\"250\":1}}],[\"basis的简写\",{\"3\":{\"50\":1}}],[\"basis\",{\"3\":{\"50\":1}}],[\"baidu\",{\"3\":{\"171\":1}}],[\"bar\",{\"3\":{\"145\":2}}],[\"background\",{\"3\":{\"52\":4}}],[\"bfc的特性\",{\"0\":{\"33\":1},\"2\":{\"33\":1}}],[\"bfc\",{\"3\":{\"31\":2}}],[\"bfc布局\",{\"1\":{\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1}}],[\"beforedestroy\",{\"3\":{\"267\":1}}],[\"beforeupdate\",{\"3\":{\"266\":1}}],[\"beforecreate\",{\"3\":{\"264\":1}}],[\"beforemount\",{\"3\":{\"260\":1,\"265\":1}}],[\"before\",{\"3\":{\"23\":1}}],[\"body\",{\"3\":{\"239\":4}}],[\"boolean\",{\"0\":{\"89\":1},\"2\":{\"89\":1},\"3\":{\"89\":2,\"118\":1}}],[\"box\",{\"3\":{\"19\":4}}],[\"border+margin\",{\"3\":{\"20\":2}}],[\"border\",{\"3\":{\"19\":2,\"21\":2,\"25\":5}}],[\"b\",{\"3\":{\"5\":4,\"24\":2,\"57\":7,\"58\":3,\"59\":3,\"60\":3,\"64\":2,\"66\":2,\"67\":2,\"83\":2,\"127\":3}}],[\"当props发生变化时\",{\"3\":{\"277\":1}}],[\"当组件被激活时\",{\"3\":{\"277\":1}}],[\"当父组件发生更新\",{\"0\":{\"276\":1},\"2\":{\"276\":1}}],[\"当捕获一个来自子孙组件的错误时被调用\",{\"3\":{\"268\":1}}],[\"当isshow从true变为false时\",{\"3\":{\"260\":1}}],[\"当isshow从false变为true时\",{\"3\":{\"260\":1}}],[\"当文章加载完成后\",{\"3\":{\"243\":2}}],[\"当文章在可视区域时\",{\"3\":{\"242\":1}}],[\"当然你也可以使用intersectionobserver来实现图片懒加载\",{\"3\":{\"240\":1}}],[\"当然我们通过props不仅只能获取到参数\",{\"3\":{\"221\":1}}],[\"当这个值等于document\",{\"3\":{\"239\":1}}],[\"当滚动事件触发时\",{\"3\":{\"235\":1}}],[\"当路由参数id发生变化时\",{\"3\":{\"235\":1}}],[\"当再次打开页面时\",{\"3\":{\"234\":1,\"235\":1}}],[\"当一个组件从页面上被移除之前执行\",{\"3\":{\"213\":1,\"217\":1}}],[\"当一个组件从父组件接收到新的props之前执行\",{\"3\":{\"212\":1}}],[\"当一个组件被重新渲染之后执行\",{\"3\":{\"212\":1,\"216\":1}}],[\"当一个组件要被重新渲染之前执行\",{\"3\":{\"212\":1}}],[\"当一个组件接收到新的props或者state之后\",{\"3\":{\"212\":1}}],[\"当一个变量声明了但是没有赋值时\",{\"3\":{\"132\":1}}],[\"当你的组件需要保存一些不需要导致视图更新的数据时\",{\"3\":{\"206\":1}}],[\"当`app`组件加载好了之后\",{\"3\":{\"183\":1}}],[\"当应用层需要传递的数据非常大\",{\"3\":{\"166\":1}}],[\"当数据从一端传到另一端的时候\",{\"3\":{\"167\":1}}],[\"当数据传到另一端时\",{\"3\":{\"165\":1}}],[\"当数组中的每一个promise对象都变为resolved状态时\",{\"3\":{\"79\":1}}],[\"当我们点击div3时\",{\"3\":{\"152\":1}}],[\"当用户滚动时\",{\"3\":{\"242\":2}}],[\"当用户滚动到图片位置时\",{\"3\":{\"240\":2}}],[\"当用户滚动到页面底部时\",{\"3\":{\"239\":3}}],[\"当用户再次访问时\",{\"3\":{\"241\":2}}],[\"当用户打开首页时\",{\"3\":{\"237\":1}}],[\"当用户点击ul的子元素时\",{\"3\":{\"148\":1}}],[\"当用户想要修改服务器数据的时候\",{\"3\":{\"16\":1}}],[\"当访问一个变量时\",{\"3\":{\"144\":1}}],[\"当前宏任务队列中的任务执行完毕\",{\"3\":{\"141\":1}}],[\"当主线程空闲时\",{\"3\":{\"140\":1}}],[\"当weakmap的键名所指向的对象被回收\",{\"3\":{\"127\":1}}],[\"当obj被回收的时候\",{\"3\":{\"127\":1}}],[\"当对象和它所引用的对象一起拷贝时即发生深拷贝\",{\"3\":{\"127\":1}}],[\"当使用new操作符构造函数时\",{\"3\":{\"83\":1}}],[\"当符合某种条件的时候才会阻塞渲染\",{\"3\":{\"41\":1}}],[\"当浏览器开始解析html文件时\",{\"3\":{\"38\":1}}],[\"当浏览器在发送跨域请求的时候\",{\"3\":{\"16\":1}}],[\"当服务器看到这些额外的参数\",{\"3\":{\"15\":1}}],[\"当强制缓存失效后\",{\"3\":{\"9\":1}}],[\"当强制缓存失效以后\",{\"3\":{\"9\":1}}],[\"当下次请求时\",{\"3\":{\"7\":1}}],[\"当需要在某个时间点上执行函数\",{\"3\":{\"5\":1}}],[\"当settimeout执行时\",{\"3\":{\"5\":1}}],[\"张三\",{\"3\":{\"5\":1,\"204\":1,\"205\":1}}],[\"p>\",{\"3\":{\"218\":1,\"234\":1,\"235\":1}}],[\"pop\",{\"3\":{\"103\":1}}],[\"position\",{\"3\":{\"25\":1,\"29\":1,\"30\":1,\"32\":1}}],[\"post\",{\"3\":{\"16\":1,\"234\":1,\"235\":2}}],[\"pure\",{\"3\":{\"189\":3,\"190\":3}}],[\"push\",{\"3\":{\"83\":1,\"102\":1}}],[\"put\",{\"3\":{\"16\":1}}],[\"p3\",{\"3\":{\"79\":4}}],[\"p2\",{\"3\":{\"79\":4}}],[\"pending\",{\"3\":{\"77\":1}}],[\"person\",{\"3\":{\"5\":2,\"70\":3,\"71\":2,\"72\":6,\"83\":4,\"159\":10,\"160\":3}}],[\"provider>\",{\"3\":{\"202\":1,\"225\":1}}],[\"provider\",{\"3\":{\"202\":1,\"225\":2}}],[\"proto\",{\"3\":{\"156\":2}}],[\"prototype\",{\"3\":{\"70\":1,\"72\":2,\"126\":1,\"155\":1,\"159\":5}}],[\"process\",{\"3\":{\"140\":1,\"141\":3}}],[\"promise放入微任务队列\",{\"3\":{\"141\":3}}],[\"promise2\",{\"3\":{\"141\":2}}],[\"promise1\",{\"3\":{\"141\":1}}],[\"promise对象的状态为pending\",{\"3\":{\"76\":1}}],[\"promise对象是一个构造函数\",{\"3\":{\"76\":1}}],[\"promise\",{\"0\":{\"75\":1,\"76\":1,\"77\":1},\"2\":{\"75\":1,\"76\":1,\"77\":1},\"3\":{\"76\":3,\"79\":15,\"140\":2,\"141\":14}}],[\"props和context都已经解析完成\",{\"3\":{\"270\":1}}],[\"props和this\",{\"3\":{\"211\":1}}],[\"props就是一个对象\",{\"3\":{\"221\":1}}],[\"props\",{\"3\":{\"67\":1,\"189\":6,\"190\":2,\"196\":2,\"197\":4,\"215\":1,\"216\":1,\"221\":4,\"222\":5,\"223\":4,\"264\":2}}],[\"prestate\",{\"3\":{\"211\":1,\"212\":1,\"216\":2}}],[\"preprops\",{\"3\":{\"211\":1,\"212\":1,\"216\":2}}],[\"pre\",{\"3\":{\"208\":1}}],[\"prev\",{\"3\":{\"107\":1}}],[\"premise\",{\"3\":{\"85\":1}}],[\"prefetch\",{\"2\":{\"45\":1},\"3\":{\"45\":2}}],[\"preload用来指定当前页面必须要用到的资源\",{\"3\":{\"45\":1}}],[\"preload和prefetch是html5中的新特性\",{\"3\":{\"45\":1}}],[\"preload\",{\"2\":{\"45\":1},\"3\":{\"45\":2}}],[\"print等\",{\"3\":{\"42\":1}}],[\"print\",{\"3\":{\"41\":1,\"43\":1}}],[\"px\",{\"3\":{\"27\":1,\"85\":1}}],[\"p\",{\"3\":{\"23\":7}}],[\"parent\",{\"3\":{\"221\":1,\"222\":1,\"223\":1}}],[\"parse\",{\"3\":{\"128\":1}}],[\"parseint\",{\"3\":{\"87\":2,\"118\":1}}],[\"padend\",{\"3\":{\"113\":1}}],[\"padstring\",{\"3\":{\"113\":2}}],[\"padstart\",{\"3\":{\"113\":1}}],[\"padding\",{\"3\":{\"19\":1,\"20\":2,\"21\":2,\"25\":1}}],[\"patch\",{\"3\":{\"16\":1}}],[\"page\",{\"3\":{\"13\":4}}],[\"p1\",{\"3\":{\"5\":3,\"70\":2,\"71\":2,\"72\":6,\"76\":2,\"79\":6}}],[\"私有变量\",{\"3\":{\"5\":1}}],[\"nextstate\",{\"3\":{\"212\":2,\"216\":1}}],[\"nextprops\",{\"3\":{\"212\":3,\"216\":1}}],[\"nexttick的优先级比promise高\",{\"3\":{\"141\":1}}],[\"nexttick属于微任务\",{\"3\":{\"141\":1}}],[\"nexttick和setimmediate\",{\"3\":{\"141\":1}}],[\"nexttick\",{\"3\":{\"141\":6}}],[\"nexttick等等\",{\"3\":{\"140\":1}}],[\"network篇\",{\"1\":{\"163\":1}}],[\"new绑定\",{\"3\":{\"83\":1}}],[\"new\",{\"3\":{\"61\":1,\"70\":1,\"71\":1,\"72\":2,\"76\":1,\"79\":7,\"83\":1,\"141\":1,\"159\":5,\"160\":1,\"239\":1,\"240\":1}}],[\"number或者symbol\",{\"3\":{\"121\":1}}],[\"number\",{\"0\":{\"87\":1},\"2\":{\"87\":1},\"3\":{\"87\":2,\"135\":3,\"251\":1,\"253\":1}}],[\"num\",{\"3\":{\"76\":4,\"79\":28}}],[\"null转化为0\",{\"3\":{\"135\":1}}],[\"null和undefined都会转换为false\",{\"3\":{\"134\":1}}],[\"null和undefined是相等的\",{\"3\":{\"134\":1}}],[\"null和undefined的区别\",{\"1\":{\"132\":1,\"133\":1,\"134\":1,\"135\":1,\"136\":1}}],[\"null的值是object\",{\"3\":{\"133\":1}}],[\"null表示当前这个值\",{\"3\":{\"133\":1}}],[\"null除外\",{\"3\":{\"127\":1}}],[\"null会返回object\",{\"3\":{\"90\":1}}],[\"null\",{\"0\":{\"90\":1,\"133\":1,\"134\":1,\"135\":1},\"2\":{\"90\":1,\"133\":1,\"134\":1,\"135\":1},\"3\":{\"4\":2,\"83\":2,\"85\":1,\"87\":2,\"89\":1,\"91\":1,\"119\":1,\"121\":1,\"122\":3,\"123\":2,\"133\":4,\"134\":4,\"135\":1,\"189\":2,\"191\":6,\"206\":6,\"229\":1,\"234\":1,\"235\":1}}],[\"nan和任何值都不相等\",{\"3\":{\"121\":1}}],[\"nan\",{\"3\":{\"87\":7,\"89\":1,\"121\":2,\"122\":2,\"135\":1}}],[\"nav\",{\"3\":{\"24\":2}}],[\"name=\",{\"3\":{\"221\":1,\"223\":1}}],[\"name+\",{\"3\":{\"160\":1}}],[\"name\",{\"3\":{\"5\":3,\"61\":4,\"62\":4,\"65\":7,\"66\":9,\"67\":2,\"70\":6,\"71\":6,\"72\":12,\"82\":5,\"83\":10,\"159\":20,\"160\":16,\"204\":2,\"205\":2,\"221\":2,\"222\":6,\"223\":5,\"228\":2,\"249\":1,\"250\":4,\"252\":1,\"253\":1}}],[\"now\",{\"3\":{\"206\":6}}],[\"nowrap\",{\"3\":{\"49\":1}}],[\"not\",{\"3\":{\"42\":1}}],[\"not|only\",{\"3\":{\"42\":1}}],[\"nodejs\",{\"3\":{\"16\":1}}],[\"none\",{\"3\":{\"9\":3,\"10\":1,\"29\":2,\"30\":1,\"50\":1,\"258\":1}}],[\"no\",{\"3\":{\"8\":2}}],[\"n\",{\"3\":{\"5\":2,\"64\":1}}],[\"那么子组件会调用上面三个函数\",{\"3\":{\"276\":1}}],[\"那么子组件的生命周期同样也会发生更新\",{\"3\":{\"276\":1}}],[\"那么子组件的生命周期会发生怎么样的变化\",{\"0\":{\"276\":1},\"2\":{\"276\":1}}],[\"那么这个组件会被缓存\",{\"3\":{\"275\":1}}],[\"那么这个组件就不会被重新渲染\",{\"3\":{\"212\":1}}],[\"那么该元素的事件监听器也会被移除\",{\"3\":{\"258\":1}}],[\"那么\",{\"3\":{\"258\":4}}],[\"那么你就需要一层一层的传递参数\",{\"3\":{\"223\":1}}],[\"那么你的组件的层级是不能太深的\",{\"3\":{\"223\":1}}],[\"那么兄弟组件就可以通过父组件来通信了\",{\"3\":{\"223\":1}}],[\"那么因变量就会重新创建\",{\"3\":{\"205\":1}}],[\"那么因变量就会重新计算\",{\"3\":{\"204\":1}}],[\"那么视图就会发生变化\",{\"3\":{\"204\":1,\"205\":1}}],[\"那么首页的数据还未加载\",{\"3\":{\"181\":1}}],[\"那么我们就来谈谈\",{\"3\":{\"148\":1}}],[\"那么工作量很大\",{\"3\":{\"148\":1}}],[\"那么异步任务又分为很多种\",{\"3\":{\"140\":1}}],[\"那么weakmap的键名和键值也会被回收\",{\"3\":{\"127\":1}}],[\"那么比较的是两个对象的引用是否相等\",{\"3\":{\"121\":1}}],[\"那么会将对象转换为原始类型的值\",{\"3\":{\"121\":1}}],[\"那么会将布尔值\",{\"3\":{\"121\":1}}],[\"那么会报错\",{\"3\":{\"58\":1}}],[\"那么第一次迭代的prev为数组的第一个元素\",{\"3\":{\"107\":1}}],[\"那么代表该请求的缓存失效\",{\"3\":{\"10\":1}}],[\"那么将请求的资源缓存到哪里呢\",{\"3\":{\"8\":1}}],[\"那么为什么会产生不同呢\",{\"3\":{\"5\":1}}],[\"那么就返回true\",{\"3\":{\"212\":1}}],[\"那么就返回false\",{\"3\":{\"212\":1}}],[\"那么就需要将这个上下文暴露出去\",{\"3\":{\"202\":1}}],[\"那么就会进行类型转换\",{\"3\":{\"121\":1}}],[\"那么就会转化为字符串\",{\"3\":{\"119\":1}}],[\"那么就会导致内存泄漏\",{\"3\":{\"3\":1}}],[\"那么就不会被清除\",{\"3\":{\"2\":1}}],[\"此时\",{\"3\":{\"268\":1,\"270\":1}}],[\"此时dom节点已经生成\",{\"3\":{\"265\":1,\"271\":1}}],[\"此时我们可以访问到data\",{\"3\":{\"264\":1}}],[\"此时我们可以根据新的props或者state来判断组件是否需要重新渲染\",{\"3\":{\"212\":1}}],[\"此时可以获取到最新的\",{\"3\":{\"216\":1}}],[\"此时可以获取到真实的\",{\"3\":{\"211\":1,\"212\":1,\"216\":1}}],[\"此时可以做一些清理工作\",{\"3\":{\"213\":1,\"217\":1}}],[\"此时可以根据新的props或者state来修改组件的状态对象\",{\"3\":{\"212\":1}}],[\"此时可以根据新的props来修改组件的状态对象\",{\"3\":{\"212\":1}}],[\"此时可以修改组件的状态对象\",{\"3\":{\"211\":1}}],[\"此时宏任务队列中的任务执行完毕\",{\"3\":{\"141\":1}}],[\"此时主线程空闲\",{\"3\":{\"141\":1}}],[\"此时微任务队列中的任务执行完毕\",{\"3\":{\"141\":2}}],[\"此时i的值已经变成了5\",{\"3\":{\"5\":1}}],[\"此时fn3指向了fn2\",{\"3\":{\"4\":1}}],[\"会缓存不活动的组件实例\",{\"3\":{\"275\":1}}],[\"会触发元素的beforeunmount\",{\"3\":{\"260\":1}}],[\"会触发元素的beforecreate\",{\"3\":{\"260\":1}}],[\"会触发元素的生命周期\",{\"3\":{\"260\":1}}],[\"会在元素上添加一个\",{\"3\":{\"259\":2}}],[\"会加载所有文章\",{\"3\":{\"237\":1}}],[\"会造成页面卡顿\",{\"3\":{\"208\":1}}],[\"会根据产生的任务的优先级来决定是否执行\",{\"3\":{\"208\":1}}],[\"会根据if\",{\"3\":{\"9\":1}}],[\"会导致视图的重新渲染\",{\"3\":{\"204\":1,\"205\":1}}],[\"会导致页面显示不全\",{\"3\":{\"181\":1}}],[\"会被转化成\",{\"0\":{\"189\":1,\"190\":1},\"2\":{\"189\":1,\"190\":1},\"3\":{\"190\":2}}],[\"会被转换成一个立即resolve的promise对象\",{\"3\":{\"141\":1}}],[\"会有一个缓存\",{\"3\":{\"175\":1}}],[\"会从div1开始\",{\"3\":{\"153\":1}}],[\"会从div3开始\",{\"3\":{\"152\":1}}],[\"会依次输出div3\",{\"3\":{\"152\":1,\"153\":1}}],[\"会先从foo的作用域中查找\",{\"3\":{\"145\":1}}],[\"会先从当前作用域查找\",{\"3\":{\"144\":1}}],[\"会先执行微任务队列中的任务\",{\"3\":{\"140\":1}}],[\"会调用那个then函数\",{\"3\":{\"141\":1}}],[\"会进行隐式类型转换\",{\"3\":{\"121\":1}}],[\"会将元素添加到\",{\"3\":{\"258\":1}}],[\"会将元素从\",{\"3\":{\"258\":1}}],[\"会将元素的\",{\"3\":{\"258\":2}}],[\"会将其他类型转化为boolean\",{\"3\":{\"119\":1}}],[\"会将不会被使用的对象进行清除\",{\"3\":{\"2\":1}}],[\"会改变数组本身\",{\"3\":{\"102\":1,\"103\":1,\"106\":2}}],[\"会把变量的声明提升到代码的最前面\",{\"3\":{\"58\":1}}],[\"会暂停html的解析\",{\"3\":{\"37\":1}}],[\"会自动在请求头中加入origin字段\",{\"3\":{\"16\":1}}],[\"会创建一个新的上下文\",{\"3\":{\"5\":1}}],[\"会访问到闭包中的i\",{\"3\":{\"5\":1}}],[\"这时\",{\"3\":{\"276\":1}}],[\"这时候需要暴露\",{\"3\":{\"225\":1}}],[\"这时候我们就可以使用泛型来解决这个问题\",{\"3\":{\"248\":1}}],[\"这时候我们就需要一个系统加载的功能\",{\"3\":{\"181\":1}}],[\"这时候我们需要使用context来解决这个问题\",{\"3\":{\"224\":1}}],[\"这时候姐可以在子组件内部通过props\",{\"3\":{\"222\":1}}],[\"这时候就只能用useref了\",{\"3\":{\"206\":1}}],[\"这时候就会把数据分成多个小的数据包\",{\"3\":{\"166\":1}}],[\"这时候就会无法获取到父函数中的变量\",{\"3\":{\"5\":1}}],[\"这时候timmer是undefined\",{\"3\":{\"206\":1}}],[\"这时候应用层就会生成相应的http报文\",{\"3\":{\"172\":1}}],[\"这时候哦我们可以使用事件委托\",{\"3\":{\"148\":1}}],[\"这时候主线程空闲\",{\"3\":{\"141\":1}}],[\"这时候服务器就可以根据这个值来决定是否同意这次请求\",{\"3\":{\"16\":1}}],[\"这时候请求的内容就会被当做javascript代码去执行\",{\"3\":{\"15\":1}}],[\"这里的移除指的是keep\",{\"3\":{\"268\":1,\"274\":1}}],[\"这里的激活指的是keep\",{\"3\":{\"268\":1,\"274\":1}}],[\"这里的resolve\",{\"3\":{\"141\":1}}],[\"这可能会导致无限循环的更新\",{\"3\":{\"266\":1,\"272\":1}}],[\"这些事件就是生命周期函数\",{\"3\":{\"208\":1}}],[\"这些数据不会导致视图的重新渲染\",{\"3\":{\"206\":1}}],[\"这些数据只有在依赖的值发生改变的时候\",{\"3\":{\"204\":1}}],[\"这些函数只有在依赖的值发生改变的时候\",{\"3\":{\"205\":1}}],[\"这些异步任务又有什么区别呢\",{\"3\":{\"140\":1}}],[\"这是一个静态方法\",{\"3\":{\"215\":1}}],[\"这是为了模拟立即卸载组件和重新挂载组件的情况\",{\"3\":{\"201\":1}}],[\"这是因为null是一个空对象\",{\"3\":{\"135\":1}}],[\"这是因为==他会进行类型转换\",{\"3\":{\"134\":1}}],[\"这是因为\",{\"3\":{\"8\":1,\"152\":1,\"153\":1}}],[\"这才是真正的数据发送过程\",{\"3\":{\"176\":1}}],[\"这两个生命周期函数只有在组件被激活时才会被调用\",{\"3\":{\"278\":1}}],[\"这两个生命周期函数和render函数\",{\"3\":{\"276\":1}}],[\"这两个地址都是ip地址\",{\"3\":{\"174\":1}}],[\"这两个字段的值分别是上一次请求返回的last\",{\"3\":{\"9\":1}}],[\"这就带来了一些生命周期钩子被废弃\",{\"3\":{\"208\":1}}],[\"这就需要路由器来帮助我们选择路由\",{\"3\":{\"167\":1}}],[\"这就需要网络层来帮助传输层完成这个工作\",{\"3\":{\"167\":1}}],[\"这就是闭包的一个特性\",{\"3\":{\"4\":1}}],[\"这种\",{\"3\":{\"222\":1}}],[\"这种事件模型同时支持冒泡阶段和捕获阶段\",{\"3\":{\"153\":1}}],[\"这种事件模型只支持冒泡阶段\",{\"3\":{\"152\":1}}],[\"这种需要转化为boolean的场景\",{\"3\":{\"119\":1}}],[\"这也就是我们说的\",{\"3\":{\"147\":1}}],[\"这边附上\",{\"3\":{\"274\":1}}],[\"这边我们来解释一下window\",{\"3\":{\"239\":1}}],[\"这边我们考虑的都是键入网址内容\",{\"3\":{\"171\":1}}],[\"这边我们引申出一个问题\",{\"3\":{\"82\":1}}],[\"这边出现了process\",{\"3\":{\"141\":1}}],[\"这边就不写了\",{\"3\":{\"127\":1}}],[\"这边flex比较复杂\",{\"3\":{\"50\":1}}],[\"这段区域内不能访问到变量\",{\"3\":{\"58\":1}}],[\"这段代码其实是一个闭包\",{\"3\":{\"5\":1}}],[\"这样我们就可以在别的地方使用这个别名了\",{\"3\":{\"252\":2}}],[\"这样我们就可以在函数内部使用泛型的属性和方法了\",{\"3\":{\"251\":1,\"252\":1}}],[\"这样我们就可以直接在ul上增加点击事件\",{\"3\":{\"148\":1}}],[\"这样会导致代码的可读性变差\",{\"3\":{\"224\":1}}],[\"这样会导致父组件的参数变多\",{\"3\":{\"223\":1}}],[\"这样只要每次渲染子组件\",{\"3\":{\"222\":1}}],[\"这样一层一层\",{\"3\":{\"156\":1}}],[\"这样的话\",{\"3\":{\"127\":2}}],[\"这样就会导致代码的可读性变差\",{\"3\":{\"223\":1}}],[\"这样就会导致缓存失效\",{\"3\":{\"8\":1}}],[\"这样就会导致缓存生效\",{\"3\":{\"8\":1}}],[\"这样就减少了打包的体积\",{\"3\":{\"188\":1}}],[\"这样就不需要引入react了\",{\"3\":{\"188\":1}}],[\"这样就不会造成内存泄漏了\",{\"3\":{\"127\":1}}],[\"这样就不会阻塞dom树的生成\",{\"3\":{\"40\":1}}],[\"这样就可以实现骨架屏的效果\",{\"3\":{\"243\":1}}],[\"这样就可以实现继承\",{\"3\":{\"159\":1}}],[\"这样就可以根据任务的优先级来安排任务的调度\",{\"3\":{\"208\":1}}],[\"这样就可以保证\",{\"3\":{\"183\":1}}],[\"这样就可以避免css阻塞dom树的生成\",{\"3\":{\"41\":1}}],[\"这样是为了确保css能够正确的渲染dom树\",{\"3\":{\"38\":1}}],[\"这样浏览器就认为这是同源的了\",{\"3\":{\"17\":1}}],[\"这个就是直接在调用它\",{\"3\":{\"222\":1}}],[\"这个时候我们就需要使用到子传父的方式\",{\"3\":{\"222\":1}}],[\"这个时候我们就需要使用到父传子的方式\",{\"3\":{\"221\":1}}],[\"这个时候就可以使用react的上下文对象来实现\",{\"3\":{\"202\":1}}],[\"这个生命周期函数主要用于性能优化\",{\"3\":{\"212\":1}}],[\"这个方法的返回值会作为参数传递给componentdidupdate的第三个参数\",{\"3\":{\"216\":1}}],[\"这个方法的返回值会被添加到组件的状态对象\",{\"3\":{\"215\":2}}],[\"这个方法的作用就是在组件更新之前获取到最新的\",{\"3\":{\"216\":1}}],[\"这个方法的作用就是根据新的props来更新组件的状态对象\",{\"3\":{\"215\":1}}],[\"这个方法在组件初始化渲染的时候不会被调用\",{\"3\":{\"216\":1}}],[\"这个方法在组件更新之前执行\",{\"3\":{\"216\":1}}],[\"这个方法在组件实例化之后和接收到新的props之后执行\",{\"3\":{\"215\":1}}],[\"这个方法在服务端渲染中也会被调用\",{\"3\":{\"211\":1}}],[\"这个方法不能访问到组件实例\",{\"3\":{\"215\":1}}],[\"这个方法也会被执行\",{\"3\":{\"212\":2}}],[\"这个过程中会伴随着一些事件\",{\"3\":{\"208\":1}}],[\"这个过程是循环不断的\",{\"3\":{\"139\":1}}],[\"这个定时器不需要导致视图的更新\",{\"3\":{\"206\":1}}],[\"这个属性可以用来存储数据\",{\"3\":{\"206\":1}}],[\"这个属性指向函数的原型对象\",{\"3\":{\"155\":1}}],[\"这个对象有一个current属性\",{\"3\":{\"206\":1}}],[\"这个对象包含了实际的值\",{\"3\":{\"99\":1}}],[\"这个数组的第一个元素就是状态对象\",{\"3\":{\"200\":1}}],[\"这个参数就是状态对象\",{\"3\":{\"200\":1}}],[\"这个深拷贝还是有问题的\",{\"3\":{\"127\":1}}],[\"这个低代码项目\",{\"3\":{\"85\":1}}],[\"这个不使用apply其实也可以做到\",{\"3\":{\"83\":1}}],[\"这个其实就是相当于window\",{\"3\":{\"82\":1}}],[\"这个请求的作用是询问服务器是否允许这种请求\",{\"3\":{\"16\":1}}],[\"这个请求是一个options请求\",{\"3\":{\"16\":1}}],[\"这个字段的值就是当前页面的源\",{\"3\":{\"16\":1}}],[\"这个函数的作用就相当于componentdidmount\",{\"3\":{\"218\":1}}],[\"这个函数的作用是拿到服务器返回的数据\",{\"3\":{\"15\":1}}],[\"这个函数会在组件初始化渲染之后执行\",{\"3\":{\"201\":1}}],[\"这个函数就相当于componentdidmount\",{\"3\":{\"201\":1}}],[\"这个函数就是onback\",{\"3\":{\"15\":1}}],[\"这个函数可以用来修改状态对象\",{\"3\":{\"200\":1}}],[\"4761c778\",{\"0\":{\"232\":1,\"233\":1,\"234\":1,\"235\":1,\"236\":1}}],[\"452c4c68\",{\"0\":{\"155\":1,\"156\":1,\"157\":1,\"158\":1}}],[\"400px\",{\"3\":{\"52\":1}}],[\"40em\",{\"3\":{\"41\":1,\"42\":4}}],[\"4d21c07a\",{\"0\":{\"7\":1,\"8\":1,\"9\":1,\"10\":1,\"11\":1}}],[\"4\",{\"0\":{\"45\":1,\"278\":1},\"2\":{\"45\":1,\"278\":1},\"3\":{\"5\":3,\"57\":4,\"64\":1,\"67\":4,\"83\":8,\"141\":6}}],[\"3bdca45c\",{\"0\":{\"263\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":1,\"271\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":1,\"276\":1,\"277\":1,\"278\":1,\"279\":1,\"280\":1,\"281\":1,\"282\":1,\"283\":1}}],[\"3448eb71\",{\"0\":{\"245\":1}}],[\"35\",{\"3\":{\"242\":1}}],[\"35f016f2\",{\"0\":{\"82\":1,\"83\":1,\"84\":1}}],[\"3之前的shouldcomponentupdate没有什么区别\",{\"3\":{\"216\":1}}],[\"3之前的render函数没有什么区别\",{\"3\":{\"215\":1}}],[\"3之前的生命周期\",{\"3\":{\"213\":1}}],[\"3之后的生命周期有以下几个\",{\"3\":{\"213\":1}}],[\"3之后的生命周期有所改变\",{\"3\":{\"213\":1}}],[\"32位寻址方式\",{\"3\":{\"167\":1}}],[\"3cb808b6\",{\"0\":{\"121\":1,\"122\":1,\"123\":1,\"124\":1}}],[\"379d5da0\",{\"0\":{\"54\":1,\"55\":1,\"56\":1,\"57\":1,\"58\":1,\"59\":1,\"60\":1,\"61\":1,\"62\":1,\"63\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":1,\"69\":1,\"70\":1,\"71\":1,\"72\":1,\"73\":1,\"74\":1,\"75\":1,\"76\":1,\"77\":1,\"78\":1,\"79\":1,\"80\":1}}],[\"36e7ec57\",{\"0\":{\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"52\":1,\"53\":1}}],[\"300\",{\"3\":{\"242\":1}}],[\"3000\",{\"3\":{\"16\":2}}],[\"30525834\",{\"0\":{\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"107\":1,\"108\":1,\"109\":1}}],[\"304\",{\"3\":{\"10\":1}}],[\"3\",{\"0\":{\"17\":1,\"44\":1,\"192\":1,\"210\":1,\"214\":1,\"277\":1},\"2\":{\"17\":1,\"44\":1,\"192\":1,\"210\":1,\"214\":1,\"277\":1},\"3\":{\"5\":5,\"24\":1,\"57\":3,\"58\":2,\"61\":3,\"64\":4,\"66\":2,\"67\":6,\"79\":3,\"83\":10,\"141\":6,\"206\":1,\"208\":1}}],[\"16\",{\"0\":{\"210\":1,\"214\":1},\"2\":{\"210\":1,\"214\":1},\"3\":{\"208\":1}}],[\"16px\",{\"3\":{\"27\":1}}],[\"1<\",{\"3\":{\"203\":1}}],[\"128位寻址方式\",{\"3\":{\"167\":1}}],[\"12\",{\"3\":{\"159\":5,\"160\":2}}],[\"123a\",{\"3\":{\"87\":1}}],[\"123\",{\"3\":{\"87\":4}}],[\"1ccf7368\",{\"0\":{\"143\":1,\"144\":1,\"145\":1,\"146\":1,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"151\":1,\"152\":1,\"153\":1,\"154\":1}}],[\"1514e16c\",{\"0\":{\"137\":1,\"138\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1}}],[\"13900acc\",{\"0\":{\"132\":1,\"133\":1,\"134\":1,\"135\":1,\"136\":1}}],[\"17星星充电\",{\"1\":{\"85\":1}}],[\"10ms\",{\"3\":{\"206\":1}}],[\"10\",{\"3\":{\"65\":1,\"206\":1}}],[\"100vh\",{\"3\":{\"239\":1}}],[\"100\",{\"3\":{\"52\":2}}],[\"100px\",{\"3\":{\"50\":2}}],[\"1000\",{\"3\":{\"5\":6,\"61\":4,\"76\":1,\"79\":7,\"206\":1,\"242\":1}}],[\"18\",{\"3\":{\"62\":2,\"65\":4,\"66\":6,\"67\":2,\"70\":2,\"71\":2,\"72\":4}}],[\"1rtem\",{\"3\":{\"27\":1}}],[\"1px\",{\"3\":{\"27\":1}}],[\"1以后\",{\"3\":{\"8\":1}}],[\"1\",{\"0\":{\"15\":1,\"40\":1,\"183\":1,\"188\":1,\"215\":1,\"216\":1,\"217\":1,\"270\":1,\"271\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":1},\"2\":{\"15\":1,\"40\":1,\"183\":1,\"188\":1,\"275\":1},\"3\":{\"5\":5,\"24\":2,\"27\":1,\"29\":1,\"30\":1,\"50\":10,\"52\":1,\"57\":1,\"58\":2,\"59\":3,\"60\":3,\"61\":3,\"64\":3,\"66\":2,\"67\":6,\"83\":12,\"87\":4,\"105\":1,\"106\":2,\"114\":1,\"119\":1,\"122\":2,\"127\":1,\"141\":6,\"145\":3,\"147\":2,\"159\":3,\"160\":1,\"196\":1,\"197\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":2,\"204\":1,\"205\":1,\"218\":1}}],[\"1d2cefc0\",{\"0\":{\"0\":1}}],[\"join\",{\"3\":{\"108\":1}}],[\"josnp\",{\"3\":{\"15\":1}}],[\"jsxs\",{\"3\":{\"190\":3}}],[\"jsx不会将jsx转化为react\",{\"3\":{\"188\":1}}],[\"jsxjsx\",{\"3\":{\"186\":1}}],[\"jsx转化过程\",{\"1\":{\"186\":1,\"187\":1,\"188\":1,\"189\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":1}}],[\"jsx\",{\"0\":{\"186\":1,\"187\":1},\"2\":{\"186\":1,\"187\":1},\"3\":{\"190\":13}}],[\"js\",{\"3\":{\"67\":1,\"127\":1,\"183\":1,\"190\":1}}],[\"json\",{\"3\":{\"15\":2,\"128\":2}}],[\"jsonp的原理是动态创建script标签\",{\"3\":{\"15\":1}}],[\"jsonp\",{\"0\":{\"15\":1},\"2\":{\"15\":1}}],[\"justify\",{\"3\":{\"49\":1}}],[\"javascript将异步任务分为了两种\",{\"3\":{\"140\":1}}],[\"javascript篇\",{\"1\":{\"131\":1}}],[\"javascript数据类型\",{\"1\":{\"86\":1,\"87\":1,\"88\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1,\"96\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1}}],[\"javascript的作用域\",{\"3\":{\"85\":1}}],[\"javascript的基本类型\",{\"3\":{\"85\":1}}],[\"javascript中没有类的概念\",{\"3\":{\"70\":1}}],[\"javascript\",{\"3\":{\"15\":2,\"137\":4,\"138\":1,\"148\":1}}],[\"j\",{\"3\":{\"5\":4,\"64\":1}}],[\"5ce1f97c\",{\"0\":{\"231\":1}}],[\"5ec739b6\",{\"0\":{\"220\":1,\"221\":1,\"222\":1,\"223\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1}}],[\"5b4756e9\",{\"0\":{\"185\":1}}],[\"5bc3b2da\",{\"0\":{\"1\":1,\"2\":1,\"3\":1,\"4\":1,\"5\":1,\"6\":1}}],[\"54eae7a0\",{\"0\":{\"171\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1}}],[\"5464e616\",{\"0\":{\"85\":1}}],[\"568d3b89\",{\"0\":{\"131\":1}}],[\"55\",{\"3\":{\"122\":2}}],[\"5null\",{\"3\":{\"119\":1}}],[\"5undefined\",{\"3\":{\"119\":1}}],[\"5f5c21dd\",{\"0\":{\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"130\":1}}],[\"5function\",{\"3\":{\"119\":1}}],[\"5false\",{\"3\":{\"119\":1}}],[\"5true\",{\"3\":{\"119\":1}}],[\"51\",{\"3\":{\"119\":1}}],[\"5\",{\"3\":{\"5\":14,\"57\":2,\"67\":4,\"76\":1,\"79\":2,\"83\":11,\"119\":10,\"141\":6}}],[\"<template>\",{\"3\":{\"256\":1}}],[\"<t\",{\"3\":{\"252\":1}}],[\"<lazyimage\",{\"3\":{\"240\":1}}],[\"<list\",{\"3\":{\"242\":1}}],[\"<li>\",{\"3\":{\"243\":1}}],[\"<li>3<\",{\"3\":{\"148\":1}}],[\"<li>2<\",{\"3\":{\"148\":1}}],[\"<li>1<\",{\"3\":{\"148\":1}}],[\"<link\",{\"3\":{\"41\":3,\"45\":2}}],[\"<p>content\",{\"3\":{\"234\":1,\"235\":1}}],[\"<p>你点击了\",{\"3\":{\"218\":1}}],[\"<>\",{\"3\":{\"206\":1}}],[\"<input\",{\"3\":{\"206\":1,\"228\":1,\"229\":1}}],[\"<mycontext\",{\"3\":{\"202\":1,\"225\":1}}],[\"<button\",{\"3\":{\"196\":1,\"197\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":2,\"204\":2,\"205\":3,\"206\":2,\"218\":1,\"222\":3,\"223\":1,\"229\":1}}],[\"<h1>post\",{\"3\":{\"235\":1}}],[\"<h1>post<\",{\"3\":{\"234\":1}}],[\"<h1>时间过去了\",{\"3\":{\"206\":1}}],[\"<h1>\",{\"3\":{\"196\":1,\"197\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":3,\"205\":2}}],[\"<hello>hello<\",{\"3\":{\"188\":1}}],[\"<suspense\",{\"3\":{\"240\":1}}],[\"<span>hello<\",{\"3\":{\"188\":1}}],[\"<script>\",{\"3\":{\"15\":1}}],[\"<div>loading\",{\"3\":{\"240\":1,\"243\":1}}],[\"<div>\",{\"3\":{\"196\":1,\"197\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1,\"206\":1,\"218\":1,\"221\":1,\"222\":3,\"223\":3,\"228\":1,\"229\":1,\"243\":1,\"256\":1}}],[\"<div\",{\"3\":{\"152\":4,\"153\":4,\"188\":1,\"234\":1,\"235\":1,\"242\":1,\"256\":2}}],[\"<ul>\",{\"3\":{\"243\":1}}],[\"<ul\",{\"3\":{\"148\":1}}],[\"<child2\",{\"3\":{\"223\":1}}],[\"<child1\",{\"3\":{\"223\":1}}],[\"<child\",{\"3\":{\"67\":1,\"202\":1,\"221\":1,\"222\":1,\"225\":1}}],[\"<=\",{\"3\":{\"42\":1,\"119\":1}}],[\"<\",{\"3\":{\"5\":4,\"15\":1,\"41\":4,\"45\":2,\"119\":1,\"148\":1,\"152\":2,\"153\":2,\"188\":1,\"196\":3,\"197\":2,\"200\":2,\"201\":2,\"202\":3,\"203\":2,\"204\":4,\"205\":3,\"206\":3,\"218\":1,\"221\":1,\"222\":3,\"223\":3,\"225\":1,\"228\":1,\"229\":1,\"234\":2,\"235\":3,\"240\":3,\"242\":3,\"243\":4,\"256\":2}}],[\"015c1f8a\",{\"0\":{\"237\":1,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":1}}],[\"08c026b0\",{\"0\":{\"208\":1,\"209\":1,\"210\":1,\"211\":1,\"212\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":1,\"217\":1,\"218\":1,\"219\":1}}],[\"0d084802\",{\"0\":{\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"198\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1,\"206\":1,\"207\":1}}],[\"0\",{\"3\":{\"5\":6,\"24\":1,\"29\":2,\"30\":4,\"50\":5,\"76\":1,\"79\":7,\"87\":5,\"89\":2,\"106\":1,\"135\":1,\"141\":4,\"196\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1,\"206\":1,\"218\":1,\"234\":2,\"235\":2,\"239\":1}}],[\"ibase>\",{\"3\":{\"251\":1,\"252\":1,\"253\":1}}],[\"ibase\",{\"3\":{\"251\":1,\"253\":1}}],[\"ibase<t>\",{\"3\":{\"252\":4}}],[\"ibase<t\",{\"3\":{\"249\":1}}],[\"img\",{\"3\":{\"240\":2}}],[\"import\",{\"3\":{\"183\":2,\"190\":3,\"196\":1,\"197\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1,\"206\":2,\"218\":1,\"221\":1,\"222\":3,\"223\":5,\"234\":1,\"235\":2,\"240\":2,\"242\":2,\"243\":1}}],[\"images\",{\"3\":{\"240\":4}}],[\"image\",{\"3\":{\"25\":1,\"240\":4}}],[\"ip头部生成后\",{\"3\":{\"175\":1}}],[\"ip\",{\"3\":{\"167\":1}}],[\"ipv6\",{\"3\":{\"167\":1}}],[\"ipv4\",{\"3\":{\"167\":1}}],[\"ip协议需要知道源地址ip和目的地址ip\",{\"3\":{\"174\":1}}],[\"ip协议需要将数据封装为数据包\",{\"3\":{\"174\":1}}],[\"ip协议还定义了一种路由选择协议\",{\"3\":{\"167\":1}}],[\"ip协议定义了一种寻址方式\",{\"3\":{\"167\":1}}],[\"ip协议\",{\"0\":{\"174\":1},\"2\":{\"174\":1},\"3\":{\"167\":1}}],[\"ip网络模型\",{\"1\":{\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":1}}],[\"include\",{\"3\":{\"275\":1}}],[\"includes\",{\"3\":{\"105\":1,\"114\":1}}],[\"interface\",{\"3\":{\"249\":1,\"251\":1,\"253\":1}}],[\"intersectionobserver是浏览器提供的一个api\",{\"3\":{\"240\":1}}],[\"intersectionobserver\",{\"3\":{\"239\":1,\"240\":1}}],[\"innerheight相加\",{\"3\":{\"239\":1}}],[\"innerheight和document\",{\"3\":{\"239\":1}}],[\"innerheight\",{\"3\":{\"239\":2,\"240\":1,\"242\":2}}],[\"innerhtml\",{\"3\":{\"148\":1}}],[\"inputref\",{\"3\":{\"206\":3,\"229\":3}}],[\"initvalue为初始值\",{\"3\":{\"107\":1}}],[\"initvalue\",{\"3\":{\"107\":1}}],[\"indexof\",{\"3\":{\"105\":1,\"114\":1}}],[\"index为负数\",{\"3\":{\"30\":1}}],[\"index\",{\"3\":{\"29\":1,\"30\":1,\"107\":6,\"114\":1,\"242\":2}}],[\"indent\",{\"3\":{\"25\":1}}],[\"itemcount=\",{\"3\":{\"242\":1}}],[\"item\",{\"3\":{\"107\":5}}],[\"item2\",{\"3\":{\"102\":1,\"103\":1}}],[\"item1\",{\"3\":{\"102\":1,\"103\":1}}],[\"itemsize=\",{\"3\":{\"242\":1}}],[\"items属性\",{\"3\":{\"50\":1}}],[\"items\",{\"3\":{\"49\":1}}],[\"iterable\",{\"3\":{\"67\":1}}],[\"isshow\",{\"3\":{\"256\":2,\"258\":3}}],[\"isintersecting\",{\"3\":{\"239\":1,\"240\":1}}],[\"is\",{\"3\":{\"62\":2,\"70\":2,\"71\":2,\"72\":4,\"134\":4,\"159\":5,\"160\":2,\"275\":1}}],[\"id=\",{\"3\":{\"148\":1,\"152\":4,\"153\":4,\"188\":1}}],[\"id\",{\"3\":{\"23\":2,\"24\":2,\"189\":2,\"190\":2,\"235\":6}}],[\"ie盒模型\",{\"3\":{\"19\":1}}],[\"ie\",{\"3\":{\"19\":2}}],[\"ifconditions\",{\"3\":{\"259\":1}}],[\"if<\",{\"3\":{\"256\":1}}],[\"if=\",{\"3\":{\"256\":1}}],[\"if\",{\"1\":{\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"261\":1,\"262\":1},\"3\":{\"10\":2,\"76\":1,\"79\":7,\"119\":1,\"134\":2,\"206\":1,\"234\":1,\"235\":1,\"239\":2,\"240\":2,\"242\":1,\"258\":3,\"259\":1,\"260\":1,\"261\":1}}],[\"i的值都不一样\",{\"3\":{\"5\":1}}],[\"i的值会被保存在闭包中\",{\"3\":{\"5\":1}}],[\"i作为参数传递给了闭包\",{\"3\":{\"5\":1}}],[\"i++\",{\"3\":{\"5\":4}}],[\"i\",{\"3\":{\"5\":17,\"62\":2,\"64\":1,\"70\":2,\"71\":2,\"72\":8,\"140\":1,\"159\":5,\"160\":3}}],[\"因为这个时候dom并不是一定渲染完成了\",{\"3\":{\"265\":1}}],[\"因为这些数据和方法都还没有初始化\",{\"3\":{\"264\":1}}],[\"因为还没有进行模板编译\",{\"3\":{\"264\":1}}],[\"因为涉及到dom结构的变化\",{\"3\":{\"260\":1}}],[\"因为只涉及到css的变化\",{\"3\":{\"260\":1}}],[\"因为我们可以在定义函数\",{\"3\":{\"246\":1}}],[\"因为可能同时监听多个元素\",{\"3\":{\"240\":1}}],[\"因为如果层级太深\",{\"3\":{\"223\":1}}],[\"因为react在\",{\"3\":{\"208\":1}}],[\"因为timmer是一个局部变量\",{\"3\":{\"206\":1}}],[\"因为在\",{\"3\":{\"190\":1}}],[\"因为首页的一些数据需要在用户登录后才能获取\",{\"3\":{\"181\":1}}],[\"因为dom是一个树形结构\",{\"3\":{\"150\":1}}],[\"因为foo的作用域链是foo\",{\"3\":{\"145\":1}}],[\"因为它的作用域在函数定义的时候就决定了\",{\"3\":{\"145\":1}}],[\"因为process\",{\"3\":{\"141\":1}}],[\"因为\",{\"3\":{\"137\":1,\"218\":1}}],[\"因为普通函数有this\",{\"3\":{\"61\":1}}],[\"因为箭头函数没有this\",{\"3\":{\"61\":2}}],[\"因为css可以修改dom树的样式\",{\"3\":{\"38\":1}}],[\"因为settimeout是一个异步函数\",{\"3\":{\"5\":1}}],[\"因为闭包会携带包含它的函数的作用域\",{\"3\":{\"4\":1}}],[\"因此fn1也不会被销毁\",{\"3\":{\"4\":1}}],[\"无法被销毁\",{\"3\":{\"4\":2}}],[\"无法销毁\",{\"3\":{\"4\":1}}],[\"但是子组件的状态并没有更新\",{\"3\":{\"276\":1}}],[\"但是setup中的props属性是reactive的\",{\"3\":{\"270\":1}}],[\"但是注意不要在这个钩子函数中操作数据\",{\"3\":{\"266\":1,\"272\":1}}],[\"但是他们达到效果的方式不同\",{\"3\":{\"257\":1}}],[\"但是泛型别名\",{\"3\":{\"252\":1}}],[\"但是我们是无法直接修改\",{\"3\":{\"222\":1}}],[\"但是我们可以使用构造函数来模拟类的概念\",{\"3\":{\"70\":1}}],[\"但是上面的生命周期都是在react16\",{\"3\":{\"213\":1}}],[\"但是不能获取到组件之前的props\",{\"3\":{\"212\":1}}],[\"但是无法清除\",{\"3\":{\"206\":1}}],[\"但是函数组件可以通过useeffect来模拟生命周期钩子\",{\"3\":{\"198\":1}}],[\"但是函数组件可以通过usestate来使用状态\",{\"3\":{\"198\":1}}],[\"但是交换机会记录下数据包的源mac地址和端口号\",{\"3\":{\"177\":1}}],[\"但是传输层并不知道数据是如何从一端传到另一端的\",{\"3\":{\"167\":1}}],[\"但是需要动态的增加item\",{\"3\":{\"148\":1}}],[\"但是需要注意的是\",{\"3\":{\"64\":1,\"65\":1}}],[\"但是宏任务的优先级要低于微任务\",{\"3\":{\"140\":1}}],[\"但是如果父组件的状态更新\",{\"3\":{\"276\":1}}],[\"但是如果我们把兄弟组件的数据提升到父组件\",{\"3\":{\"223\":1}}],[\"但是如果你要在这个钩子里面使用this\",{\"3\":{\"216\":1}}],[\"但是如果是基于构造函数的继承\",{\"3\":{\"159\":1}}],[\"但是如果只将任务划分为同步任务和异步任务\",{\"3\":{\"140\":1}}],[\"但是如果存在引用\",{\"3\":{\"2\":1}}],[\"但是即使这样\",{\"3\":{\"127\":1}}],[\"但是这些操作最好放在nexttick中\",{\"3\":{\"265\":1}}],[\"但是这样会带来很多问题\",{\"3\":{\"224\":1}}],[\"但是这不代表\",{\"3\":{\"137\":1}}],[\"但是这个深拷贝还有一个问题\",{\"3\":{\"127\":1}}],[\"但是这个深拷贝没有考虑到数组的情况\",{\"3\":{\"127\":1}}],[\"但是这种方法并不是很便捷\",{\"3\":{\"83\":1}}],[\"但是这种方法会导致元素不占据空间\",{\"3\":{\"29\":1}}],[\"但是没有赋值的情况下的默认值\",{\"3\":{\"91\":2}}],[\"但是有一些特殊情况\",{\"3\":{\"84\":1}}],[\"但是它会把数组中的每一个元素\",{\"3\":{\"83\":1}}],[\"但是使用apply\",{\"3\":{\"83\":1}}],[\"但是math\",{\"3\":{\"83\":1}}],[\"但是普通函数有this\",{\"3\":{\"61\":1}}],[\"但是变量的赋值不会被提升\",{\"3\":{\"58\":1}}],[\"但是\",{\"3\":{\"58\":1}}],[\"但是在组件实例创建之前被调用\",{\"3\":{\"270\":1}}],[\"但是在react16\",{\"3\":{\"217\":1}}],[\"但是在react17之后\",{\"3\":{\"208\":1}}],[\"但是在\",{\"3\":{\"190\":1}}],[\"但是在块级作用域和函数作用域中都不能访问到\",{\"3\":{\"57\":1}}],[\"但是在函数作用域中不能访问到\",{\"3\":{\"57\":1}}],[\"但是在生成dom树的时候\",{\"3\":{\"38\":1}}],[\"但是元素还是占据空间\",{\"3\":{\"30\":4}}],[\"但是浏览器的控制台中会显示出如下错误信息\",{\"3\":{\"13\":1}}],[\"但是浏览器第二次请求时\",{\"3\":{\"8\":1}}],[\"但是缺点是读取速度慢\",{\"3\":{\"8\":1}}],[\"但是缺点是存储空间小\",{\"3\":{\"8\":1}}],[\"但是只针对于代理服务器\",{\"3\":{\"8\":1}}],[\"但是会使用协商缓存\",{\"3\":{\"8\":1}}],[\"但是实际上\",{\"3\":{\"8\":1}}],[\"但是到了http1\",{\"3\":{\"8\":1}}],[\"但是大体上可以分为两种\",{\"3\":{\"7\":1}}],[\"但是又不想立即执行该函数时\",{\"3\":{\"5\":1}}],[\"但是因为使用了闭包\",{\"3\":{\"5\":1}}],[\"但是fn2依然会访问到外部作用域的变量\",{\"3\":{\"4\":1}}],[\"的是什么\",{\"2\":{\"275\":1}}],[\"的生命周期图\",{\"3\":{\"274\":1}}],[\"的操作\",{\"3\":{\"266\":1,\"272\":1}}],[\"的初始值\",{\"3\":{\"200\":1}}],[\"的父\",{\"3\":{\"191\":1}}],[\"的兄弟\",{\"3\":{\"191\":2}}],[\"的子\",{\"3\":{\"191\":2}}],[\"的形式\",{\"3\":{\"190\":1}}],[\"的一种语法糖\",{\"3\":{\"186\":1}}],[\"的继承\",{\"0\":{\"159\":1,\"160\":1},\"2\":{\"159\":1,\"160\":1}}],[\"的事件模型\",{\"3\":{\"148\":1}}],[\"的不同点\",{\"0\":{\"135\":1},\"2\":{\"135\":1}}],[\"的相同点\",{\"0\":{\"134\":1},\"2\":{\"134\":1}}],[\"的垃圾回收机制\",{\"3\":{\"127\":1}}],[\"的角度来看待的\",{\"3\":{\"110\":1}}],[\"的元素\",{\"3\":{\"103\":1}}],[\"的数组\",{\"3\":{\"87\":1}}],[\"的值会绑定到新创建的对象上\",{\"3\":{\"83\":1}}],[\"的区别\",{\"2\":{\"83\":1}}],[\"的指向\",{\"3\":{\"82\":1}}],[\"的指向类型\",{\"2\":{\"82\":1}}],[\"的三种状态\",{\"0\":{\"77\":1},\"2\":{\"77\":1}}],[\"的基本使用\",{\"0\":{\"76\":1},\"2\":{\"76\":1}}],[\"的构造函数\",{\"3\":{\"71\":1}}],[\"的类\",{\"0\":{\"70\":1,\"71\":1},\"2\":{\"70\":1,\"71\":1},\"3\":{\"71\":1}}],[\"的产物\",{\"3\":{\"55\":2}}],[\"的优缺点\",{\"3\":{\"15\":1}}],[\"的\",{\"3\":{\"15\":1,\"222\":1,\"228\":4,\"229\":1}}],[\"的关闭而释放\",{\"3\":{\"8\":1}}],[\"的引用已经被释放\",{\"3\":{\"4\":1}}],[\"的返回值\",{\"3\":{\"4\":1}}],[\"l\",{\"3\":{\"64\":1}}],[\"length\",{\"3\":{\"112\":1,\"251\":2}}],[\"left\",{\"3\":{\"52\":1}}],[\"let声明的变量不会被提升到代码的最前面\",{\"3\":{\"58\":1}}],[\"let和const声明的变量不能被重复声明\",{\"3\":{\"59\":1}}],[\"let和const声明的变量在全局作用域中可以访问到\",{\"3\":{\"57\":1}}],[\"let和const是\",{\"3\":{\"55\":1}}],[\"let定义的变量不会具有变量提升的特性\",{\"3\":{\"5\":1}}],[\"let\",{\"0\":{\"54\":1},\"2\":{\"54\":1},\"3\":{\"3\":1,\"5\":1,\"57\":3,\"58\":1,\"59\":2,\"60\":1,\"61\":1,\"127\":1,\"132\":2,\"133\":2,\"147\":1,\"148\":1,\"152\":4,\"153\":4,\"206\":2,\"225\":1}}],[\"lazy\",{\"3\":{\"240\":1}}],[\"lazyimage\",{\"3\":{\"240\":2}}],[\"lazyimage组件会被动态加载\",{\"3\":{\"240\":1}}],[\"lazy和suspense来实现图片懒加载\",{\"3\":{\"240\":1}}],[\"layout\",{\"3\":{\"25\":1}}],[\"lastscrolltop\",{\"3\":{\"234\":4,\"235\":4}}],[\"lastindexof\",{\"3\":{\"105\":1}}],[\"last\",{\"3\":{\"9\":1,\"10\":1}}],[\"li>\",{\"3\":{\"148\":3,\"243\":1}}],[\"limit表示最大分割次数\",{\"3\":{\"115\":1}}],[\"limit\",{\"3\":{\"115\":1}}],[\"list>\",{\"3\":{\"242\":1}}],[\"list\",{\"3\":{\"25\":3,\"242\":1}}],[\"listen\",{\"3\":{\"16\":1}}],[\"link\",{\"3\":{\"24\":1}}],[\"li\",{\"3\":{\"24\":1}}],[\"loadmore\",{\"3\":{\"239\":1}}],[\"loading\",{\"3\":{\"181\":1,\"183\":6,\"243\":2}}],[\"lodash\",{\"3\":{\"128\":1}}],[\"localstorage\",{\"0\":{\"234\":1},\"2\":{\"234\":1},\"3\":{\"234\":4,\"235\":2}}],[\"localstore和sessionstore的区别\",{\"3\":{\"85\":1}}],[\"localhost\",{\"3\":{\"16\":1}}],[\"login\",{\"3\":{\"15\":1}}],[\"log\",{\"3\":{\"4\":2,\"5\":7,\"16\":1,\"57\":12,\"58\":6,\"59\":3,\"60\":3,\"61\":9,\"62\":1,\"64\":3,\"65\":3,\"66\":4,\"67\":4,\"70\":1,\"71\":1,\"72\":4,\"76\":2,\"79\":6,\"82\":4,\"83\":10,\"132\":2,\"133\":3,\"134\":3,\"135\":2,\"141\":39,\"145\":1,\"147\":1,\"148\":1,\"152\":4,\"153\":4,\"159\":3,\"160\":4,\"201\":2,\"204\":1,\"205\":1,\"206\":1,\"218\":2,\"221\":1,\"229\":1,\"251\":1}}],[\"2b00a92c\",{\"0\":{\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"261\":1,\"262\":1}}],[\"2b9022fc\",{\"0\":{\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"116\":1,\"117\":1}}],[\"2376843a\",{\"0\":{\"246\":1,\"247\":1,\"248\":1,\"249\":1,\"250\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":1}}],[\"28cd39da\",{\"0\":{\"163\":1}}],[\"200px\",{\"3\":{\"52\":2}}],[\"29367432\",{\"0\":{\"19\":1,\"20\":1,\"21\":1,\"22\":1}}],[\"25\",{\"3\":{\"5\":1}}],[\"2\",{\"0\":{\"16\":1,\"41\":1,\"191\":1,\"276\":1},\"2\":{\"16\":1,\"41\":1,\"191\":1,\"276\":1},\"3\":{\"4\":3,\"5\":5,\"50\":2,\"57\":3,\"58\":2,\"59\":4,\"60\":5,\"61\":3,\"64\":3,\"66\":2,\"67\":6,\"83\":10,\"127\":1,\"141\":6,\"145\":1,\"204\":1}}],[\"==会进行隐式类型转换\",{\"3\":{\"123\":1}}],[\"===不会进行隐式类型转换\",{\"3\":{\"123\":1}}],[\"===\",{\"3\":{\"119\":1,\"122\":1,\"123\":1}}],[\"==\",{\"3\":{\"91\":1,\"119\":2,\"121\":2,\"122\":1,\"123\":1,\"134\":1}}],[\"=object的原因是什么\",{\"3\":{\"85\":1}}],[\"=＞promise\",{\"3\":{\"85\":1}}],[\"=＞直接存在了缓存中\",{\"3\":{\"85\":1}}],[\"=＞react\",{\"3\":{\"85\":1}}],[\"=>\",{\"3\":{\"16\":2,\"61\":4,\"67\":1,\"76\":4,\"79\":20,\"83\":1,\"107\":6,\"141\":4,\"191\":1,\"196\":1,\"197\":1,\"200\":1,\"201\":3,\"202\":1,\"203\":3,\"204\":3,\"205\":3,\"206\":2,\"218\":3,\"222\":3,\"223\":2,\"228\":1,\"229\":1,\"234\":5,\"235\":5,\"239\":2,\"240\":7,\"242\":4,\"243\":4}}],[\"=\",{\"3\":{\"4\":6,\"5\":9,\"15\":3,\"16\":2,\"19\":2,\"20\":2,\"21\":2,\"27\":2,\"57\":9,\"58\":3,\"59\":6,\"60\":6,\"61\":4,\"62\":3,\"64\":7,\"65\":6,\"66\":1,\"67\":13,\"70\":4,\"71\":3,\"72\":7,\"76\":2,\"79\":14,\"82\":4,\"83\":14,\"119\":1,\"127\":2,\"132\":1,\"133\":2,\"145\":2,\"147\":2,\"148\":1,\"152\":8,\"153\":4,\"159\":17,\"160\":7,\"183\":2,\"189\":2,\"191\":1,\"196\":1,\"200\":1,\"201\":1,\"202\":3,\"203\":1,\"204\":3,\"205\":3,\"206\":11,\"218\":1,\"222\":2,\"223\":2,\"225\":2,\"228\":1,\"229\":2,\"234\":4,\"235\":5,\"239\":2,\"240\":5,\"242\":2,\"243\":3,\"250\":2,\"252\":1}}],[\"axios等\",{\"3\":{\"264\":1}}],[\"add\",{\"3\":{\"203\":2}}],[\"addeventlistener接收三个参数\",{\"3\":{\"153\":1}}],[\"addeventlistener\",{\"3\":{\"148\":1,\"153\":4,\"234\":1,\"235\":1,\"239\":1,\"240\":1,\"242\":1}}],[\"any\",{\"3\":{\"191\":6}}],[\"and\",{\"3\":{\"42\":3}}],[\"a85593e6\",{\"0\":{\"186\":1,\"187\":1,\"188\":1,\"189\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":1}}],[\"await后面跟着的是一个promise对象\",{\"3\":{\"141\":1}}],[\"await等等\",{\"3\":{\"140\":1}}],[\"a0326798\",{\"0\":{\"118\":1,\"119\":1,\"120\":1}}],[\"a123\",{\"3\":{\"87\":1}}],[\"as\",{\"3\":{\"190\":2,\"242\":1}}],[\"async函数返回的是一个promise对象\",{\"3\":{\"141\":1}}],[\"async和await\",{\"3\":{\"141\":1}}],[\"async\",{\"3\":{\"140\":1}}],[\"assign\",{\"3\":{\"72\":2,\"126\":1}}],[\"as=\",{\"3\":{\"45\":2}}],[\"article\",{\"3\":{\"242\":3,\"243\":2}}],[\"articles\",{\"3\":{\"242\":2,\"243\":4}}],[\"arp为了提高效率\",{\"3\":{\"175\":1}}],[\"arp获取mac地址的方式\",{\"3\":{\"175\":1}}],[\"array\",{\"0\":{\"95\":1},\"2\":{\"95\":1},\"3\":{\"107\":6,\"126\":1}}],[\"arr3\",{\"3\":{\"67\":2}}],[\"arr2\",{\"3\":{\"67\":2,\"83\":4}}],[\"arr1\",{\"3\":{\"67\":2,\"83\":5}}],[\"arr\",{\"3\":{\"64\":6,\"67\":5,\"83\":5}}],[\"arg\",{\"3\":{\"248\":2,\"251\":3,\"252\":3,\"253\":2}}],[\"arguments是一个类数组对象\",{\"3\":{\"61\":1}}],[\"arguments\",{\"3\":{\"5\":1,\"61\":2,\"67\":1}}],[\"args\",{\"3\":{\"5\":2}}],[\"aquamarine\",{\"3\":{\"52\":1}}],[\"auto\",{\"3\":{\"50\":5}}],[\"absolute或fixed\",{\"3\":{\"32\":1}}],[\"absolute\",{\"3\":{\"29\":1,\"30\":1}}],[\"abcd法则\",{\"3\":{\"24\":1}}],[\"activated\",{\"3\":{\"268\":1}}],[\"active\",{\"3\":{\"23\":1}}],[\"action\",{\"3\":{\"203\":2}}],[\"access\",{\"3\":{\"16\":4}}],[\"after\",{\"3\":{\"23\":1}}],[\"aad12c32\",{\"0\":{\"23\":1,\"24\":1,\"25\":1,\"26\":1}}],[\"at\",{\"3\":{\"16\":1}}],[\"alive组件包裹的组件\",{\"3\":{\"278\":1}}],[\"alive下的组件生命周期\",{\"0\":{\"278\":1}}],[\"alive和memo都是用来优化性能的\",{\"3\":{\"277\":1}}],[\"alive可以接受三个属性\",{\"3\":{\"275\":1}}],[\"alive是将组件缓存起来\",{\"3\":{\"277\":1}}],[\"alive是否类似于react中的memo\",{\"0\":{\"277\":1}}],[\"alive是惰性的\",{\"3\":{\"275\":1}}],[\"alive是vue内置的一个组件\",{\"3\":{\"275\":1}}],[\"alive包裹动态组件时\",{\"3\":{\"275\":1}}],[\"alive\",{\"2\":{\"275\":1,\"277\":1,\"278\":1}}],[\"alive的是什么\",{\"0\":{\"275\":1}}],[\"alive中组件被移除时调用\",{\"3\":{\"268\":1,\"274\":1}}],[\"alive中组件被激活时调用\",{\"3\":{\"268\":1,\"274\":1}}],[\"align\",{\"3\":{\"25\":2,\"49\":2,\"50\":1}}],[\"alex\",{\"3\":{\"223\":1}}],[\"alert\",{\"3\":{\"15\":1}}],[\"all遇到错误的时候是怎么做的\",{\"3\":{\"85\":1}}],[\"all\",{\"3\":{\"79\":5,\"85\":1}}],[\"allow\",{\"3\":{\"16\":6}}],[\"app\",{\"3\":{\"67\":1,\"183\":9,\"188\":2,\"189\":2,\"190\":2,\"196\":1,\"197\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1,\"206\":1,\"218\":1,\"228\":1,\"229\":1,\"240\":1,\"242\":1,\"243\":1}}],[\"appendchild\",{\"3\":{\"15\":1}}],[\"apply的使用场景\",{\"3\":{\"83\":1}}],[\"apply\",{\"2\":{\"83\":1},\"3\":{\"5\":1,\"82\":1,\"83\":5}}],[\"ajax请求只能发给同源的网址\",{\"3\":{\"13\":1}}],[\"age+\",{\"3\":{\"160\":1}}],[\"age的作用一样\",{\"3\":{\"8\":1}}],[\"age\",{\"3\":{\"5\":3,\"8\":1,\"62\":2,\"65\":6,\"66\":7,\"67\":2,\"70\":4,\"71\":4,\"72\":8,\"159\":15,\"160\":12,\"249\":1,\"250\":4,\"252\":1,\"253\":1}}],[\"a\",{\"3\":{\"4\":5,\"5\":4,\"24\":3,\"57\":7,\"58\":3,\"59\":3,\"60\":3,\"64\":2,\"66\":2,\"67\":2,\"83\":2,\"122\":2,\"127\":1,\"132\":3,\"133\":5,\"145\":1,\"223\":1}}],[\"fetch\",{\"3\":{\"264\":1}}],[\"fetcharticles\",{\"3\":{\"243\":1}}],[\"from\",{\"3\":{\"183\":2,\"190\":2,\"196\":1,\"197\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1,\"206\":2,\"218\":1,\"221\":1,\"222\":3,\"223\":5,\"234\":1,\"235\":2,\"240\":1,\"242\":2,\"243\":1}}],[\"ftp\",{\"3\":{\"164\":1}}],[\"fixedsizelist\",{\"3\":{\"242\":1}}],[\"filber对应的是react中的fiber\",{\"3\":{\"191\":1}}],[\"filter\",{\"3\":{\"107\":1}}],[\"fiber架构的核心就是render阶段和commit阶段的分离\",{\"3\":{\"208\":1}}],[\"fiber架构的目的是为了解决react在渲染过程中\",{\"3\":{\"208\":1}}],[\"fiber是react中的一个核心算法\",{\"3\":{\"191\":1}}],[\"fiber\",{\"0\":{\"191\":1,\"192\":1},\"2\":{\"191\":1,\"192\":1},\"3\":{\"191\":21}}],[\"find\",{\"3\":{\"105\":1}}],[\"finally\",{\"3\":{\"78\":1}}],[\"fallback=\",{\"3\":{\"240\":1}}],[\"false\",{\"3\":{\"87\":1,\"119\":1,\"121\":1,\"122\":6,\"123\":1,\"134\":4,\"243\":1,\"258\":2}}],[\"family\",{\"3\":{\"25\":1}}],[\"f\",{\"3\":{\"64\":2}}],[\"flow\",{\"3\":{\"49\":1}}],[\"float\",{\"3\":{\"33\":1}}],[\"float和position类\",{\"3\":{\"25\":1}}],[\"flex\",{\"3\":{\"47\":2,\"49\":4,\"50\":11,\"52\":2}}],[\"flex布局\",{\"1\":{\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"52\":1,\"53\":1}}],[\"fd14e8e4\",{\"0\":{\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1}}],[\"foo\",{\"3\":{\"145\":2,\"147\":3}}],[\"font\",{\"3\":{\"25\":6}}],[\"foreach\",{\"3\":{\"107\":1,\"240\":3,\"242\":1}}],[\"formatting\",{\"3\":{\"31\":1}}],[\"for\",{\"3\":{\"5\":4,\"189\":1}}],[\"func\",{\"3\":{\"5\":2}}],[\"function等特殊对象\",{\"3\":{\"127\":1}}],[\"function\",{\"0\":{\"96\":1},\"2\":{\"96\":1},\"3\":{\"4\":4,\"5\":14,\"15\":1,\"57\":1,\"61\":6,\"66\":4,\"70\":2,\"72\":1,\"82\":4,\"83\":3,\"119\":1,\"141\":28,\"145\":2,\"147\":2,\"148\":1,\"152\":4,\"153\":4,\"159\":9,\"189\":1,\"197\":1,\"200\":1,\"201\":1,\"202\":2,\"203\":1,\"204\":1,\"205\":1,\"206\":4,\"218\":1,\"221\":2,\"222\":2,\"223\":3,\"228\":1,\"229\":1,\"248\":1,\"251\":1,\"252\":1,\"253\":1}}],[\"fn<t\",{\"3\":{\"251\":1,\"253\":1}}],[\"fn<t>\",{\"3\":{\"248\":1,\"252\":1}}],[\"fn4\",{\"3\":{\"66\":2}}],[\"fn\",{\"3\":{\"5\":4,\"57\":2,\"61\":6,\"66\":2,\"82\":8}}],[\"fn3\",{\"3\":{\"4\":11,\"66\":2}}],[\"fn2\",{\"3\":{\"4\":5,\"61\":2,\"66\":2,\"83\":3}}],[\"fn1\",{\"3\":{\"4\":8,\"5\":2,\"83\":3,\"147\":2}}],[\"注意\",{\"3\":{\"141\":1}}],[\"注意区分后代选择器和兄弟选择器的区别\",{\"3\":{\"23\":1}}],[\"注意清除定时器\",{\"3\":{\"3\":1}}],[\"注意闭包中的变量是否会被使用\",{\"3\":{\"3\":1}}],[\"如width\",{\"3\":{\"42\":1}}],[\"如screen\",{\"3\":{\"42\":1}}],[\"如何优化首页加载速度\",{\"3\":{\"237\":1}}],[\"如何写出一个惊艳面试官的深拷贝\",{\"3\":{\"129\":1}}],[\"如何适配移动端\",{\"3\":{\"85\":1}}],[\"如何做到的\",{\"3\":{\"85\":1}}],[\"如何避免\",{\"0\":{\"39\":1},\"2\":{\"39\":1}}],[\"如何创建bfc\",{\"0\":{\"32\":1},\"2\":{\"32\":1}}],[\"如何解决跨域\",{\"0\":{\"14\":1},\"2\":{\"14\":1}}],[\"如何处理\",{\"0\":{\"3\":1},\"2\":{\"3\":1}}],[\"如何处理内存泄漏问题\",{\"0\":{\"1\":1},\"2\":{\"1\":1}}],[\"如果组件的名字和is匹配\",{\"3\":{\"275\":1}}],[\"如果需要修改数据\",{\"3\":{\"266\":1,\"272\":1}}],[\"如果需要进行dom操作\",{\"3\":{\"264\":1}}],[\"如果需要加参数\",{\"3\":{\"222\":1}}],[\"如果创建的\",{\"3\":{\"225\":1}}],[\"如果你使用的是利用变量提升的方式\",{\"3\":{\"223\":1}}],[\"如果返回null\",{\"3\":{\"215\":1}}],[\"如果返回false\",{\"3\":{\"212\":1}}],[\"如果两个对象不相等\",{\"3\":{\"212\":1}}],[\"如果两个对象相等\",{\"3\":{\"212\":1}}],[\"如果两方都是object\",{\"3\":{\"121\":1}}],[\"如果渲染任务过多\",{\"3\":{\"208\":1}}],[\"如果http请求的消息体较大\",{\"3\":{\"173\":1}}],[\"如果有\",{\"3\":{\"171\":1,\"172\":1}}],[\"如果是搜索内容\",{\"3\":{\"171\":1}}],[\"如果是一个promise对象\",{\"3\":{\"79\":1}}],[\"如果是一个值\",{\"3\":{\"79\":1}}],[\"如果全局作用域也没有找到\",{\"3\":{\"144\":1,\"145\":1}}],[\"如果已经拷贝过了\",{\"3\":{\"127\":1}}],[\"如果属性是引用类型\",{\"3\":{\"125\":1}}],[\"如果属性是基本类型\",{\"3\":{\"125\":1}}],[\"如果类型相同\",{\"3\":{\"122\":1,\"123\":1}}],[\"如果类型不同\",{\"3\":{\"122\":1,\"123\":1}}],[\"如果一方是object\",{\"3\":{\"121\":1}}],[\"如果一方是布尔值或者是字符串\",{\"3\":{\"121\":1}}],[\"如果包含\",{\"3\":{\"114\":2}}],[\"如果没有\",{\"3\":{\"171\":1,\"172\":1}}],[\"如果没有找到\",{\"3\":{\"144\":1,\"145\":1}}],[\"如果没有初始值\",{\"3\":{\"107\":1}}],[\"如果没有发生变化\",{\"3\":{\"8\":2,\"9\":1}}],[\"如果第一个字符就不可以转化\",{\"3\":{\"87\":1}}],[\"如果数组中的某一个promise对象变为rejected状态\",{\"3\":{\"79\":2}}],[\"如果不借助任何外力\",{\"3\":{\"223\":1}}],[\"如果不在一个文件里面\",{\"3\":{\"202\":1}}],[\"如果不是\",{\"3\":{\"141\":1}}],[\"如果不存在\",{\"3\":{\"105\":1}}],[\"如果不写\",{\"3\":{\"71\":1}}],[\"如果不会被使用\",{\"3\":{\"3\":1}}],[\"如果解构不成功\",{\"3\":{\"64\":1}}],[\"如果访问\",{\"3\":{\"58\":1}}],[\"如果希望弹箱项目会根据位置和大小进行缩小\",{\"3\":{\"50\":1}}],[\"如果希望弹性项目可以占据多余空间\",{\"3\":{\"50\":1}}],[\"如果遇到了css\",{\"3\":{\"37\":1,\"38\":1}}],[\"如果服务器允许\",{\"3\":{\"16\":1}}],[\"如果服务器的时间和浏览器的时间不一致\",{\"3\":{\"8\":1}}],[\"如果发生了变化\",{\"3\":{\"9\":1}}],[\"如果资源没有发生变化\",{\"3\":{\"7\":1}}],[\"避免使用\",{\"3\":{\"3\":1}}],[\"声明变量\",{\"3\":{\"3\":1}}],[\"和react16\",{\"3\":{\"216\":1}}],[\"和string\",{\"3\":{\"118\":1}}],[\"和splice\",{\"3\":{\"104\":1}}],[\"和number\",{\"3\":{\"87\":1,\"118\":1}}],[\"和math\",{\"3\":{\"83\":2}}],[\"和max\",{\"3\":{\"8\":1}}],[\"和vh\",{\"3\":{\"27\":1}}],[\"和\",{\"0\":{\"54\":2,\"134\":1,\"135\":1},\"2\":{\"45\":1,\"54\":2,\"83\":2,\"134\":1,\"135\":1},\"3\":{\"3\":1,\"10\":1,\"89\":1,\"118\":1,\"122\":6}}],[\"未清理的定时器或者回调函数\",{\"3\":{\"2\":1}}],[\"循环引用\",{\"3\":{\"2\":1}}],[\"闭包中内部函数可以访问外部变量的原因\",{\"3\":{\"147\":1}}],[\"闭包就是在作用域链中查找变量的一种机制\",{\"3\":{\"145\":1}}],[\"闭包进行延迟执行\",{\"3\":{\"5\":1}}],[\"闭包可以用来延迟函数的执行\",{\"3\":{\"5\":1}}],[\"闭包可以用来封装私有变量\",{\"3\":{\"5\":1}}],[\"闭包可以用来模拟块级作用域\",{\"3\":{\"5\":1}}],[\"闭包的应用\",{\"0\":{\"5\":1},\"2\":{\"5\":1}}],[\"闭包的另一个特性是\",{\"3\":{\"4\":1}}],[\"闭包是指有权访问另一个函数作用域中的变量的函数\",{\"3\":{\"4\":1}}],[\"闭包\",{\"0\":{\"4\":1,\"147\":1},\"2\":{\"4\":1,\"147\":1},\"3\":{\"2\":1,\"3\":1,\"85\":1}}],[\"vs\",{\"1\":{\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"261\":1,\"262\":1}}],[\"void\",{\"3\":{\"191\":1}}],[\"vue生命周期图\",{\"3\":{\"274\":1}}],[\"vue3\",{\"0\":{\"269\":1},\"2\":{\"269\":1}}],[\"vuex\",{\"3\":{\"264\":1}}],[\"vue2\",{\"0\":{\"263\":1},\"2\":{\"263\":1}}],[\"vue篇\",{\"1\":{\"255\":1}}],[\"vue\",{\"0\":{\"183\":1},\"2\":{\"183\":1},\"3\":{\"183\":2,\"274\":1}}],[\"value=\",{\"3\":{\"202\":1,\"225\":1,\"228\":1}}],[\"valueof\",{\"3\":{\"121\":1}}],[\"value\",{\"3\":{\"87\":1,\"145\":3,\"147\":2,\"206\":1,\"228\":1,\"229\":1}}],[\"var和let声明的变量是可变的\",{\"3\":{\"60\":2}}],[\"var声明的变量可以被重复声明\",{\"3\":{\"59\":2}}],[\"var声明的变量会被提升到代码的最前面\",{\"3\":{\"58\":1}}],[\"var声明的变量在全局作用域和块级作用域中都可以访问到\",{\"3\":{\"57\":1}}],[\"var是\",{\"3\":{\"55\":1}}],[\"variant\",{\"3\":{\"25\":1}}],[\"var定义的变量会具有变量提升的特性\",{\"3\":{\"5\":1}}],[\"var\",{\"0\":{\"54\":1},\"2\":{\"54\":1},\"3\":{\"3\":1,\"4\":4,\"5\":8,\"15\":1,\"57\":3,\"58\":1,\"59\":2,\"60\":1,\"145\":2,\"147\":1}}],[\"viewport\",{\"3\":{\"239\":1}}],[\"viewport是什么\",{\"3\":{\"85\":1}}],[\"visibility\",{\"3\":{\"25\":1,\"29\":1,\"30\":1}}],[\"vm是相对于视窗的高度和宽度来计算的\",{\"3\":{\"27\":1}}],[\"vm的区别\",{\"3\":{\"27\":1}}],[\"vm\",{\"3\":{\"27\":1}}],[\"vh\",{\"3\":{\"27\":2}}],[\"vertical\",{\"3\":{\"25\":1}}],[\"v\",{\"0\":{\"0\":1,\"1\":1,\"2\":1,\"3\":1,\"4\":1,\"5\":1,\"6\":1,\"7\":1,\"8\":1,\"9\":1,\"10\":1,\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"16\":1,\"17\":1,\"18\":1,\"19\":1,\"20\":1,\"21\":1,\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"41\":1,\"42\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"55\":1,\"56\":1,\"57\":1,\"58\":1,\"59\":1,\"60\":1,\"61\":1,\"62\":1,\"63\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":1,\"69\":1,\"70\":1,\"71\":1,\"72\":1,\"73\":1,\"74\":1,\"75\":1,\"76\":1,\"77\":1,\"78\":1,\"79\":1,\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"88\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1,\"96\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"116\":1,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"130\":1,\"131\":1,\"132\":1,\"133\":1,\"134\":1,\"135\":1,\"136\":1,\"137\":1,\"138\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"143\":1,\"144\":1,\"145\":1,\"146\":1,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"151\":1,\"152\":1,\"153\":1,\"154\":1,\"155\":1,\"156\":1,\"157\":1,\"158\":1,\"159\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"171\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":1,\"182\":1,\"183\":1,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"188\":1,\"189\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":1,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"198\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1,\"206\":1,\"207\":1,\"208\":1,\"209\":1,\"210\":1,\"211\":1,\"212\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":1,\"217\":1,\"218\":1,\"219\":1,\"220\":1,\"221\":1,\"222\":1,\"223\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"229\":1,\"230\":1,\"231\":1,\"232\":1,\"233\":1,\"234\":1,\"235\":1,\"236\":1,\"237\":1,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":1,\"245\":1,\"246\":1,\"247\":1,\"248\":1,\"249\":1,\"250\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":1,\"255\":1,\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"261\":1,\"262\":1,\"263\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":1,\"271\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":1,\"276\":1,\"277\":1,\"278\":1,\"279\":1,\"280\":1,\"281\":1,\"282\":1,\"283\":1},\"1\":{\"256\":2,\"257\":2,\"258\":2,\"259\":2,\"260\":2,\"261\":2,\"262\":2},\"3\":{\"256\":2,\"258\":6,\"259\":2,\"260\":2,\"261\":2}}]],\"serializationVersion\":2}}")).map(([a,t])=>[a,xt.loadJSON(t,{fields:["title","header","text","customFields"],storeFields:["title","header","text","customFields"]})]));self.onmessage=({data:{query:a,locale:t,options:e}})=>{self.postMessage(Vt(a,Lt[t],e))};
//# sourceMappingURL=index.js.map
